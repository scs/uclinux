#! /usr/bin/env bash
# This script is used to tag the working directory including adjustment of version #defines.

# Information about adapting this script:
#
#	This script reads the version string form the command line, parses is and calls the function 'update_files' with the version string, the major and minor version, patch and release candidate number as arguments. The function should update all files that hold this information for the application and put theire pathes on standard out. This script then commits these files and makes a tag according to the version string.
#
# 	The version argument is parsed according to the following EBNF expression:
#		
#		version := "v" <major> : non-negative-number "." <minor> : non-negative-number [ "-p" <patch> : positive-number ] [ "-RC" <rc> : positive-number ]
#			non-negative-number := "0" | positive-number
#			positive-number := ( digit { digit } ) ^ ( "0" ? )
#			digit := "0" .. "9"
#	
#		Or this regular expression:
#			v(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(-p([1-9][0-9]*))?(-RC([1-9][0-9]*))?

print() { echo "$1" >&2; }
inform() { print "$0: $1"; }
warn() { print "Warning: $1"; }
error() { inform "Error: $1"; }
fail() { [ "$1" ] && error "$1"; exit 1; }

usage() {
	cat << EOF
Usage:
    do-tag --help
    do-tag <version>
EOF
[ "$1" ] && fail "$1"
}

help() {
	usage
	cat << EOF

Where:
    --help: Print this help.
    <version>: v<major>.<minor>[-<patch>][-RC<rc>]
    <major>: Major version number.
    <minor>: Minor version number.
    <patch>: Optional patch number.
    <rc>: Optional release candidate number.

Notes:
    This script replaces the defines holding the version information, makes a
    commit with the file and tags the commit with a  tag name of the following
    form:
    
        "release/v" <major> "." <minor> [ "-p" <patch> ]
        | "beta/v" <major> "." <minor> [ "-p" <patch> ] "-RC" <rc>
EOF
}

update_files() {
	VERSION_STRING=$1
	VERSION_MAJOR=$2
	VERSION_MINOR=$3
	VERSION_PATCH=$4
	VERSION_RC=$5
}

[ "$1" == "--help" ] && { help; exit; }

[ "$1" ] && ARG_VERSION=$1 || usage "Version specification missing!"
[ "$2" ] && usage "Too many arguments!"

VERSION_PARSER="v(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(-p([1-9][0-9]*))?(-RC([1-9][0-9]*))?"
echo "$ARG_VERSION" | grep -qxE "$VERSION_PARSER" || fail "Invalid version specification: $ARG_VERSION"
VERSION_PARSED=$(echo "$ARG_VERSION" | sed -r "s/$VERSION_PARSER/\1 \2 \4 \6/")

VERSION_MAJOR=$(echo "$VERSION_PARSED" | cut -d " " -f 1)
VERSION_MINOR=$(echo "$VERSION_PARSED" | cut -d " " -f 2)
VERSION_PATCH=$(echo "$VERSION_PARSED" | cut -d " " -f 3)
VERSION_RC=$(echo "$VERSION_PARSED" | cut -d " " -f 4)

[ "$VERSION_PATCH" ] || VERSION_PATCH=0
[ "$VERSION_RC" ] || VERSION_RC=0

update_files "$ARG_VERSION" "$VERSION_MAJOR" "$VERSION_MINOR" "$VERSION_PATCH" "$VERSION_RC" | {
	while IFS= read i; do
		print "$i"
		UPDATED_FILES=("${UPDATED_FILES[@]}" "$i")
		echo "$VERSION_MAJOR"
	done
	
	if [ $VERSION_RC -eq 0 ]; then
		TAG_NAME="release/$ARG_VERSION"
		COMMIT_MESSAGE="+ Release $ARG_VERSION"
	else
		TAG_NAME="beta/$ARG_VERSION"
		COMMIT_MESSAGE="+ Beta version $ARG_VERSION"
	fi
	
	git tag -l | grep -qxF "$TAG_NAME" && fail "Tag $TAG_NAME already exists"
	git commit --allow-empty -m "$COMMIT_MESSAGE" "${UPDATED_FILES[@]}" || exit $?
	git tag "$TAG_NAME" || exit $?
} || exit $?
