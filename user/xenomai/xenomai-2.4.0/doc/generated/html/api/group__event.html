<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Event flag group services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul>
</div>
<h1>Event flag group services.<br>
<small>
[<a class="el" href="group__native.html">Native Xenomai API.</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Event flag group services.:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__event.png" border="0" alt="" usemap="#group____event_map">
<map name="group____event_map">
<area shape="rect" href="group__native.html" title="Native Xenomai API." alt="" coords="5,5,160,32"></map></td></tr></table></center>
</div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
An event flag group is a synchronization object represented by a long-word structure; every available bit in such word can be used to map a user-defined event flag. When a flag is set, the associated event is said to have occurred. Xenomai tasks and interrupt handlers can use event flags to signal the occurrence of events to other tasks; those tasks can either wait for the events to occur in a conjunctive manner (all awaited events must have occurred to wake up), or in a disjunctive way (at least one of the awaited events must have occurred to wake up). 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksrc_2skins_2native_2event_8c.html">event.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file is part of the Xenomai project. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html#g8b0fbb2b816c62081afe86bf897c503c">rt_event_create</a> (RT_EVENT *event, const char *name, unsigned long ivalue, int mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html#gbccfea1cd018493ef5a28c6fe8e90d7c">rt_event_delete</a> (RT_EVENT *event)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html#gfda4c544f2429005c4b15de3a7ffc902">rt_event_signal</a> (RT_EVENT *event, unsigned long mask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html#g6e9f775275661d9258f8b1eb02fe4681">rt_event_wait</a> (RT_EVENT *event, unsigned long mask, unsigned long *mask_r, int mode, RTIME timeout)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html#g448889bcfd01ed892d97a0b00fdaf553">rt_event_clear</a> (RT_EVENT *event, unsigned long mask, unsigned long *mask_r)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html#gbecddf3846622df42bf95f94871f8e62">rt_event_inquire</a> (RT_EVENT *event, RT_EVENT_INFO *info)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html#g535edab31526338258479100f3e6997c">rt_event_bind</a> (RT_EVENT *event, const char *name, RTIME timeout)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event.html#ge985bb0e671e2a5e07b575fd793fde22">rt_event_unbind</a> (RT_EVENT *event)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g535edab31526338258479100f3e6997c"></a><!-- doxytag: member="event.h::rt_event_bind" ref="g535edab31526338258479100f3e6997c" args="(RT_EVENT *event, const char *name, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_bind           </td>
          <td>(</td>
          <td class="paramtype">RT_EVENT *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bind to an event flag group.<p>
This user-space only service retrieves the uniform descriptor of a given Xenomai event flag group identified by its symbolic name. If the event flag group does not exist on entry, this service blocks the caller until a event flag group of the given name is created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>A valid NULL-terminated name which identifies the event flag group to bind to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>The address of an event flag group descriptor retrieved by the operation. Contents of this memory is undefined upon failure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for the registration to occur (see note). Passing TM_INFINITE causes the caller to block indefinitely until the object is registered. Passing TM_NONBLOCK causes the service to return immediately without waiting if the object is not registered on entry.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EFAULT is returned if <em>event</em> or <em>name</em> is referencing invalid memory.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g770281eeca009c0a08a7c4a9fd849ac1">rt_task_unblock()</a> has been called for the waiting task before the retrieval has completed.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the searched object is not registered on entry.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if the object cannot be retrieved within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g448889bcfd01ed892d97a0b00fdaf553"></a><!-- doxytag: member="event.c::rt_event_clear" ref="g448889bcfd01ed892d97a0b00fdaf553" args="(RT_EVENT *event, unsigned long mask, unsigned long *mask_r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_clear           </td>
          <td>(</td>
          <td class="paramtype">RT_EVENT *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>mask_r</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear an event group.<p>
Clears a set of flags from an event mask.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>The descriptor address of the affected event.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>The set of events to be cleared.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask_r</em>&nbsp;</td><td>If non-NULL, <em>mask_r</em> is the address of a memory location which will be written upon success with the previous value of the event group before the flags are cleared.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>event</em> is not an event group descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>event</em> is a deleted event group descriptor.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g8b0fbb2b816c62081afe86bf897c503c"></a><!-- doxytag: member="event.c::rt_event_create" ref="g8b0fbb2b816c62081afe86bf897c503c" args="(RT_EVENT *event, const char *name, unsigned long ivalue, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_create           </td>
          <td>(</td>
          <td class="paramtype">RT_EVENT *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>ivalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an event group.<p>
Event groups provide for task synchronization by allowing a set of flags (or "events") to be waited for and posted atomically. An event group contains a mask of received events; any set of bits from the event mask can be pended or posted in a single operation.<p>
Tasks can wait for a conjunctive (AND) or disjunctive (OR) set of events to occur. A task pending on an event group in conjunctive mode is woken up as soon as all awaited events are set in the event mask. A task pending on an event group in disjunctive mode is woken up as soon as any awaited event is set in the event mask.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>The address of an event group descriptor Xenomai will use to store the event-related data. This descriptor must always be valid while the group is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the group. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created event group.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ivalue</em>&nbsp;</td><td>The initial value of the group's event mask.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The event group creation mode. The following flags can be OR'ed into this bitmask, each of them affecting the new group:</td></tr>
  </table>
</dl>
<ul>
<li>EV_FIFO makes tasks pend in FIFO order on the event group.</li></ul>
<p>
<ul>
<li>EV_PRIO makes tasks pend in priority order on the event group.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EEXIST is returned if the <em>name</em> is already in use by some registered object.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li></ul>
<p>
<ul>
<li>-ENOMEM is returned if the system fails to get enough dynamic memory from the global real-time heap in order to register the event group.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="gbccfea1cd018493ef5a28c6fe8e90d7c"></a><!-- doxytag: member="event.c::rt_event_delete" ref="gbccfea1cd018493ef5a28c6fe8e90d7c" args="(RT_EVENT *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_delete           </td>
          <td>(</td>
          <td class="paramtype">RT_EVENT *&nbsp;</td>
          <td class="paramname"> <em>event</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete an event group.<p>
Destroy an event group and release all the tasks currently pending on it. An event group exists in the system since <a class="el" href="group__event.html#g8b0fbb2b816c62081afe86bf897c503c">rt_event_create()</a> has been called to create it, so this service must be called in order to destroy it afterwards.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>The descriptor address of the affected event group.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>event</em> is not a event group descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>event</em> is a deleted event group descriptor.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="gbecddf3846622df42bf95f94871f8e62"></a><!-- doxytag: member="event.c::rt_event_inquire" ref="gbecddf3846622df42bf95f94871f8e62" args="(RT_EVENT *event, RT_EVENT_INFO *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_inquire           </td>
          <td>(</td>
          <td class="paramtype">RT_EVENT *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_EVENT_INFO *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inquire about an event group.<p>
Return various information about the status of a specified event group.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>The descriptor address of the inquired event group.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>The address of a structure the event group information will be written to.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned and status information is written to the structure pointed at by <em>info</em> upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>event</em> is not a event group descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>event</em> is a deleted event group descriptor.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="gfda4c544f2429005c4b15de3a7ffc902"></a><!-- doxytag: member="event.c::rt_event_signal" ref="gfda4c544f2429005c4b15de3a7ffc902" args="(RT_EVENT *event, unsigned long mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_signal           </td>
          <td>(</td>
          <td class="paramtype">RT_EVENT *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Post an event group.<p>
Post a set of bits to the event mask. All tasks having their wait request fulfilled by the posted events are resumed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>The descriptor address of the affected event.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>The set of events to be posted.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>event</em> is not an event group descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>event</em> is a deleted event group descriptor.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="ge985bb0e671e2a5e07b575fd793fde22"></a><!-- doxytag: member="event.h::rt_event_unbind" ref="ge985bb0e671e2a5e07b575fd793fde22" args="(RT_EVENT *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_unbind           </td>
          <td>(</td>
          <td class="paramtype">RT_EVENT *&nbsp;</td>
          <td class="paramname"> <em>event</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unbind from an event flag group.<p>
This user-space only service unbinds the calling task from the event flag group object previously retrieved by a call to <a class="el" href="group__event.html#g535edab31526338258479100f3e6997c">rt_event_bind()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>The address of an event flag group descriptor to unbind from.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is always returned.</dd></dl>
This service can be called from:<p>
<ul>
<li>User-space task.</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g6e9f775275661d9258f8b1eb02fe4681"></a><!-- doxytag: member="event.c::rt_event_wait" ref="g6e9f775275661d9258f8b1eb02fe4681" args="(RT_EVENT *event, unsigned long mask, unsigned long *mask_r, int mode, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_wait           </td>
          <td>(</td>
          <td class="paramtype">RT_EVENT *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>mask_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pend on an event group.<p>
Waits for one or more events on the specified event group, either in conjunctive or disjunctive mode.<p>
If the specified set of bits is not set, the calling task is blocked. The task is not resumed until the request is fulfilled. The event bits are NOT cleared from the event group when a request is satisfied; <a class="el" href="group__event.html#g6e9f775275661d9258f8b1eb02fe4681">rt_event_wait()</a> will return immediately with success for the same event mask until <a class="el" href="group__event.html#g448889bcfd01ed892d97a0b00fdaf553">rt_event_clear()</a> is called to clear those bits.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>The descriptor address of the affected event group.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>The set of bits to wait for. Passing zero causes this service to return immediately with a success value; the current value of the event mask is also copied to <em>mask_r</em>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask_r</em>&nbsp;</td><td>The value of the event mask at the time the task was readied.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The pend mode. The following flags can be OR'ed into this bitmask, each of them affecting the operation:</td></tr>
  </table>
</dl>
<ul>
<li>EV_ANY makes the task pend in disjunctive mode (i.e. OR); this means that the request is fulfilled when at least one bit set into <em>mask</em> is set in the current event mask.</li></ul>
<p>
<ul>
<li>EV_ALL makes the task pend in conjunctive mode (i.e. AND); this means that the request is fulfilled when at all bits set into <em>mask</em> are set in the current event mask.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for fulfilling the request (see note). Passing TM_INFINITE causes the caller to block indefinitely until the request is fulfilled. Passing TM_NONBLOCK causes the service to return immediately without waiting if the request cannot be satisfied immediately.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>event</em> is not a event group descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>event</em> is a deleted event group descriptor, including if the deletion occurred while the caller was sleeping on it before the request has been satisfied.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the current event mask value does not satisfy the request.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g770281eeca009c0a08a7c4a9fd849ac1">rt_task_unblock()</a> has been called for the waiting task before the request has been satisfied.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if the request has not been satisfied within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code or Interrupt service routine only if <em>timeout</em> is equal to TM_NONBLOCK.</li><li>Kernel-based task</li><li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Dec 8 10:59:49 2007 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
