<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Synchronisation Services</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul>
</div>
<h1>Synchronisation Services<br>
<small>
[<a class="el" href="group__driverapi.html">Driver Development API</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Synchronisation Services:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__rtdmsync.png" border="0" alt="" usemap="#group____rtdmsync_map">
<map name="group____rtdmsync_map">
<area shape="rect" href="group__driverapi.html" title="Driver Development API" alt="" coords="7,5,185,32"></map></td></tr></table></center>
</div>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Spinlock with Preemption Deactivation</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb6398c5dab6f8614bc8310b2248ae0b6"></a><!-- doxytag: member="rtdmsync::rtdm_lock_t" ref="gb6398c5dab6f8614bc8310b2248ae0b6" args="" -->
typedef rthal_spinlock_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gb6398c5dab6f8614bc8310b2248ae0b6">rtdm_lock_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock variable. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7584217487c323356414e21200a57e63"></a><!-- doxytag: member="rtdmsync::rtdm_lockctx_t" ref="g7584217487c323356414e21200a57e63" args="" -->
typedef unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g7584217487c323356414e21200a57e63">rtdm_lockctx_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Variable to save the context while holding a lock. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g1dd901a6311b10ef7961b5fce7fa9d41"></a><!-- doxytag: member="rtdmsync::RTDM_LOCK_UNLOCKED" ref="g1dd901a6311b10ef7961b5fce7fa9d41" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g1dd901a6311b10ef7961b5fce7fa9d41">RTDM_LOCK_UNLOCKED</a>&nbsp;&nbsp;&nbsp;RTHAL_SPIN_LOCK_UNLOCKED</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Static lock initialisation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g6abf985ea7a0b13ec564cf0107fd8cba">rtdm_lock_init</a>(lock)&nbsp;&nbsp;&nbsp;rthal_spin_lock_init(lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamic lock initialisation.  <a href="#g6abf985ea7a0b13ec564cf0107fd8cba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g65a4897268e15bda462b871976cb3909">rtdm_lock_get</a>(lock)&nbsp;&nbsp;&nbsp;rthal_spin_lock(lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire lock from non-preemptible contexts.  <a href="#g65a4897268e15bda462b871976cb3909"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g963bdb01102d0076cd64f6bc72a347da">rtdm_lock_put</a>(lock)&nbsp;&nbsp;&nbsp;rthal_spin_unlock(lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release lock without preemption restoration.  <a href="#g963bdb01102d0076cd64f6bc72a347da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g985473873f9e32af688fe8a23634693d">rtdm_lock_get_irqsave</a>(lock, context)&nbsp;&nbsp;&nbsp;rthal_spin_lock_irqsave(lock, context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire lock and disable preemption.  <a href="#g985473873f9e32af688fe8a23634693d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g4f1f8e33baf33b162636f63dec61aebd">rtdm_lock_put_irqrestore</a>(lock, context)&nbsp;&nbsp;&nbsp;rthal_spin_unlock_irqrestore(lock, context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release lock and restore preemption state.  <a href="#g4f1f8e33baf33b162636f63dec61aebd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g3d563fc5def018f743c55c452e061758">rtdm_lock_irqsave</a>(context)&nbsp;&nbsp;&nbsp;rthal_local_irq_save(context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable preemption locally.  <a href="#g3d563fc5def018f743c55c452e061758"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ge03c387fcae8a55105dd31d7c008bbb4">rtdm_lock_irqrestore</a>(context)&nbsp;&nbsp;&nbsp;rthal_local_irq_restore(context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restore preemption state.  <a href="#ge03c387fcae8a55105dd31d7c008bbb4"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Timeout Sequence Management</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g531ddf80690059302409f760bd7f14d4">rtdm_toseq_init</a> (rtdm_toseq_t *timeout_seq, <a class="el" href="group__rtdm.html#gededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout)</td></tr>

<tr><td colspan="2"><br><h2>Event Services</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gddf08d8ba5a44668bb360070a114fb19">rtdm_event_init</a> (rtdm_event_t *event, unsigned long pending)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g7b27d0206027a07958d4a09017e8a3fe">rtdm_event_destroy</a> (rtdm_event_t *event)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g7c9745d1db8e6de244a6c2690cbb8b22">rtdm_event_pulse</a> (rtdm_event_t *event)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g1217402b82034b26fe25c26f1e5b32c9">rtdm_event_signal</a> (rtdm_event_t *event)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g1c433b50c53d49d164b084751861e855">rtdm_event_wait</a> (rtdm_event_t *event)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gf76f858a3951ca2e20d3b1e00afa17e0">rtdm_event_timedwait</a> (rtdm_event_t *event, <a class="el" href="group__rtdm.html#gededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout, rtdm_toseq_t *timeout_seq)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g732fe3cf3370df0f296f06fc4ac7f925">rtdm_event_clear</a> (rtdm_event_t *event)</td></tr>

<tr><td colspan="2"><br><h2>Semaphore Services</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ge1172824e463d7705ed3033e8aea133d">rtdm_sem_init</a> (rtdm_sem_t *sem, unsigned long value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gf16f45217e54201ff3f24753982c41f8">rtdm_sem_destroy</a> (rtdm_sem_t *sem)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g59da1b60b7279c1fc4355e2e0b2cc77c">rtdm_sem_down</a> (rtdm_sem_t *sem)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g8aadb120a93df5dfd717c5bac6d4c1a9">rtdm_sem_timeddown</a> (rtdm_sem_t *sem, <a class="el" href="group__rtdm.html#gededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout, rtdm_toseq_t *timeout_seq)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g829dbd8c5709d798ed06947b27001fed">rtdm_sem_up</a> (rtdm_sem_t *sem)</td></tr>

<tr><td colspan="2"><br><h2>Mutex Services</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g8d58a144bf71df7b38bb887d036cbbb5">rtdm_mutex_init</a> (rtdm_mutex_t *mutex)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gd13170b569d0a4cdb46072e1e3a45527">rtdm_mutex_destroy</a> (rtdm_mutex_t *mutex)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gb40ed579324d8cc76387a0e06dd0f82a">rtdm_mutex_unlock</a> (rtdm_mutex_t *mutex)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g67c8f85c844df1aeed806e343a1b6437">rtdm_mutex_lock</a> (rtdm_mutex_t *mutex)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#g0789968300701ba2a940f5fe8b1fd4d8">rtdm_mutex_timedlock</a> (rtdm_mutex_t *mutex, <a class="el" href="group__rtdm.html#gededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout, rtdm_toseq_t *timeout_seq)</td></tr>

<tr><td colspan="2"><br><h2>Global Lock across Scheduler Invocation</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gbbaf52632d5dde7fa66e0b70d887493b">RTDM_EXECUTE_ATOMICALLY</a>(code_block)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="gbbaf52632d5dde7fa66e0b70d887493b"></a><!-- doxytag: member="rtdm_driver.h::RTDM_EXECUTE_ATOMICALLY" ref="gbbaf52632d5dde7fa66e0b70d887493b" args="(code_block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_EXECUTE_ATOMICALLY          </td>
          <td>(</td>
          <td class="paramtype">code_block&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{                                               \
        &lt;ENTER_ATOMIC_SECTION&gt;                  \
        code_block;                             \
        &lt;LEAVE_ATOMIC_SECTION&gt;                  \
}
</pre></div>Execute code block atomically Generally, it is illegal to suspend the current task by calling <a class="el" href="group__rtdmtask.html#gbfae53746165a83a75965b7b0f6710a0">rtdm_task_sleep()</a>, <a class="el" href="group__rtdmsync.html#g1c433b50c53d49d164b084751861e855">rtdm_event_wait()</a>, etc. while holding a spinlock. In contrast, this macro allows to combine several operations including a potentially rescheduling call to an atomic code block with respect to other <a class="el" href="group__rtdmsync.html#gbbaf52632d5dde7fa66e0b70d887493b">RTDM_EXECUTE_ATOMICALLY()</a> blocks. The macro is a light-weight alternative for protecting code blocks via mutexes, and it can even be used to synchronise real-time and non-real-time contexts.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>code_block</em>&nbsp;</td><td>Commands to be executed atomically</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is not allowed to leave the code block explicitly by using <code>break</code>, <code>return</code>, <code>goto</code>, etc. This would leave the global lock held during the code block execution in an inconsistent state. Moreover, do not embed complex operations into the code bock. Consider that they will be executed under preemption lock with interrupts switched-off. Also note that invocation of rescheduling calls may break the atomicity until the task gains the CPU again.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible, depends on functions called within <em>code_block</em>. 
</div>
</div><p>
<a class="anchor" name="g65a4897268e15bda462b871976cb3909"></a><!-- doxytag: member="rtdm_driver.h::rtdm_lock_get" ref="g65a4897268e15bda462b871976cb3909" args="(lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_get          </td>
          <td>(</td>
          <td class="paramtype">lock&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;rthal_spin_lock(lock)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Acquire lock from non-preemptible contexts. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Address of lock variable</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g985473873f9e32af688fe8a23634693d"></a><!-- doxytag: member="rtdm_driver.h::rtdm_lock_get_irqsave" ref="g985473873f9e32af688fe8a23634693d" args="(lock, context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_get_irqsave          </td>
          <td>(</td>
          <td class="paramtype">lock,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">context&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;rthal_spin_lock_irqsave(lock, context)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Acquire lock and disable preemption. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Address of lock variable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>name of local variable to store the context in</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g6abf985ea7a0b13ec564cf0107fd8cba"></a><!-- doxytag: member="rtdm_driver.h::rtdm_lock_init" ref="g6abf985ea7a0b13ec564cf0107fd8cba" args="(lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_init          </td>
          <td>(</td>
          <td class="paramtype">lock&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;rthal_spin_lock_init(lock)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dynamic lock initialisation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Address of lock variable</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="ge03c387fcae8a55105dd31d7c008bbb4"></a><!-- doxytag: member="rtdm_driver.h::rtdm_lock_irqrestore" ref="ge03c387fcae8a55105dd31d7c008bbb4" args="(context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_irqrestore          </td>
          <td>(</td>
          <td class="paramtype">context&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;rthal_local_irq_restore(context)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Restore preemption state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>name of local variable which stored the context</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="g3d563fc5def018f743c55c452e061758"></a><!-- doxytag: member="rtdm_driver.h::rtdm_lock_irqsave" ref="g3d563fc5def018f743c55c452e061758" args="(context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_irqsave          </td>
          <td>(</td>
          <td class="paramtype">context&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;rthal_local_irq_save(context)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable preemption locally. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>name of local variable to store the context in</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g963bdb01102d0076cd64f6bc72a347da"></a><!-- doxytag: member="rtdm_driver.h::rtdm_lock_put" ref="g963bdb01102d0076cd64f6bc72a347da" args="(lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_put          </td>
          <td>(</td>
          <td class="paramtype">lock&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;rthal_spin_unlock(lock)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release lock without preemption restoration. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Address of lock variable</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g4f1f8e33baf33b162636f63dec61aebd"></a><!-- doxytag: member="rtdm_driver.h::rtdm_lock_put_irqrestore" ref="g4f1f8e33baf33b162636f63dec61aebd" args="(lock, context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_put_irqrestore          </td>
          <td>(</td>
          <td class="paramtype">lock,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">context&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;rthal_spin_unlock_irqrestore(lock, context)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release lock and restore preemption state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Address of lock variable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>name of local variable which stored the context</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g732fe3cf3370df0f296f06fc4ac7f925"></a><!-- doxytag: member="drvlib.c::rtdm_event_clear" ref="g732fe3cf3370df0f296f06fc4ac7f925" args="(rtdm_event_t *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_event_clear           </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&nbsp;</td>
          <td class="paramname"> <em>event</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear event state <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gddf08d8ba5a44668bb360070a114fb19">rtdm_event_init()</a> Environments: This service can be called from: - Kernel module initialization/cleanup code<ul>
<li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT) Rescheduling: never. </li></ul>
</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g7b27d0206027a07958d4a09017e8a3fe"></a><!-- doxytag: member="drvlib.c::rtdm_event_destroy" ref="g7b27d0206027a07958d4a09017e8a3fe" args="(rtdm_event_t *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_event_destroy           </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&nbsp;</td>
          <td class="paramname"> <em>event</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy an event <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gddf08d8ba5a44668bb360070a114fb19">rtdm_event_init()</a> Environments: This service can be called from: - Kernel module initialization/cleanup code<ul>
<li>Kernel-based task</li><li>User-space task (RT, non-RT) Rescheduling: possible. </li></ul>
</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gddf08d8ba5a44668bb360070a114fb19"></a><!-- doxytag: member="drvlib.c::rtdm_event_init" ref="gddf08d8ba5a44668bb360070a114fb19" args="(rtdm_event_t *event, unsigned long pending)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_event_init           </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>pending</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialise an event <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pending</em>&nbsp;</td><td>Non-zero if event shall be initialised as set, 0 otherwise Environments: This service can be called from: - Kernel module initialization/cleanup code<ul>
<li>Kernel-based task</li><li>User-space task (RT, non-RT) Rescheduling: never. </li></ul>
</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g7c9745d1db8e6de244a6c2690cbb8b22"></a><!-- doxytag: member="drvlib.c::rtdm_event_pulse" ref="g7c9745d1db8e6de244a6c2690cbb8b22" args="(rtdm_event_t *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_event_pulse           </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&nbsp;</td>
          <td class="paramname"> <em>event</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signal an event occurrence to currently listening waiters This function wakes up all current waiters of the given event, but it does not change the event state. Subsequently callers of <a class="el" href="group__rtdmsync.html#g1c433b50c53d49d164b084751861e855">rtdm_event_wait()</a> or <a class="el" href="group__rtdmsync.html#gf76f858a3951ca2e20d3b1e00afa17e0">rtdm_event_timedwait()</a> will therefore be blocked first.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gddf08d8ba5a44668bb360070a114fb19">rtdm_event_init()</a></td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="g1217402b82034b26fe25c26f1e5b32c9"></a><!-- doxytag: member="drvlib.c::rtdm_event_signal" ref="g1217402b82034b26fe25c26f1e5b32c9" args="(rtdm_event_t *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_event_signal           </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&nbsp;</td>
          <td class="paramname"> <em>event</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signal an event occurrence This function sets the given event and wakes up all current waiters. If no waiter is presently registered, the next call to <a class="el" href="group__rtdmsync.html#g1c433b50c53d49d164b084751861e855">rtdm_event_wait()</a> or <a class="el" href="group__rtdmsync.html#gf76f858a3951ca2e20d3b1e00afa17e0">rtdm_event_timedwait()</a> will return immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gddf08d8ba5a44668bb360070a114fb19">rtdm_event_init()</a></td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="gf76f858a3951ca2e20d3b1e00afa17e0"></a><!-- doxytag: member="drvlib.c::rtdm_event_timedwait" ref="gf76f858a3951ca2e20d3b1e00afa17e0" args="(rtdm_event_t *event, nanosecs_rel_t timeout, rtdm_toseq_t *timeout_seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_event_timedwait           </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_toseq_t *&nbsp;</td>
          <td class="paramname"> <em>timeout_seq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait on event occurrence with timeout This function waits or tests for the occurence of the given event, taking the provided timeout into account. On successful return, the event is reset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gddf08d8ba5a44668bb360070a114fb19">rtdm_event_init()</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>Relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>timeout_seq</em>&nbsp;</td><td>Handle of a timeout sequence as returned by <a class="el" href="group__rtdmsync.html#g531ddf80690059302409f760bd7f14d4">rtdm_toseq_init()</a> or NULL</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitly via <a class="el" href="group__rtdmtask.html#ge52cca97ebaf78eec2e31553a4dacd5e">rtdm_task_unblock()</a>.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>event</em> has been destroyed.</li></ul>
<p>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task (RT)</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="g1c433b50c53d49d164b084751861e855"></a><!-- doxytag: member="drvlib.c::rtdm_event_wait" ref="g1c433b50c53d49d164b084751861e855" args="(rtdm_event_t *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_event_wait           </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&nbsp;</td>
          <td class="paramname"> <em>event</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait on event occurrence This is the light-weight version of <a class="el" href="group__rtdmsync.html#gf76f858a3951ca2e20d3b1e00afa17e0">rtdm_event_timedwait()</a>, implying an infinite timeout.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gddf08d8ba5a44668bb360070a114fb19">rtdm_event_init()</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitly via <a class="el" href="group__rtdmtask.html#ge52cca97ebaf78eec2e31553a4dacd5e">rtdm_task_unblock()</a>.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>event</em> has been destroyed.</li></ul>
<p>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task (RT)</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="gd13170b569d0a4cdb46072e1e3a45527"></a><!-- doxytag: member="drvlib.c::rtdm_mutex_destroy" ref="gd13170b569d0a4cdb46072e1e3a45527" args="(rtdm_mutex_t *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_mutex_destroy           </td>
          <td>(</td>
          <td class="paramtype">rtdm_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy a mutex <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>mutex</em>&nbsp;</td><td>Mutex handle as returned by <a class="el" href="group__rtdmsync.html#g8d58a144bf71df7b38bb887d036cbbb5">rtdm_mutex_init()</a> Environments: This service can be called from: - Kernel module initialization/cleanup code<ul>
<li>Kernel-based task</li><li>User-space task (RT, non-RT) Rescheduling: possible. </li></ul>
</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g8d58a144bf71df7b38bb887d036cbbb5"></a><!-- doxytag: member="drvlib.c::rtdm_mutex_init" ref="g8d58a144bf71df7b38bb887d036cbbb5" args="(rtdm_mutex_t *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_mutex_init           </td>
          <td>(</td>
          <td class="paramtype">rtdm_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialise a mutex This function initalises a basic mutex with priority inversion protection. "Basic", as it does not allow a mutex owner to recursively lock the same mutex again.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>mutex</em>&nbsp;</td><td>Mutex handle</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g67c8f85c844df1aeed806e343a1b6437"></a><!-- doxytag: member="drvlib.c::rtdm_mutex_lock" ref="g67c8f85c844df1aeed806e343a1b6437" args="(rtdm_mutex_t *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_mutex_lock           </td>
          <td>(</td>
          <td class="paramtype">rtdm_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Request a mutex This is the light-weight version of <a class="el" href="group__rtdmsync.html#g0789968300701ba2a940f5fe8b1fd4d8">rtdm_mutex_timedlock()</a>, implying an infinite timeout.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>mutex</em>&nbsp;</td><td>Mutex handle as returned by <a class="el" href="group__rtdmsync.html#g8d58a144bf71df7b38bb887d036cbbb5">rtdm_mutex_init()</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EIDRM is returned if <em>mutex</em> has been destroyed.</li></ul>
<p>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task (RT)</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="g0789968300701ba2a940f5fe8b1fd4d8"></a><!-- doxytag: member="drvlib.c::rtdm_mutex_timedlock" ref="g0789968300701ba2a940f5fe8b1fd4d8" args="(rtdm_mutex_t *mutex, nanosecs_rel_t timeout, rtdm_toseq_t *timeout_seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_mutex_timedlock           </td>
          <td>(</td>
          <td class="paramtype">rtdm_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_toseq_t *&nbsp;</td>
          <td class="paramname"> <em>timeout_seq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Request a mutex with timeout This function tries to acquire the given mutex. If it is not available, the caller is blocked unless non-blocking operation was selected.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>mutex</em>&nbsp;</td><td>Mutex handle as returned by <a class="el" href="group__rtdmsync.html#g8d58a144bf71df7b38bb887d036cbbb5">rtdm_mutex_init()</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>Relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>timeout_seq</em>&nbsp;</td><td>Handle of a timeout sequence as returned by <a class="el" href="group__rtdmsync.html#g531ddf80690059302409f760bd7f14d4">rtdm_toseq_init()</a> or NULL</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is negative and the semaphore value is currently not positive.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>mutex</em> has been destroyed.</li></ul>
<p>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task (RT)</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="gb40ed579324d8cc76387a0e06dd0f82a"></a><!-- doxytag: member="drvlib.c::rtdm_mutex_unlock" ref="gb40ed579324d8cc76387a0e06dd0f82a" args="(rtdm_mutex_t *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_mutex_unlock           </td>
          <td>(</td>
          <td class="paramtype">rtdm_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release a mutex This function releases the given mutex, waking up a potential waiter which was blocked upon <a class="el" href="group__rtdmsync.html#g67c8f85c844df1aeed806e343a1b6437">rtdm_mutex_lock()</a> or <a class="el" href="group__rtdmsync.html#g0789968300701ba2a940f5fe8b1fd4d8">rtdm_mutex_timedlock()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>mutex</em>&nbsp;</td><td>Mutex handle as returned by <a class="el" href="group__rtdmsync.html#g8d58a144bf71df7b38bb887d036cbbb5">rtdm_mutex_init()</a></td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task (RT)</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="gf16f45217e54201ff3f24753982c41f8"></a><!-- doxytag: member="drvlib.c::rtdm_sem_destroy" ref="gf16f45217e54201ff3f24753982c41f8" args="(rtdm_sem_t *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_sem_destroy           </td>
          <td>(</td>
          <td class="paramtype">rtdm_sem_t *&nbsp;</td>
          <td class="paramname"> <em>sem</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy a semaphore <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#ge1172824e463d7705ed3033e8aea133d">rtdm_sem_init()</a> Environments: This service can be called from: - Kernel module initialization/cleanup code<ul>
<li>Kernel-based task</li><li>User-space task (RT, non-RT) Rescheduling: possible. </li></ul>
</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g59da1b60b7279c1fc4355e2e0b2cc77c"></a><!-- doxytag: member="drvlib.c::rtdm_sem_down" ref="g59da1b60b7279c1fc4355e2e0b2cc77c" args="(rtdm_sem_t *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_sem_down           </td>
          <td>(</td>
          <td class="paramtype">rtdm_sem_t *&nbsp;</td>
          <td class="paramname"> <em>sem</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decrement a semaphore This is the light-weight version of <a class="el" href="group__rtdmsync.html#g8aadb120a93df5dfd717c5bac6d4c1a9">rtdm_sem_timeddown()</a>, implying an infinite timeout.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#ge1172824e463d7705ed3033e8aea133d">rtdm_sem_init()</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitly via <a class="el" href="group__rtdmtask.html#ge52cca97ebaf78eec2e31553a4dacd5e">rtdm_task_unblock()</a>.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>sem</em> has been destroyed.</li></ul>
<p>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task (RT)</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="ge1172824e463d7705ed3033e8aea133d"></a><!-- doxytag: member="drvlib.c::rtdm_sem_init" ref="ge1172824e463d7705ed3033e8aea133d" args="(rtdm_sem_t *sem, unsigned long value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_sem_init           </td>
          <td>(</td>
          <td class="paramtype">rtdm_sem_t *&nbsp;</td>
          <td class="paramname"> <em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialise a semaphore <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>Semaphore handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Initial value of the semaphore Environments: This service can be called from: - Kernel module initialization/cleanup code<ul>
<li>Kernel-based task</li><li>User-space task (RT, non-RT) Rescheduling: never. </li></ul>
</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g8aadb120a93df5dfd717c5bac6d4c1a9"></a><!-- doxytag: member="drvlib.c::rtdm_sem_timeddown" ref="g8aadb120a93df5dfd717c5bac6d4c1a9" args="(rtdm_sem_t *sem, nanosecs_rel_t timeout, rtdm_toseq_t *timeout_seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_sem_timeddown           </td>
          <td>(</td>
          <td class="paramtype">rtdm_sem_t *&nbsp;</td>
          <td class="paramname"> <em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_toseq_t *&nbsp;</td>
          <td class="paramname"> <em>timeout_seq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decrement a semaphore with timeout This function tries to decrement the given semphore's value if it is positive on entry. If not, the caller is blocked unless non-blocking operation was selected.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#ge1172824e463d7705ed3033e8aea133d">rtdm_sem_init()</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>Relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>timeout_seq</em>&nbsp;</td><td>Handle of a timeout sequence as returned by <a class="el" href="group__rtdmsync.html#g531ddf80690059302409f760bd7f14d4">rtdm_toseq_init()</a> or NULL</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is negative and the semaphore value is currently not positive.</li></ul>
<p>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitly via <a class="el" href="group__rtdmtask.html#ge52cca97ebaf78eec2e31553a4dacd5e">rtdm_task_unblock()</a>.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>sem</em> has been destroyed.</li></ul>
<p>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task (RT)</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="g829dbd8c5709d798ed06947b27001fed"></a><!-- doxytag: member="drvlib.c::rtdm_sem_up" ref="g829dbd8c5709d798ed06947b27001fed" args="(rtdm_sem_t *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_sem_up           </td>
          <td>(</td>
          <td class="paramtype">rtdm_sem_t *&nbsp;</td>
          <td class="paramname"> <em>sem</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Increment a semaphore This function increments the given semphore's value, waking up a potential waiter which was blocked upon <a class="el" href="group__rtdmsync.html#g59da1b60b7279c1fc4355e2e0b2cc77c">rtdm_sem_down()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#ge1172824e463d7705ed3033e8aea133d">rtdm_sem_init()</a></td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task (RT, non-RT)</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="g531ddf80690059302409f760bd7f14d4"></a><!-- doxytag: member="drvlib.c::rtdm_toseq_init" ref="g531ddf80690059302409f760bd7f14d4" args="(rtdm_toseq_t *timeout_seq, nanosecs_rel_t timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_toseq_init           </td>
          <td>(</td>
          <td class="paramtype">rtdm_toseq_t *&nbsp;</td>
          <td class="paramname"> <em>timeout_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialise a timeout sequence This service initialises a timeout sequence handle according to the given timeout value. Timeout sequences allow to maintain a continuous <em>timeout</em> across multiple calls of blocking synchronisation services. A typical application scenario is given below.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>timeout_seq</em>&nbsp;</td><td>Timeout sequence handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>Relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values</td></tr>
  </table>
</dl>
Application Scenario: <div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> device_service_routine(...)
{
        rtdm_toseq_t timeout_seq;
        ...

        <a class="code" href="group__rtdmsync.html#g531ddf80690059302409f760bd7f14d4">rtdm_toseq_init</a>(&amp;timeout_seq, timeout);
        ...
        <span class="keywordflow">while</span> (received &lt; requested) {
                ret = <a class="code" href="group__rtdmsync.html#gf76f858a3951ca2e20d3b1e00afa17e0">rtdm_event_timedwait</a>(&amp;data_available, timeout, &amp;timeout_seq);
                <span class="keywordflow">if</span> (ret &lt; 0) <span class="comment">// including -ETIMEDOUT</span>
                        <span class="keywordflow">break</span>;

                <span class="comment">// receive some data</span>
                ...
        }
        ...
}
</pre></div> Using a timeout sequence in such a scenario avoids that the user-provided relative <code>timeout</code> is restarted on every call to <a class="el" href="group__rtdmsync.html#gf76f858a3951ca2e20d3b1e00afa17e0">rtdm_event_timedwait()</a>, potentially causing an overall delay that is larger than specified by <code>timeout</code>. Moreover, all functions supporting timeout sequences also interpret special timeout values (infinite and non-blocking), disburdening the driver developer from handling them separately.<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task (RT)</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Dec 8 10:59:50 2007 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
