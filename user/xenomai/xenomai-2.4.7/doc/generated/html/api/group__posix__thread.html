<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Threads management services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Threads management services.<br>
<small>
[<a class="el" href="group__posix.html">POSIX skin.</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Threads management services.:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__posix__thread.png" border="0" alt="" usemap="#group____posix____thread_map">
<map name="group____posix____thread_map">
<area shape="rect" href="group__posix__cancel.html" title="Thread cancellation." alt="" coords="429,6,568,30"><area shape="rect" href="group__posix__sched.html" title="Thread scheduling services." alt="" coords="403,54,595,78"><area shape="rect" href="group__posix__threadattr.html" title="Thread creation attributes." alt="" coords="412,102,585,126"><area shape="rect" href="group__posix.html" title="Xenomai POSIX skin is an implementation of a small subset of the Single Unix specification..." alt="" coords="7,54,100,78"></map></td></tr></table></center>
</div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Threads management services. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/xsh_chap02_09.html#tag_02_09">Specification.</a> </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__cancel.html">Thread cancellation.</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread cancellation. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__sched.html">Threads scheduling services.</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread scheduling services. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__threadattr.html">Thread creation attributes.</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread creation attributes. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#gfb4c3f58a873bfe7f44aa37919437320">pthread_once</a> (pthread_once_t *once, void(*init_routine)(void))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute an initialization routine.  <a href="#gfb4c3f58a873bfe7f44aa37919437320"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ge6e819ed048e4c4a4ee96fa6f426852c">pthread_create</a> (pthread_t *tid, const pthread_attr_t *attr, void *(*start)(void *), void *arg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a thread.  <a href="#ge6e819ed048e4c4a4ee96fa6f426852c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#g7c275c509c26566b6dd95a2de1668a2f">pthread_detach</a> (pthread_t thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach a running thread.  <a href="#g7c275c509c26566b6dd95a2de1668a2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#g98ec817164a6641eda2341de473b659d">pthread_equal</a> (pthread_t t1, pthread_t t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare thread identifiers.  <a href="#g98ec817164a6641eda2341de473b659d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#g090bdc13141e76205fab4cb3c5fab0e4">pthread_exit</a> (void *value_ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Terminate the current thread.  <a href="#g090bdc13141e76205fab4cb3c5fab0e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga79c99cc7b194918a2def257246f11c6">pthread_join</a> (pthread_t thread, void **value_ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for termination of a specified thread.  <a href="#ga79c99cc7b194918a2def257246f11c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">pthread_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#g4c4f5f3b4f8f45d9d897847d53b11aaa">pthread_self</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the identifier of the calling thread.  <a href="#g4c4f5f3b4f8f45d9d897847d53b11aaa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#gfe8deaa3c89e0a07e59f0e58f9ec1473">pthread_make_periodic_np</a> (pthread_t thread, struct timespec *starttp, struct timespec *periodtp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a thread periodic.  <a href="#gfe8deaa3c89e0a07e59f0e58f9ec1473"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#g1f18e6e7dd5342463ca8546ef3a36c34">pthread_wait_np</a> (unsigned long *overruns_r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for current thread next period.  <a href="#g1f18e6e7dd5342463ca8546ef3a36c34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#g9dd3db5524fccb05a8868b7c33ccaa79">pthread_set_mode_np</a> (int clrmask, int setmask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the mode of the current thread.  <a href="#g9dd3db5524fccb05a8868b7c33ccaa79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#g414a759c928f7be7ac105980d8e73431">pthread_set_name_np</a> (pthread_t thread, const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a thread name.  <a href="#g414a759c928f7be7ac105980d8e73431"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ge6e819ed048e4c4a4ee96fa6f426852c"></a><!-- doxytag: member="thread.c::pthread_create" ref="ge6e819ed048e4c4a4ee96fa6f426852c" args="(pthread_t *tid, const pthread_attr_t *attr, void *(*start)(void *), void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_create           </td>
          <td>(</td>
          <td class="paramtype">pthread_t *&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pthread_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a thread. 
<p>
This service create a thread. The created thread may be used with all POSIX skin services.<p>
The new thread run the <em>start</em> routine, with the <em>arg</em> argument.<p>
The new thread signal mask is inherited from the current thread, if it was also created with <a class="el" href="group__posix__thread.html#ge6e819ed048e4c4a4ee96fa6f426852c" title="Create a thread.">pthread_create()</a>, otherwise the new thread signal mask is empty.<p>
Other attributes of the new thread depend on the <em>attr</em> argument. If <em>attr</em> is null, default values for these attributes are used. See <a class="el" href="group__posix__threadattr.html">Thread creation attributes.</a> for a definition of thread creation attributes and their default values.<p>
Returning from the <em>start</em> routine has the same effect as calling <a class="el" href="group__posix__thread.html#g090bdc13141e76205fab4cb3c5fab0e4" title="Terminate the current thread.">pthread_exit()</a> with the return value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>address where the identifier of the new thread will be stored on success;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>thread attributes;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>thread routine;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>thread routine argument.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EINVAL, <em>attr</em> is invalid;</li><li>EAGAIN, insufficient memory exists in the system heap to create a new thread, increase CONFIG_XENO_OPT_SYS_HEAPSZ;</li><li>EINVAL, thread attribute <em>inheritsched</em> is set to PTHREAD_INHERIT_SCHED and the calling thread does not belong to the POSIX skin;</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_create.html">Specification.</a> </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="rtcan__rtt_8c-example.html#a21">rtcan_rtt.c</a>.</dl>
<p>References <a class="el" href="sched_8c-source.html#l00184">pthread_getschedparam()</a>, <a class="el" href="include_2nucleus_2thread_8h-source.html#l00059">XNFPU</a>, <a class="el" href="pod_8c-source.html#l00680">xnpod_init_thread()</a>, <a class="el" href="pod_8c-source.html#l00794">xnpod_start_thread()</a>, <a class="el" href="include_2nucleus_2thread_8h-source.html#l00048">XNRRB</a>, <a class="el" href="include_2nucleus_2thread_8h-source.html#l00060">XNSHADOW</a>, and <a class="el" href="synch_8c-source.html#l00087">xnsynch_init()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g7c275c509c26566b6dd95a2de1668a2f"></a><!-- doxytag: member="thread.c::pthread_detach" ref="g7c275c509c26566b6dd95a2de1668a2f" args="(pthread_t thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_detach           </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detach a running thread. 
<p>
This service detaches a joinable thread. A detached thread is a thread which control block is automatically reclaimed when it terminates. The control block of a joinable thread, on the other hand, is only reclaimed when joined with the service <a class="el" href="group__posix__thread.html#ga79c99cc7b194918a2def257246f11c6" title="Wait for termination of a specified thread.">pthread_join()</a>.<p>
If some threads are currently blocked in the <a class="el" href="group__posix__thread.html#ga79c99cc7b194918a2def257246f11c6" title="Wait for termination of a specified thread.">pthread_join()</a> service with <em>thread</em> as a target, they are unblocked and <a class="el" href="group__posix__thread.html#ga79c99cc7b194918a2def257246f11c6" title="Wait for termination of a specified thread.">pthread_join()</a> returns EINVAL.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>target thread.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is an invalid thread identifier;</li><li>EINVAL, <em>thread</em> is not joinable.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_detach.html">Specification.</a> </dd></dl>

<p>References <a class="el" href="pod_8c-source.html#l02376">xnpod_schedule()</a>, and <a class="el" href="synch_8c-source.html#l00571">xnsynch_flush()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g98ec817164a6641eda2341de473b659d"></a><!-- doxytag: member="thread.c::pthread_equal" ref="g98ec817164a6641eda2341de473b659d" args="(pthread_t t1, pthread_t t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_equal           </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare thread identifiers. 
<p>
This service compare the thread identifiers <em>t1</em> and <em>t2</em>. No attempt is made to check the threads for existence. In order to check if a thread exists, the <a class="el" href="group__posix__signal.html#g5aafacc071cdfafd0eb992004dee3e62" title="Send a signal to a thread.">pthread_kill()</a> service should be used with the signal number 0.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>thread identifier;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>other thread identifier.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a non zero value if the thread identifiers are equal; <p>
0 otherwise.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_equal.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g090bdc13141e76205fab4cb3c5fab0e4"></a><!-- doxytag: member="thread.c::pthread_exit" ref="g090bdc13141e76205fab4cb3c5fab0e4" args="(void *value_ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pthread_exit           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value_ptr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Terminate the current thread. 
<p>
This service terminate the current thread with the return value <em>value_ptr</em>. If the current thread is joinable, the return value is returned to any thread joining the current thread with the <a class="el" href="group__posix__thread.html#ga79c99cc7b194918a2def257246f11c6" title="Wait for termination of a specified thread.">pthread_join()</a> service.<p>
When a thread terminates, cancellation cleanup handlers are executed in the reverse order that they were pushed. Then, thread-specific data destructors are executed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value_ptr</em>&nbsp;</td><td>thread return value.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_exit.html">Specification.</a> </dd></dl>

<p>Referenced by <a class="el" href="src_2skins_2native_2task_8c-source.html#l00210">rt_task_delete()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ga79c99cc7b194918a2def257246f11c6"></a><!-- doxytag: member="thread.c::pthread_join" ref="ga79c99cc7b194918a2def257246f11c6" args="(pthread_t thread, void **value_ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_join           </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>value_ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for termination of a specified thread. 
<p>
If the thread <em>thread</em> is running and joinable, this service blocks the calling thread until the thread <em>thread</em> terminates or detaches. In this case, the calling context must be a blockable context (i.e. a Xenomai thread without the scheduler locked) or the root thread (i.e. a module initilization or cleanup routine). When <em>thread</em> terminates, the calling thread is unblocked and its return value is stored at* the address <em>value_ptr</em>.<p>
If, on the other hand, the thread <em>thread</em> has already finished execution, its return value is stored at the address <em>value_ptr</em> and this service returns immediately. In this case, this service may be called from any context.<p>
This service is a cancelation point for POSIX skin threads: if the calling thread is canceled while blocked in a call to this service, the cancelation request is honored and <em>thread</em> remains joinable.<p>
Multiple simultaneous calls to <a class="el" href="group__posix__thread.html#ga79c99cc7b194918a2def257246f11c6" title="Wait for termination of a specified thread.">pthread_join()</a> specifying the same running target thread block all the callers until the target thread terminates.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>identifier of the thread to wait for;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value_ptr</em>&nbsp;</td><td>address where the target thread return value will be stored on success.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid;</li><li>EDEADLK, attempting to join the calling thread;</li><li>EINVAL, <em>thread</em> is detached;</li><li>EPERM, the caller context is invalid.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Valid contexts, if this service has to block its caller:</b></dt><dd><ul>
<li>Xenomai kernel-space thread;</li><li>kernel module initilization or cleanup routine;</li><li>Xenomai user-space thread (switches to primary mode).</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_join.html">Specification.</a> </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="rtcan__rtt_8c-example.html#a24">rtcan_rtt.c</a>.</dl>
<p>References <a class="el" href="pod_8c-source.html#l02376">xnpod_schedule()</a>, <a class="el" href="synch_8c-source.html#l00168">xnsynch_sleep_on()</a>, and <a class="el" href="synch_8c-source.html#l00376">xnsynch_wakeup_one_sleeper()</a>.</p>

<p>Referenced by <a class="el" href="src_2skins_2native_2task_8c-source.html#l00330">rt_task_join()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gfe8deaa3c89e0a07e59f0e58f9ec1473"></a><!-- doxytag: member="thread.c::pthread_make_periodic_np" ref="gfe8deaa3c89e0a07e59f0e58f9ec1473" args="(pthread_t thread, struct timespec *starttp, struct timespec *periodtp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_make_periodic_np           </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&nbsp;</td>
          <td class="paramname"> <em>starttp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&nbsp;</td>
          <td class="paramname"> <em>periodtp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a thread periodic. 
<p>
This service make the POSIX skin thread <em>thread</em> periodic.<p>
This service is a non-portable extension of the POSIX interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>thread identifier. This thread is immediately delayed until the first periodic release point is reached.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>starttp</em>&nbsp;</td><td>start time, expressed as an absolute value of the CLOCK_REALTIME clock. The affected thread will be delayed until this point is reached.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>periodtp</em>&nbsp;</td><td>period, expressed as a time interval.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid;</li><li>ETIMEDOUT, the start time has already passed.</li></ul>
</dd></dl>
Rescheduling: always, until the <em>starttp</em> start time has been reached. 
<p>References <a class="el" href="pod_8c-source.html#l03239">xnpod_set_thread_periodic()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gfb4c3f58a873bfe7f44aa37919437320"></a><!-- doxytag: member="once.c::pthread_once" ref="gfb4c3f58a873bfe7f44aa37919437320" args="(pthread_once_t *once, void(*init_routine)(void))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_once           </td>
          <td>(</td>
          <td class="paramtype">pthread_once_t *&nbsp;</td>
          <td class="paramname"> <em>once</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&nbsp;</td>
          <td class="paramname"> <em>init_routine</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute an initialization routine. 
<p>
This service may be used by libraries which need an initialization function to be called only once.<p>
The function <em>init_routine</em> will only be called, with no argument, the first time this service is called specifying the address <em>once</em>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EINVAL, the object pointed to by <em>once</em> is invalid (it must have been initialized with PTHREAD_ONCE_INIT).</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_once.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4c4f5f3b4f8f45d9d897847d53b11aaa"></a><!-- doxytag: member="thread.c::pthread_self" ref="g4c4f5f3b4f8f45d9d897847d53b11aaa" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_t pthread_self           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the identifier of the calling thread. 
<p>
This service returns the identifier of the calling thread.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>identifier of the calling thread; <p>
NULL if the calling thread is not a POSIX skin thread.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_self.html">Specification.</a> </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="rtcan__rtt_8c-example.html#a4">rtcan_rtt.c</a>.</dl>
<p>Referenced by <a class="el" href="src_2skins_2native_2task_8c-source.html#l00167">rt_task_shadow()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g9dd3db5524fccb05a8868b7c33ccaa79"></a><!-- doxytag: member="thread.c::pthread_set_mode_np" ref="g9dd3db5524fccb05a8868b7c33ccaa79" args="(int clrmask, int setmask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_set_mode_np           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>clrmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>setmask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the mode of the current thread. 
<p>
This service sets the mode of the calling thread. <em>clrmask</em> and <em>setmask</em> are two bit masks which are respectively cleared and set in the calling thread status. They are a bitwise OR of the following values:<ul>
<li>PTHREAD_LOCK_SCHED, when set, locks the scheduler, which prevents the current thread from being switched out by the scheduler until the scheduler is unlocked;</li><li>PTHREAD_SHIELD, when set, activates the interrupt shield, which improve the execution determinism of the current thread by blocking Linux interrupts when it runs in secondary mode;</li><li>PTHREAD_RPIOFF, when set, prevents the root Linux thread from inheriting the priority of the calling thread, when this thread is running in secondary mode;</li><li>PTHREAD_WARNSW, when set, cause the signal SIGXCPU to be sent to the current thread, whenever it involontary switches to secondary mode;</li><li>PTHREAD_PRIMARY, cause the migration of the current thread to primary mode.</li></ul>
<p>
PTHREAD_LOCK_SCHED is valid for any Xenomai thread, the other bits are only valid for Xenomai user-space threads.<p>
This service is a non-portable extension of the POSIX interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clrmask</em>&nbsp;</td><td>set of bits to be cleared;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>setmask</em>&nbsp;</td><td>set of bits to be set.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EINVAL, some bit in <em>clrmask</em> or <em>setmask</em> is invalid. </li></ul>
</dd></dl>

<p>References <a class="el" href="include_2nucleus_2thread_8h-source.html#l00047">XNLOCK</a>, <a class="el" href="pod_8c-source.html#l01035">xnpod_set_thread_mode()</a>, <a class="el" href="include_2nucleus_2thread_8h-source.html#l00057">XNRPIOFF</a>, <a class="el" href="include_2nucleus_2thread_8h-source.html#l00060">XNSHADOW</a>, <a class="el" href="shadow_8c-source.html#l01185">xnshadow_relax()</a>, <a class="el" href="include_2nucleus_2thread_8h-source.html#l00055">XNSHIELD</a>, and <a class="el" href="include_2nucleus_2thread_8h-source.html#l00056">XNTRAPSW</a>.</p>

</div>
</div><p>
<a class="anchor" name="g414a759c928f7be7ac105980d8e73431"></a><!-- doxytag: member="thread.c::pthread_set_name_np" ref="g414a759c928f7be7ac105980d8e73431" args="(pthread_t thread, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_set_name_np           </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a thread name. 
<p>
This service set to <em>name</em>, the name of <em>thread</em>. This name is used for displaying information in /proc/xenomai/sched.<p>
This service is a non-portable extension of the POSIX interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>target thread;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of the thread.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g1f18e6e7dd5342463ca8546ef3a36c34"></a><!-- doxytag: member="thread.c::pthread_wait_np" ref="g1f18e6e7dd5342463ca8546ef3a36c34" args="(unsigned long *overruns_r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_wait_np           </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>overruns_r</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for current thread next period. 
<p>
If it is periodic, this service blocks the calling thread until the next period elapses.<p>
This service is a cancelation point for POSIX skin threads.<p>
This service is a non-portable extension of the POSIX interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>overruns_r</em>&nbsp;</td><td>address where the overruns count is returned in case of overrun.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success; <p>
an error number if:<ul>
<li>EPERM, the calling context is invalid;</li><li>EWOULDBLOCK, the calling thread is not periodic;</li><li>EINTR, this service was interrupted by a signal;</li><li>ETIMEDOUT, at least one overrun occurred.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>Xenomai kernel-space thread;</li><li>Xenomai user-space thread (switches to primary mode). </li></ul>
</dd></dl>

<p>References <a class="el" href="pod_8c-source.html#l03338">xnpod_wait_thread_period()</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Feb 26 15:05:09 2009 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
