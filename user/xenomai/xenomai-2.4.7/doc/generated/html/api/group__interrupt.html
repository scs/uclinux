<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Interrupt management services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Interrupt management services.<br>
<small>
[<a class="el" href="group__native.html">Native Xenomai API.</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Interrupt management services.:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__interrupt.png" border="0" alt="" usemap="#group____interrupt_map">
<map name="group____interrupt_map">
<area shape="rect" href="group__native.html" title="Native Xenomai API." alt="" coords="5,6,149,30"></map></td></tr></table></center>
</div>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksrc_2skins_2native_2intr_8c.html">intr.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file is part of the Xenomai project. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ga0a9d98556ec838008f408a56e79d304">rt_intr_create</a> (RT_INTR *intr, const char *name, unsigned irq, rt_isr_t isr, rt_iack_t iack, int mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an interrupt object from kernel space.  <a href="#ga0a9d98556ec838008f408a56e79d304"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#g6da6ddd4e65b0feb47278dae74cab6c9">rt_intr_delete</a> (RT_INTR *intr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete an interrupt object.  <a href="#g6da6ddd4e65b0feb47278dae74cab6c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#gc712ee67f90d053a21bdb0041a63e17c">rt_intr_enable</a> (RT_INTR *intr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable an interrupt object.  <a href="#gc712ee67f90d053a21bdb0041a63e17c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#g9cf127812ea07326d5f4924f3e28eb3f">rt_intr_disable</a> (RT_INTR *intr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable an interrupt object.  <a href="#g9cf127812ea07326d5f4924f3e28eb3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#gea34e43cbd6d6f515966f67990738395">rt_intr_inquire</a> (RT_INTR *intr, RT_INTR_INFO *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inquire about an interrupt object.  <a href="#gea34e43cbd6d6f515966f67990738395"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#g92fa8e83f6f3db05dd1d2d075dd310ee">rt_intr_create</a> (RT_INTR *intr, const char *name, unsigned irq, int mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an interrupt object from user-space.  <a href="#g92fa8e83f6f3db05dd1d2d075dd310ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#g222e6a9a681f83b13ed5b51021711f4d">rt_intr_wait</a> (RT_INTR *intr, RTIME timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the next interrupt.  <a href="#g222e6a9a681f83b13ed5b51021711f4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#ge13742ca2710acfedc54c76541863fe3">rt_intr_bind</a> (RT_INTR *intr, const char *name, RTIME timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind to an interrupt object.  <a href="#ge13742ca2710acfedc54c76541863fe3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interrupt.html#g4db46e047246e5c237a3c2816bf1889a">rt_intr_unbind</a> (RT_INTR *intr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unbind from an interrupt object.  <a href="#g4db46e047246e5c237a3c2816bf1889a"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ge13742ca2710acfedc54c76541863fe3"></a><!-- doxytag: member="intr.h::rt_intr_bind" ref="ge13742ca2710acfedc54c76541863fe3" args="(RT_INTR *intr, const char *name, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_intr_bind           </td>
          <td>(</td>
          <td class="paramtype">RT_INTR *&nbsp;</td>
          <td class="paramname"> <em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bind to an interrupt object. 
<p>
This user-space only service retrieves the uniform descriptor of a given Xenomai interrupt object identified by its IRQ number. If the object does not exist on entry, this service blocks the caller until an interrupt object of the given number is created. An interrupt is registered whenever a kernel-space task invokes the <a class="el" href="group__interrupt.html#g92fa8e83f6f3db05dd1d2d075dd310ee" title="Create an interrupt object from user-space.">rt_intr_create()</a> service successfully for the given IRQ line.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The address of an interrupt object descriptor retrieved by the operation. Contents of this memory is undefined upon failure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the interrupt object to search for.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for the registration to occur (see note). Passing TM_INFINITE causes the caller to block indefinitely until the object is registered. Passing TM_NONBLOCK causes the service to return immediately without waiting if the object is not registered on entry.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EFAULT is returned if <em>intr</em> is referencing invalid memory.</li></ul>
<p>
<ul>
<li>-EINVAL is returned if <em>irq</em> is invalid.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the waiting task before the retrieval has completed.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the searched object is not registered on entry.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if the object cannot be retrieved within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g92fa8e83f6f3db05dd1d2d075dd310ee"></a><!-- doxytag: member="intr.h::rt_intr_create" ref="g92fa8e83f6f3db05dd1d2d075dd310ee" args="(RT_INTR *intr, const char *name, unsigned irq, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_intr_create           </td>
          <td>(</td>
          <td class="paramtype">RT_INTR *&nbsp;</td>
          <td class="paramname"> <em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an interrupt object from user-space. 
<p>
Initializes and associates an interrupt object with an IRQ line from a user-space application. In this mode, the basic principle is to define some interrupt server task which routinely waits for the next incoming IRQ event through the <a class="el" href="group__interrupt.html#g222e6a9a681f83b13ed5b51021711f4d" title="Wait for the next interrupt.">rt_intr_wait()</a> syscall.<p>
When an interrupt occurs on the given <em>irq</em> line, any task pending on the interrupt object through <a class="el" href="group__interrupt.html#g222e6a9a681f83b13ed5b51021711f4d" title="Wait for the next interrupt.">rt_intr_wait()</a> is imediately awaken in order to deal with the hardware event. The interrupt service code may then call any Xenomai service available from user-space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The address of a interrupt object descriptor Xenomai will use to store the object-specific data. This descriptor must always be valid while the object is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the interrupt object. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created interrupt objects.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The hardware interrupt channel associated with the interrupt object. This value is architecture-dependent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The interrupt object creation mode. The following flags can be OR'ed into this bitmask:</td></tr>
  </table>
</dl>
<ul>
<li>I_NOAUTOENA asks Xenomai not to re-enable the IRQ line before awakening the interrupt server task. This flag is functionally equivalent as always returning RT_INTR_NOENABLE from a kernel space interrupt handler.</li></ul>
<p>
<ul>
<li>I_PROPAGATE asks Xenomai to propagate the IRQ down the pipeline; in other words, the interrupt occurrence is chained to Linux after it has been processed by the Xenomai task. This flag is functionally equivalent as always returning RT_INTR_PROPAGATE from a kernel space interrupt handler.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the system fails to get enough dynamic memory from the global real-time heap in order to register the interrupt object.</li></ul>
<p>
<ul>
<li>-EBUSY is returned if the interrupt line is already in use by another interrupt object. Only a single interrupt object can be associated to any given interrupt line using <a class="el" href="group__interrupt.html#g92fa8e83f6f3db05dd1d2d075dd310ee" title="Create an interrupt object from user-space.">rt_intr_create()</a> at any time, regardless of the caller's execution space (kernel or user).</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>User-space task</li></ul>
<p>
Rescheduling: possible.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The interrupt source associated to the interrupt descriptor remains masked upon creation. <a class="el" href="group__interrupt.html#gc712ee67f90d053a21bdb0041a63e17c" title="Enable an interrupt object.">rt_intr_enable()</a> should be called for the new interrupt object to unmask it. </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="user__irq_8c-example.html#a1">user_irq.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="ga0a9d98556ec838008f408a56e79d304"></a><!-- doxytag: member="intr.c::rt_intr_create" ref="ga0a9d98556ec838008f408a56e79d304" args="(RT_INTR *intr, const char *name, unsigned irq, rt_isr_t isr, rt_iack_t iack, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_intr_create           </td>
          <td>(</td>
          <td class="paramtype">RT_INTR *&nbsp;</td>
          <td class="paramname"> <em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_isr_t&nbsp;</td>
          <td class="paramname"> <em>isr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_iack_t&nbsp;</td>
          <td class="paramname"> <em>iack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an interrupt object from kernel space. 
<p>
Initializes and associates an interrupt object with an IRQ line. In kernel space, interrupts are immediately notified to a user-defined handler or ISR (interrupt service routine).<p>
When an interrupt occurs on the given <em>irq</em> line, the ISR is fired in order to deal with the hardware event. The interrupt service code may call any non-suspensive Xenomai service.<p>
Upon receipt of an IRQ, the ISR is immediately called on behalf of the interrupted stack context, the rescheduling procedure is locked, and the interrupt source is masked at hardware level. The status value returned by the ISR is then checked for the following values:<p>
<ul>
<li>RT_INTR_HANDLED indicates that the interrupt request has been fulfilled by the ISR.</li></ul>
<p>
<ul>
<li>RT_INTR_NONE indicates the opposite to RT_INTR_HANDLED. The ISR must always return this value when it determines that the interrupt request has not been issued by the dedicated hardware device.</li></ul>
<p>
In addition, one of the following bits may be set by the ISR :<p>
NOTE: use these bits with care and only when you do understand their effect on the system. The ISR is not encouraged to use these bits in case it shares the IRQ line with other ISRs in the real-time domain.<p>
<ul>
<li>RT_INTR_PROPAGATE tells Xenomai to require the real-time control layer to forward the IRQ. For instance, this would cause the Adeos control layer to propagate the interrupt down the interrupt pipeline to other Adeos domains, such as Linux. This is the regular way to share interrupts between Xenomai and the Linux kernel.</li></ul>
<p>
<ul>
<li>RT_INTR_NOENABLE asks Xenomai not to re-enable the IRQ line upon return of the interrupt service routine.</li></ul>
<p>
A count of interrupt receipts is tracked into the interrupt descriptor, and reset to zero each time the interrupt object is attached. Since this count could wrap around, it should be used as an indication of interrupt activity only.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The address of a interrupt object descriptor Xenomai will use to store the object-specific data. This descriptor must always be valid while the object is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the interrupt object. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created interrupt objects.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The hardware interrupt channel associated with the interrupt object. This value is architecture-dependent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isr</em>&nbsp;</td><td>The address of a valid interrupt service routine in kernel space. This handler will be called each time the corresponding IRQ is delivered on behalf of an interrupt context. A pointer to an internal information is passed to the routine which can use it to retrieve the descriptor address of the associated interrupt object through the I_DESC() macro.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iack</em>&nbsp;</td><td>The address of an optional interrupt acknowledge routine, aimed at replacing the default one. Only very specific situations actually require to override the default setting for this parameter, like having to acknowledge non-standard PIC hardware. <em>iack</em> should return a non-zero value to indicate that the interrupt has been properly acknowledged. If <em>iack</em> is NULL, the default routine will be used instead.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The interrupt object creation mode. The following flags can be OR'ed into this bitmask, each of them affecting the new interrupt object:</td></tr>
  </table>
</dl>
<ul>
<li>I_SHARED enables IRQ-sharing with other interrupt objects.</li></ul>
<p>
<ul>
<li>I_EDGE is an additional flag need to be set together with I_SHARED to enable IRQ-sharing of edge-triggered interrupts.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the system fails to get enough dynamic memory from the global real-time heap in order to register the interrupt object.</li></ul>
<p>
<ul>
<li>-EBUSY is returned if the interrupt line is already in use by another interrupt object. Only a single interrupt object can be associated to any given interrupt line using <a class="el" href="group__interrupt.html#g92fa8e83f6f3db05dd1d2d075dd310ee" title="Create an interrupt object from user-space.">rt_intr_create()</a> at any time.</li></ul>
<p>
<ul>
<li>-EEXIST is returned if <em>irq</em> is already associated to an existing interrupt object.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task (note that in user-space the interface is different, see <a class="el" href="group__interrupt.html#g92fa8e83f6f3db05dd1d2d075dd310ee" title="Create an interrupt object from user-space.">rt_intr_create()</a>)</li></ul>
<p>
Rescheduling: possible.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The interrupt source associated to the interrupt descriptor remains masked upon creation. <a class="el" href="group__interrupt.html#gc712ee67f90d053a21bdb0041a63e17c" title="Enable an interrupt object.">rt_intr_enable()</a> should be called for the new interrupt object to unmask it. </dd></dl>

<p>References <a class="el" href="src_2skins_2native_2intr_8c-source.html#l00038">rt_intr_delete()</a>, <a class="el" href="ksrc_2nucleus_2intr_8c-source.html#l00690">xnintr_attach()</a>, <a class="el" href="ksrc_2nucleus_2intr_8c-source.html#l00603">xnintr_init()</a>, <a class="el" href="nucleus_2registry_8c-source.html#l00582">xnregistry_enter()</a>, and <a class="el" href="synch_8c-source.html#l00087">xnsynch_init()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g6da6ddd4e65b0feb47278dae74cab6c9"></a><!-- doxytag: member="intr.c::rt_intr_delete" ref="g6da6ddd4e65b0feb47278dae74cab6c9" args="(RT_INTR *intr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_intr_delete           </td>
          <td>(</td>
          <td class="paramtype">RT_INTR *&nbsp;</td>
          <td class="paramname"> <em>intr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete an interrupt object. 
<p>
Destroys an interrupt object. An interrupt exists in the system since <a class="el" href="group__interrupt.html#g92fa8e83f6f3db05dd1d2d075dd310ee" title="Create an interrupt object from user-space.">rt_intr_create()</a> has been called to create it, so this service must be called in order to destroy it afterwards.<p>
Any user-space task which might be currently pending on the interrupt object through the <a class="el" href="group__interrupt.html#g222e6a9a681f83b13ed5b51021711f4d" title="Wait for the next interrupt.">rt_intr_wait()</a> service will be awaken as a result of the deletion, and return with the -EIDRM status.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the affected interrupt object.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>intr</em> is not a interrupt object descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>intr</em> is a deleted interrupt object descriptor.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible. 
<p>References <a class="el" href="ksrc_2nucleus_2intr_8c-source.html#l00648">xnintr_destroy()</a>, <a class="el" href="ksrc_2nucleus_2intr_8c-source.html#l00747">xnintr_detach()</a>, <a class="el" href="pod_8c-source.html#l02376">xnpod_schedule()</a>, and <a class="el" href="nucleus_2registry_8c-source.html#l00809">xnregistry_remove()</a>.</p>

<p>Referenced by <a class="el" href="ksrc_2skins_2native_2intr_8c-source.html#l00246">rt_intr_create()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g9cf127812ea07326d5f4924f3e28eb3f"></a><!-- doxytag: member="intr.c::rt_intr_disable" ref="g9cf127812ea07326d5f4924f3e28eb3f" args="(RT_INTR *intr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_intr_disable           </td>
          <td>(</td>
          <td class="paramtype">RT_INTR *&nbsp;</td>
          <td class="paramname"> <em>intr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable an interrupt object. 
<p>
Disables the hardware interrupt line associated with an interrupt object. This operation invalidates further interrupt requests from the given source until the IRQ line is re-enabled anew through <a class="el" href="group__interrupt.html#gc712ee67f90d053a21bdb0041a63e17c" title="Enable an interrupt object.">rt_intr_enable()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object to enable.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>intr</em> is not a interrupt object descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>intr</em> is a deleted interrupt object descriptor.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
<p>References <a class="el" href="ksrc_2nucleus_2intr_8c-source.html#l00822">xnintr_disable()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gc712ee67f90d053a21bdb0041a63e17c"></a><!-- doxytag: member="intr.c::rt_intr_enable" ref="gc712ee67f90d053a21bdb0041a63e17c" args="(RT_INTR *intr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_intr_enable           </td>
          <td>(</td>
          <td class="paramtype">RT_INTR *&nbsp;</td>
          <td class="paramname"> <em>intr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable an interrupt object. 
<p>
Enables the hardware interrupt line associated with an interrupt object. Over Adeos-based systems which mask and acknowledge IRQs upon receipt, this operation is necessary to revalidate the interrupt channel so that more interrupts from the same source can be notified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object to enable.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>intr</em> is not a interrupt object descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>intr</em> is a deleted interrupt object descriptor.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
<p>References <a class="el" href="ksrc_2nucleus_2intr_8c-source.html#l00791">xnintr_enable()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gea34e43cbd6d6f515966f67990738395"></a><!-- doxytag: member="intr.c::rt_intr_inquire" ref="gea34e43cbd6d6f515966f67990738395" args="(RT_INTR *intr, RT_INTR_INFO *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_intr_inquire           </td>
          <td>(</td>
          <td class="paramtype">RT_INTR *&nbsp;</td>
          <td class="paramname"> <em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_INTR_INFO *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inquire about an interrupt object. 
<p>
Return various information about the status of a given interrupt object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the inquired interrupt object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>The address of a structure the interrupt object information will be written to.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned and status information is written to the structure pointed at by <em>info</em> upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>intr</em> is not a interrupt object descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>intr</em> is a deleted interrupt object descriptor.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g4db46e047246e5c237a3c2816bf1889a"></a><!-- doxytag: member="intr.h::rt_intr_unbind" ref="g4db46e047246e5c237a3c2816bf1889a" args="(RT_INTR *intr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_intr_unbind           </td>
          <td>(</td>
          <td class="paramtype">RT_INTR *&nbsp;</td>
          <td class="paramname"> <em>intr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unbind from an interrupt object. 
<p>
This user-space only service unbinds the calling task from the interrupt object previously retrieved by a call to <a class="el" href="group__interrupt.html#ge13742ca2710acfedc54c76541863fe3" title="Bind to an interrupt object.">rt_intr_bind()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The address of a interrupt object descriptor to unbind from.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is always returned.</dd></dl>
This service can be called from:<p>
<ul>
<li>User-space task.</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g222e6a9a681f83b13ed5b51021711f4d"></a><!-- doxytag: member="intr.h::rt_intr_wait" ref="g222e6a9a681f83b13ed5b51021711f4d" args="(RT_INTR *intr, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_intr_wait           </td>
          <td>(</td>
          <td class="paramtype">RT_INTR *&nbsp;</td>
          <td class="paramname"> <em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for the next interrupt. 
<p>
This user-space only call allows the current task to suspend execution until the associated interrupt event triggers. The priority of the current task is raised above all other Xenomai tasks - except those also undergoing an interrupt or alarm wait (see <a class="el" href="group__alarm.html#g6c0caadae03541db8a46751d290c0d76" title="Wait for the next alarm shot.">rt_alarm_wait()</a>) - so that it would preempt any of them under normal circumstances (i.e. no scheduler lock).<p>
Interrupt receipts are logged if they cannot be delivered immediately to some interrupt server task, so that a call to <a class="el" href="group__interrupt.html#g222e6a9a681f83b13ed5b51021711f4d" title="Wait for the next interrupt.">rt_intr_wait()</a> might return immediately if an IRQ is already pending on entry of the service.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the awaited interrupt.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for an interrupt to occur (see note). Passing TM_INFINITE causes the caller to block indefinitely until an interrupt triggers. Passing TM_NONBLOCK is invalid.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A positive value is returned upon success, representing the number of pending interrupts to process. Otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if no interrupt occurred within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EINVAL is returned if <em>intr</em> is not an interrupt object descriptor, or <em>timeout</em> is equal to TM_NONBLOCK.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>intr</em> is a deleted interrupt object descriptor, including if the deletion occurred while the caller was waiting for its next interrupt.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the current task before the next interrupt occurrence.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>User-space task</li></ul>
<p>
Rescheduling: always, unless an interrupt is already pending on entry.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="user__irq_8c-example.html#a0">user_irq.c</a>.</dl>
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Feb 26 15:05:07 2009 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
