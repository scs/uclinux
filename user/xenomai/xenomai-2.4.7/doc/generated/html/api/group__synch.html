<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Thread synchronization services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Thread synchronization services.<br>
<small>
[<a class="el" href="group__nucleus.html">Xenomai nucleus.</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Thread synchronization services.:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__synch.png" border="0" alt="" usemap="#group____synch_map">
<map name="group____synch_map">
<area shape="rect" href="group__nucleus.html" title="Xenomai nucleus." alt="" coords="5,6,131,30"></map></td></tr></table></center>
</div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Thread synchronization services. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="synch_8c.html">synch.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread synchronization services. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#g9ba3d7a44aca6f7246ba1a5fa3f3251a">xnsynch_init</a> (xnsynch_t *synch, xnflags_t flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a synchronization object.  <a href="#g9ba3d7a44aca6f7246ba1a5fa3f3251a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#g6a230ca2035ff7494b517f52cd4fd800">xnsynch_sleep_on</a> (xnsynch_t *synch, xnticks_t timeout, xntmode_t timeout_mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sleep on a synchronization object.  <a href="#g6a230ca2035ff7494b517f52cd4fd800"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#g6651c0538a5984ee20547e159ad1bd30">xnsynch_clear_boost</a> (xnsynch_t *synch, xnthread_t *lastowner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the priority boost.  <a href="#g6651c0538a5984ee20547e159ad1bd30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#g800c68e26b7fc0eca599e18785137b5c">xnsynch_renice_sleeper</a> (xnthread_t *thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change a sleeper's priority.  <a href="#g800c68e26b7fc0eca599e18785137b5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">xnthread_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#gc9926fd6af7a7fe01b9f8d02c1a62957">xnsynch_wakeup_one_sleeper</a> (xnsynch_t *synch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Give the resource ownership to the next waiting thread.  <a href="#gc9926fd6af7a7fe01b9f8d02c1a62957"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">xnthread_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#g80c718b07372cfc4b1c18b4d5ac1c7ce">xnsynch_peek_pendq</a> (xnsynch_t *synch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the thread leading a synch object wait queue.  <a href="#g80c718b07372cfc4b1c18b4d5ac1c7ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">xnpholder_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#g15b56df22d23acd5de3d1d622b2caa6a">xnsynch_wakeup_this_sleeper</a> (xnsynch_t *synch, xnpholder_t *holder)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Give the resource ownership to a given waiting thread.  <a href="#g15b56df22d23acd5de3d1d622b2caa6a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#g0a340f5c1541bc6f431c105928ec8489">xnsynch_flush</a> (xnsynch_t *synch, xnflags_t reason)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unblock all waiters pending on a resource.  <a href="#g0a340f5c1541bc6f431c105928ec8489"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#gcf7a1aacc7be8816ea644474e75434f9">xnsynch_forget_sleeper</a> (xnthread_t *thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abort a wait for a resource.  <a href="#gcf7a1aacc7be8816ea644474e75434f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#gc9da9b803c6e27b32ebd2651dcd23922">xnsynch_release_all_ownerships</a> (xnthread_t *thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release all ownerships.  <a href="#gc9da9b803c6e27b32ebd2651dcd23922"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g6651c0538a5984ee20547e159ad1bd30"></a><!-- doxytag: member="synch.c::xnsynch_clear_boost" ref="g6651c0538a5984ee20547e159ad1bd30" args="(xnsynch_t *synch, xnthread_t *lastowner)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnsynch_clear_boost           </td>
          <td>(</td>
          <td class="paramtype">xnsynch_t *&nbsp;</td>
          <td class="paramname"> <em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnthread_t *&nbsp;</td>
          <td class="paramname"> <em>owner</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the priority boost. 
<p>
<p><b>For internal use only.</b></p>
<p>
This service is called internally whenever a synchronization object is not claimed anymore by sleepers to reset the object owner's priority to its initial level.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>synch</em>&nbsp;</td><td>The descriptor address of the synchronization object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owner</em>&nbsp;</td><td>The descriptor address of the thread which currently owns the synchronization object.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine must be entered nklock locked, interrupts off. </dd></dl>
</p>

<p>References <a class="el" href="include_2nucleus_2thread_8h-source.html#l00045">XNBOOST</a>.</p>

<p>Referenced by <a class="el" href="synch_8c-source.html#l00571">xnsynch_flush()</a>, <a class="el" href="synch_8c-source.html#l00622">xnsynch_forget_sleeper()</a>, <a class="el" href="synch_8c-source.html#l00376">xnsynch_wakeup_one_sleeper()</a>, and <a class="el" href="synch_8c-source.html#l00491">xnsynch_wakeup_this_sleeper()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g0a340f5c1541bc6f431c105928ec8489"></a><!-- doxytag: member="synch.c::xnsynch_flush" ref="g0a340f5c1541bc6f431c105928ec8489" args="(xnsynch_t *synch, xnflags_t reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnsynch_flush           </td>
          <td>(</td>
          <td class="paramtype">xnsynch_t *&nbsp;</td>
          <td class="paramname"> <em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnflags_t&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unblock all waiters pending on a resource. 
<p>
This service atomically releases all threads which currently sleep on a given resource.<p>
This service should be called by upper interfaces under circumstances requiring that the pending queue of a given resource is cleared, such as before the resource is deleted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>synch</em>&nbsp;</td><td>The descriptor address of the synchronization object to be flushed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>Some flags to set in the information mask of every unblocked thread. Zero is an acceptable value. The following bits are pre-defined by the nucleus:</td></tr>
  </table>
</dl>
<ul>
<li>XNRMID should be set to indicate that the synchronization object is about to be destroyed (see <a class="el" href="group__pod.html#gc3a7bf9e973782a8cfd6495a1786e812" title="Resume a thread.">xnpod_resume_thread()</a>).</li></ul>
<p>
<ul>
<li>XNBREAK should be set to indicate that the wait has been forcibly interrupted (see <a class="el" href="group__pod.html#ge5f0d19e7a499b9b262f68a43ab545dd" title="Unblock a thread.">xnpod_unblock_thread()</a>).</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>XNSYNCH_RESCHED is returned if at least one thread is unblocked, which means the caller should invoke <a class="el" href="group__pod.html#gcf5b53f0405351327b89b0cc4976b962" title="Rescheduling procedure entry point.">xnpod_schedule()</a> for applying the new scheduling state. Otherwise, XNSYNCH_DONE is returned.</dd></dl>
Side-effects:<p>
<ul>
<li>The effective priority of the previous resource owner might be lowered to its base priority value as a consequence of the priority inheritance boost being cleared.</li></ul>
<p>
<ul>
<li>The synchronization object is no more owned by any thread.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
<p>References <a class="el" href="include_2nucleus_2thread_8h-source.html#l00034">XNPEND</a>, <a class="el" href="pod_8c-source.html#l01559">xnpod_resume_thread()</a>, and <a class="el" href="synch_8c-source.html#l00268">xnsynch_clear_boost()</a>.</p>

<p>Referenced by <a class="el" href="ksrc_2skins_2posix_2cond_8c-source.html#l00566">pthread_cond_broadcast()</a>, <a class="el" href="skins_2posix_2thread_8c-source.html#l00271">pthread_detach()</a>, <a class="el" href="ksrc_2skins_2native_2cond_8c-source.html#l00364">rt_cond_broadcast()</a>, <a class="el" href="ksrc_2skins_2native_2sem_8c-source.html#l00488">rt_sem_broadcast()</a>, <a class="el" href="ksrc_2skins_2native_2task_8c-source.html#l01739">rt_task_send()</a>, <a class="el" href="drvlib_8c-source.html#l00829">rtdm_event_signal()</a>, and <a class="el" href="nucleus_2registry_8c-source.html#l01084">xnregistry_put()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gcf7a1aacc7be8816ea644474e75434f9"></a><!-- doxytag: member="synch.c::xnsynch_forget_sleeper" ref="gcf7a1aacc7be8816ea644474e75434f9" args="(xnthread_t *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnsynch_forget_sleeper           </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Abort a wait for a resource. 
<p>
<p><b>For internal use only.</b></p>
<p>
Performs all the necessary housekeeping chores to stop a thread from waiting on a given synchronization object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The descriptor address of the affected thread.</td></tr>
  </table>
</dl>
When the trace support is enabled (i.e. MVM), the idle state is posted to the synchronization object's state diagram (if any) whenever no thread remains blocked on it. The real-time interfaces must ensure that such condition (i.e. EMPTY/IDLE) is mapped to state #0.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine must be entered nklock locked, interrupts off. </dd></dl>
</p>

<p>References <a class="el" href="include_2nucleus_2thread_8h-source.html#l00034">XNPEND</a>, and <a class="el" href="synch_8c-source.html#l00268">xnsynch_clear_boost()</a>.</p>

<p>Referenced by <a class="el" href="pod_8c-source.html#l01115">xnpod_delete_thread()</a>, <a class="el" href="pod_8c-source.html#l01559">xnpod_resume_thread()</a>, and <a class="el" href="pod_8c-source.html#l01360">xnpod_suspend_thread()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g9ba3d7a44aca6f7246ba1a5fa3f3251a"></a><!-- doxytag: member="synch.c::xnsynch_init" ref="g9ba3d7a44aca6f7246ba1a5fa3f3251a" args="(xnsynch_t *synch, xnflags_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnsynch_init           </td>
          <td>(</td>
          <td class="paramtype">xnsynch_t *&nbsp;</td>
          <td class="paramname"> <em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnflags_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a synchronization object. 
<p>
Initializes a new specialized object which can subsequently be used to synchronize real-time activities. The Xenomai nucleus provides a basic synchronization object which can be used to build higher resource objects. Nucleus threads can wait for and signal such objects in order to synchronize their activities.<p>
This object has built-in support for priority inheritance.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>synch</em>&nbsp;</td><td>The address of a synchronization object descriptor the nucleus will use to store the object-specific data. This descriptor must always be valid while the object is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>A set of creation flags affecting the operation. The valid flags are:</td></tr>
  </table>
</dl>
<ul>
<li>XNSYNCH_PRIO causes the threads waiting for the resource to pend in priority order. Otherwise, FIFO ordering is used (XNSYNCH_FIFO).</li></ul>
<p>
<ul>
<li>XNSYNCH_PIP causes the priority inheritance mechanism to be automatically activated when a priority inversion is detected among threads using this object. Otherwise, no priority inheritance takes place upon priority inversion (XNSYNCH_NOPIP).</li></ul>
<p>
<ul>
<li>XNSYNCH_DREORD (Disable REORDering) tells the nucleus that the wait queue should not be reordered whenever the priority of a blocked thread it holds is changed. If this flag is not specified, changing the priority of a blocked thread using <a class="el" href="group__pod.html#g1282a77af15a1421fb9bd0f5b90330b5" title="Change the base priority of a thread.">xnpod_renice_thread()</a> will cause this object's wait queue to be reordered according to the new priority level, provided the synchronization object makes the waiters wait by priority order on the awaited resource (XNSYNCH_PRIO).</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
<p>Referenced by <a class="el" href="ksrc_2skins_2posix_2cond_8c-source.html#l00106">pthread_cond_init()</a>, <a class="el" href="skins_2posix_2thread_8c-source.html#l00152">pthread_create()</a>, <a class="el" href="ksrc_2skins_2posix_2intr_8c-source.html#l00099">pthread_intr_attach_np()</a>, <a class="el" href="ksrc_2skins_2posix_2mutex_8c-source.html#l00092">pthread_mutex_init()</a>, <a class="el" href="ksrc_2skins_2native_2alarm_8c-source.html#l00187">rt_alarm_create()</a>, <a class="el" href="ksrc_2skins_2native_2cond_8c-source.html#l00155">rt_cond_create()</a>, <a class="el" href="ksrc_2skins_2native_2event_8c-source.html#l00177">rt_event_create()</a>, <a class="el" href="ksrc_2skins_2native_2heap_8c-source.html#l00241">rt_heap_create()</a>, <a class="el" href="ksrc_2skins_2native_2intr_8c-source.html#l00246">rt_intr_create()</a>, <a class="el" href="ksrc_2skins_2native_2mutex_8c-source.html#l00165">rt_mutex_create()</a>, <a class="el" href="ksrc_2skins_2native_2queue_8c-source.html#l00209">rt_queue_create()</a>, <a class="el" href="ksrc_2skins_2native_2sem_8c-source.html#l00173">rt_sem_create()</a>, <a class="el" href="ksrc_2skins_2native_2task_8c-source.html#l00236">rt_task_create()</a>, <a class="el" href="drvlib_8c-source.html#l00749">rtdm_event_init()</a>, <a class="el" href="drvlib_8c-source.html#l01380">rtdm_mutex_init()</a>, <a class="el" href="drvlib_8c-source.html#l01096">rtdm_sem_init()</a>, <a class="el" href="nucleus_2registry_8c-source.html#l00582">xnregistry_enter()</a>, and <a class="el" href="select_8c-source.html#l00273">xnselector_init()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g80c718b07372cfc4b1c18b4d5ac1c7ce"></a><!-- doxytag: member="synch.c::xnsynch_peek_pendq" ref="g80c718b07372cfc4b1c18b4d5ac1c7ce" args="(xnsynch_t *synch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnthread_t* xnsynch_peek_pendq           </td>
          <td>(</td>
          <td class="paramtype">xnsynch_t *&nbsp;</td>
          <td class="paramname"> <em>synch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access the thread leading a synch object wait queue. 
<p>
This services returns the descriptor address of to the thread leading a synchronization object wait queue.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>synch</em>&nbsp;</td><td>The descriptor address of the target synchronization object.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The descriptor address of the unblocked thread.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="gc9da9b803c6e27b32ebd2651dcd23922"></a><!-- doxytag: member="synch.c::xnsynch_release_all_ownerships" ref="gc9da9b803c6e27b32ebd2651dcd23922" args="(xnthread_t *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnsynch_release_all_ownerships           </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release all ownerships. 
<p>
<p><b>For internal use only.</b></p>
<p>
This call is used internally to release all the ownerships obtained by a thread on synchronization objects. This routine must be entered interrupts off.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The descriptor address of the affected thread.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine must be entered nklock locked, interrupts off. </dd></dl>
</p>

<p>References <a class="el" href="synch_8c-source.html#l00376">xnsynch_wakeup_one_sleeper()</a>.</p>

<p>Referenced by <a class="el" href="pod_8c-source.html#l01115">xnpod_delete_thread()</a>, and <a class="el" href="pod_8c-source.html#l00913">xnpod_restart_thread()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g800c68e26b7fc0eca599e18785137b5c"></a><!-- doxytag: member="synch.c::xnsynch_renice_sleeper" ref="g800c68e26b7fc0eca599e18785137b5c" args="(xnthread_t *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnsynch_renice_sleeper           </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change a sleeper's priority. 
<p>
<p><b>For internal use only.</b></p>
<p>
This service is used by the PIP code to update the pending priority of a sleeping thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The descriptor address of the affected thread.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine must be entered nklock locked, interrupts off. </dd></dl>
</p>

<p>References <a class="el" href="include_2nucleus_2thread_8h-source.html#l00045">XNBOOST</a>.</p>

</div>
</div><p>
<a class="anchor" name="g6a230ca2035ff7494b517f52cd4fd800"></a><!-- doxytag: member="synch.c::xnsynch_sleep_on" ref="g6a230ca2035ff7494b517f52cd4fd800" args="(xnsynch_t *synch, xnticks_t timeout, xntmode_t timeout_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnsynch_sleep_on           </td>
          <td>(</td>
          <td class="paramtype">xnsynch_t *&nbsp;</td>
          <td class="paramname"> <em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xntmode_t&nbsp;</td>
          <td class="paramname"> <em>timeout_mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sleep on a synchronization object. 
<p>
Makes the calling thread sleep on the specified synchronization object, waiting for it to be signaled.<p>
This service should be called by upper interfaces wanting the current thread to pend on the given resource.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>synch</em>&nbsp;</td><td>The descriptor address of the synchronization object to sleep on.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The timeout which may be used to limit the time the thread pends on the resource. This value is a wait time given in ticks (see note). It can either be relative, absolute monotonic, or absolute adjustable depending on <em>timeout_mode</em>. Passing XN_INFINITE <b>and</b> setting <em>mode</em> to XN_RELATIVE specifies an unbounded wait. All other values are used to initialize a watchdog timer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_mode</em>&nbsp;</td><td>The mode of the <em>timeout</em> parameter. It can either be set to XN_RELATIVE, XN_ABSOLUTE, or XN_REALTIME (see also <a class="el" href="group__timer.html#g0ad3c70bed7fe1a45b45ee0875f031ab" title="Arm a timer.">xntimer_start()</a>).</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: always.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the current thread is bound to a periodic time base (see xnpod_init_thread), or nanoseconds otherwise. </dd></dl>

<p>References <a class="el" href="include_2nucleus_2thread_8h-source.html#l00045">XNBOOST</a>, <a class="el" href="include_2nucleus_2thread_8h-source.html#l00112">XNBREAK</a>, <a class="el" href="include_2nucleus_2thread_8h-source.html#l00034">XNPEND</a>, <a class="el" href="pod_8c-source.html#l01360">xnpod_suspend_thread()</a>, <a class="el" href="include_2nucleus_2thread_8h-source.html#l00111">XNRMID</a>, <a class="el" href="include_2nucleus_2thread_8h-source.html#l00115">XNROBBED</a>, <a class="el" href="include_2nucleus_2thread_8h-source.html#l00110">XNTIMEO</a>, and <a class="el" href="include_2nucleus_2thread_8h-source.html#l00114">XNWAKEN</a>.</p>

<p>Referenced by <a class="el" href="skins_2posix_2thread_8c-source.html#l00399">pthread_join()</a>, <a class="el" href="ksrc_2skins_2native_2cond_8c-source.html#l00442">rt_cond_wait()</a>, <a class="el" href="ksrc_2skins_2native_2event_8c-source.html#l00458">rt_event_wait()</a>, <a class="el" href="ksrc_2skins_2native_2heap_8c-source.html#l00523">rt_heap_alloc()</a>, <a class="el" href="ksrc_2skins_2native_2mutex_8c-source.html#l00351">rt_mutex_acquire()</a>, <a class="el" href="ksrc_2skins_2native_2queue_8c-source.html#l00813">rt_queue_receive()</a>, <a class="el" href="ksrc_2skins_2native_2sem_8c-source.html#l00356">rt_sem_p()</a>, <a class="el" href="ksrc_2skins_2native_2task_8c-source.html#l01932">rt_task_receive()</a>, <a class="el" href="ksrc_2skins_2native_2task_8c-source.html#l01739">rt_task_send()</a>, <a class="el" href="drvlib_8c-source.html#l00920">rtdm_event_timedwait()</a>, <a class="el" href="drvlib_8c-source.html#l01497">rtdm_mutex_timedlock()</a>, <a class="el" href="drvlib_8c-source.html#l01205">rtdm_sem_timeddown()</a>, <a class="el" href="nucleus_2registry_8c-source.html#l00716">xnregistry_bind()</a>, <a class="el" href="nucleus_2registry_8c-source.html#l00912">xnregistry_remove_safe()</a>, and <a class="el" href="select_8c-source.html#l00310">xnselect()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gc9926fd6af7a7fe01b9f8d02c1a62957"></a><!-- doxytag: member="synch.c::xnsynch_wakeup_one_sleeper" ref="gc9926fd6af7a7fe01b9f8d02c1a62957" args="(xnsynch_t *synch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnthread_t* xnsynch_wakeup_one_sleeper           </td>
          <td>(</td>
          <td class="paramtype">xnsynch_t *&nbsp;</td>
          <td class="paramname"> <em>synch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Give the resource ownership to the next waiting thread. 
<p>
This service gives the ownership of a synchronization object to the thread which is currently leading the object's pending list. The sleeping thread is unblocked, but no action is taken regarding the previous owner of the resource.<p>
This service should be called by upper interfaces wanting to signal the given resource so that a single waiter is resumed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>synch</em>&nbsp;</td><td>The descriptor address of the synchronization object whose ownership is changed.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The descriptor address of the unblocked thread.</dd></dl>
Side-effects:<p>
<ul>
<li>The effective priority of the previous resource owner might be lowered to its base priority value as a consequence of the priority inheritance boost being cleared.</li></ul>
<p>
<ul>
<li>The synchronization object ownership is transfered to the unblocked thread.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
<p>References <a class="el" href="include_2nucleus_2thread_8h-source.html#l00034">XNPEND</a>, <a class="el" href="pod_8c-source.html#l01559">xnpod_resume_thread()</a>, <a class="el" href="synch_8c-source.html#l00268">xnsynch_clear_boost()</a>, and <a class="el" href="include_2nucleus_2thread_8h-source.html#l00114">XNWAKEN</a>.</p>

<p>Referenced by <a class="el" href="ksrc_2skins_2posix_2cond_8c-source.html#l00516">pthread_cond_signal()</a>, <a class="el" href="skins_2posix_2thread_8c-source.html#l00399">pthread_join()</a>, <a class="el" href="ksrc_2skins_2native_2cond_8c-source.html#l00308">rt_cond_signal()</a>, <a class="el" href="ksrc_2skins_2native_2cond_8c-source.html#l00442">rt_cond_wait()</a>, <a class="el" href="ksrc_2skins_2native_2mutex_8c-source.html#l00440">rt_mutex_release()</a>, <a class="el" href="ksrc_2skins_2native_2queue_8c-source.html#l00606">rt_queue_send()</a>, <a class="el" href="ksrc_2skins_2native_2sem_8c-source.html#l00434">rt_sem_v()</a>, <a class="el" href="drvlib_8c-source.html#l01278">rtdm_sem_up()</a>, <a class="el" href="ksrc_2skins_2posix_2sem_8c-source.html#l00716">sem_post()</a>, and <a class="el" href="synch_8c-source.html#l00676">xnsynch_release_all_ownerships()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g15b56df22d23acd5de3d1d622b2caa6a"></a><!-- doxytag: member="synch.c::xnsynch_wakeup_this_sleeper" ref="g15b56df22d23acd5de3d1d622b2caa6a" args="(xnsynch_t *synch, xnpholder_t *holder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnpholder_t* xnsynch_wakeup_this_sleeper           </td>
          <td>(</td>
          <td class="paramtype">xnsynch_t *&nbsp;</td>
          <td class="paramname"> <em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnpholder_t *&nbsp;</td>
          <td class="paramname"> <em>holder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Give the resource ownership to a given waiting thread. 
<p>
This service gives the ownership of a given synchronization object to a specific thread which is currently pending on it. The sleeping thread is unblocked from its pending state. No action is taken regarding the previous resource owner.<p>
This service should be called by upper interfaces wanting to signal the given resource so that a specific waiter is resumed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>synch</em>&nbsp;</td><td>The descriptor address of the synchronization object whose ownership is changed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>holder</em>&nbsp;</td><td>The link holder address of the thread to unblock (&amp;thread-&gt;plink) which MUST be currently linked to the synchronization object's pending queue (i.e. synch-&gt;pendq).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The link address of the next waiting thread in the synchronization object's pending queue.</dd></dl>
Side-effects:<p>
<ul>
<li>The effective priority of the previous resource owner might be lowered to its base priority value as a consequence of the priority inheritance boost being cleared.</li></ul>
<p>
<ul>
<li>The synchronization object ownership is transfered to the unblocked thread.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
<p>References <a class="el" href="include_2nucleus_2thread_8h-source.html#l00034">XNPEND</a>, <a class="el" href="pod_8c-source.html#l01559">xnpod_resume_thread()</a>, <a class="el" href="synch_8c-source.html#l00268">xnsynch_clear_boost()</a>, and <a class="el" href="include_2nucleus_2thread_8h-source.html#l00114">XNWAKEN</a>.</p>

<p>Referenced by <a class="el" href="ksrc_2skins_2native_2event_8c-source.html#l00329">rt_event_signal()</a>, and <a class="el" href="ksrc_2skins_2native_2heap_8c-source.html#l00642">rt_heap_free()</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Feb 26 15:05:07 2009 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
