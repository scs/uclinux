<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Alarm services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Alarm services.<br>
<small>
[<a class="el" href="group__native.html">Native Xenomai API.</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Alarm services.:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__alarm.png" border="0" alt="" usemap="#group____alarm_map">
<map name="group____alarm_map">
<area shape="rect" href="group__native.html" title="Native Xenomai API." alt="" coords="5,6,149,30"></map></td></tr></table></center>
</div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Alarms are general watchdog timers. Any Xenomai task may create any number of alarms and use them to run a user-defined handler, after a specified initial delay has elapsed. Alarms can be either one shot or periodic; in the latter case, the real-time kernel automatically reprograms the alarm for the next shot according to a user-defined interval value. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksrc_2skins_2native_2alarm_8c.html">alarm.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file is part of the Xenomai project. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#g22353f79379121bbebfa0e72bbde5028">rt_alarm_create</a> (RT_ALARM *alarm, const char *name, rt_alarm_t handler, void *cookie)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an alarm object from kernel space.  <a href="#g22353f79379121bbebfa0e72bbde5028"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#gf00e05b47b1183816480e270d326f9ac">rt_alarm_delete</a> (RT_ALARM *alarm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete an alarm.  <a href="#gf00e05b47b1183816480e270d326f9ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#g0d9cb8ae623be0f7224ac47b10a0b542">rt_alarm_start</a> (RT_ALARM *alarm, RTIME value, RTIME interval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an alarm.  <a href="#g0d9cb8ae623be0f7224ac47b10a0b542"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#g71f2ffec98e3e23fe5d7f87c2cb24d77">rt_alarm_stop</a> (RT_ALARM *alarm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop an alarm.  <a href="#g71f2ffec98e3e23fe5d7f87c2cb24d77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#g25c4556b6e2f6fa220a734bf83c4c374">rt_alarm_inquire</a> (RT_ALARM *alarm, RT_ALARM_INFO *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inquire about an alarm.  <a href="#g25c4556b6e2f6fa220a734bf83c4c374"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#g53e7f8400068253d2df58e6b4a7978ae">rt_alarm_create</a> (RT_ALARM *alarm, const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an alarm object from user-space.  <a href="#g53e7f8400068253d2df58e6b4a7978ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alarm.html#g6c0caadae03541db8a46751d290c0d76">rt_alarm_wait</a> (RT_ALARM *alarm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the next alarm shot.  <a href="#g6c0caadae03541db8a46751d290c0d76"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g53e7f8400068253d2df58e6b4a7978ae"></a><!-- doxytag: member="alarm.c::rt_alarm_create" ref="g53e7f8400068253d2df58e6b4a7978ae" args="(RT_ALARM *alarm, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_alarm_create           </td>
          <td>(</td>
          <td class="paramtype">RT_ALARM *&nbsp;</td>
          <td class="paramname"> <em>alarm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an alarm object from user-space. 
<p>
Initializes an alarm object from a user-space application. Alarms can be made periodic or oneshot, depending on the reload interval value passed to <a class="el" href="group__alarm.html#g0d9cb8ae623be0f7224ac47b10a0b542" title="Start an alarm.">rt_alarm_start()</a> for them. In this mode, the basic principle is to define some alarm server task which routinely waits for the next incoming alarm event through the <a class="el" href="group__alarm.html#g6c0caadae03541db8a46751d290c0d76" title="Wait for the next alarm shot.">rt_alarm_wait()</a> syscall.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>alarm</em>&nbsp;</td><td>The address of an alarm descriptor Xenomai will use to store the alarm-related data. This descriptor must always be valid while the alarm is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the alarm. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created alarm.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the system fails to get enough dynamic memory from the global real-time heap in order to register the alarm.</li></ul>
<p>
<ul>
<li>-EEXIST is returned if the <em>name</em> is already in use by some registered object.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>User-space task</li></ul>
<p>
Rescheduling: possible.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is possible to combine kernel-based alarm handling with waiter threads pending on the same alarm object from user-space through the <a class="el" href="group__alarm.html#g6c0caadae03541db8a46751d290c0d76" title="Wait for the next alarm shot.">rt_alarm_wait()</a> service. For this purpose, the rt_alarm_handler() routine which is internally invoked to wake up alarm servers in user-space is accessible to user-provided alarm handlers in kernel space, and should be called from there in order to unblock any thread sleeping on the <a class="el" href="group__alarm.html#g6c0caadae03541db8a46751d290c0d76" title="Wait for the next alarm shot.">rt_alarm_wait()</a> service. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g22353f79379121bbebfa0e72bbde5028"></a><!-- doxytag: member="alarm.c::rt_alarm_create" ref="g22353f79379121bbebfa0e72bbde5028" args="(RT_ALARM *alarm, const char *name, rt_alarm_t handler, void *cookie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_alarm_create           </td>
          <td>(</td>
          <td class="paramtype">RT_ALARM *&nbsp;</td>
          <td class="paramname"> <em>alarm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_alarm_t&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an alarm object from kernel space. 
<p>
Create an object triggering an alarm routine at a specified time in the future. Alarms can be made periodic or oneshot, depending on the reload interval value passed to <a class="el" href="group__alarm.html#g0d9cb8ae623be0f7224ac47b10a0b542" title="Start an alarm.">rt_alarm_start()</a> for them. In kernel space, alarms are immediately notified on behalf of the timer interrupt to a user-defined handler.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>alarm</em>&nbsp;</td><td>The address of an alarm descriptor Xenomai will use to store the alarm-related data. This descriptor must always be valid while the alarm is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the alarm. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created alarm.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The address of the routine to call when the alarm expires. This routine will be passed the address of the current alarm descriptor, and the opaque <em>cookie</em>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cookie</em>&nbsp;</td><td>A user-defined opaque cookie the real-time kernel will pass to the alarm handler as its second argument.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the system fails to get enough dynamic memory from the global real-time heap in order to register the alarm.</li></ul>
<p>
<ul>
<li>-EEXIST is returned if the <em>name</em> is already in use by some registered object.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li></ul>
<p>
Rescheduling: possible.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is possible to combine kernel-based alarm handling with waiter threads pending on the same alarm object from user-space through the <a class="el" href="group__alarm.html#g6c0caadae03541db8a46751d290c0d76" title="Wait for the next alarm shot.">rt_alarm_wait()</a> service. For this purpose, the rt_alarm_handler() routine which is internally invoked to wake up alarm servers in user-space is accessible to user-provided alarm handlers in kernel space, and should be called from there in order to unblock any thread sleeping on the <a class="el" href="group__alarm.html#g6c0caadae03541db8a46751d290c0d76" title="Wait for the next alarm shot.">rt_alarm_wait()</a> service. </dd></dl>

<p>References <a class="el" href="src_2skins_2native_2alarm_8c-source.html#l00030">rt_alarm_delete()</a>, <a class="el" href="nucleus_2registry_8c-source.html#l00582">xnregistry_enter()</a>, and <a class="el" href="synch_8c-source.html#l00087">xnsynch_init()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gf00e05b47b1183816480e270d326f9ac"></a><!-- doxytag: member="alarm.c::rt_alarm_delete" ref="gf00e05b47b1183816480e270d326f9ac" args="(RT_ALARM *alarm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_alarm_delete           </td>
          <td>(</td>
          <td class="paramtype">RT_ALARM *&nbsp;</td>
          <td class="paramname"> <em>alarm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete an alarm. 
<p>
Destroy an alarm. An alarm exists in the system since <a class="el" href="group__alarm.html#g22353f79379121bbebfa0e72bbde5028" title="Create an alarm object from kernel space.">rt_alarm_create()</a> has been called to create it, so this service must be called in order to destroy it afterwards.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>alarm</em>&nbsp;</td><td>The descriptor address of the affected alarm.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>alarm</em> is not a alarm descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>alarm</em> is a deleted alarm descriptor.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from an asynchronous context.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
<p>References <a class="el" href="pod_8c-source.html#l02373">xnpod_schedule()</a>, <a class="el" href="nucleus_2registry_8c-source.html#l00809">xnregistry_remove()</a>, and <a class="el" href="ksrc_2nucleus_2timer_8c-source.html#l00824">xntimer_destroy()</a>.</p>

<p>Referenced by <a class="el" href="ksrc_2skins_2native_2alarm_8c-source.html#l00187">rt_alarm_create()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g25c4556b6e2f6fa220a734bf83c4c374"></a><!-- doxytag: member="alarm.c::rt_alarm_inquire" ref="g25c4556b6e2f6fa220a734bf83c4c374" args="(RT_ALARM *alarm, RT_ALARM_INFO *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_alarm_inquire           </td>
          <td>(</td>
          <td class="paramtype">RT_ALARM *&nbsp;</td>
          <td class="paramname"> <em>alarm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_ALARM_INFO *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inquire about an alarm. 
<p>
Return various information about the status of a given alarm.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>alarm</em>&nbsp;</td><td>The descriptor address of the inquired alarm.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>The address of a structure the alarm information will be written to.</td></tr>
  </table>
</dl>
The expiration date returned in the information block is converted to the current time unit. The special value TM_INFINITE is returned if <em>alarm</em> is currently inactive/stopped. In single-shot mode, it might happen that the alarm has already expired when this service is run (even if the associated handler has not been fired yet); in such a case, 1 is returned.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned and status information is written to the structure pointed at by <em>info</em> upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>alarm</em> is not a alarm descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>alarm</em> is a deleted alarm descriptor.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
<p>References <a class="el" href="include_2nucleus_2timer_8h-source.html#l00582">xntimer_get_timeout()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g0d9cb8ae623be0f7224ac47b10a0b542"></a><!-- doxytag: member="alarm.c::rt_alarm_start" ref="g0d9cb8ae623be0f7224ac47b10a0b542" args="(RT_ALARM *alarm, RTIME value, RTIME interval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_alarm_start           </td>
          <td>(</td>
          <td class="paramtype">RT_ALARM *&nbsp;</td>
          <td class="paramname"> <em>alarm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>interval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an alarm. 
<p>
Program the trigger date of an alarm object. An alarm can be either periodic or oneshot, depending on the reload value passed to this routine. The given alarm must have been previously created by a call to <a class="el" href="group__alarm.html#g22353f79379121bbebfa0e72bbde5028" title="Create an alarm object from kernel space.">rt_alarm_create()</a>.<p>
Alarm handlers are always called on behalf of Xenomai's internal timer tick handler, so the Xenomai services which can be called from such handlers are restricted to the set of services available on behalf of any ISR.<p>
This service overrides any previous setup of the expiry date and reload interval for the given alarm.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>alarm</em>&nbsp;</td><td>The descriptor address of the affected alarm.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The relative date of the initial alarm shot, expressed in clock ticks (see note).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interval</em>&nbsp;</td><td>The reload value of the alarm. It is a periodic interval value to be used for reprogramming the next alarm shot, expressed in clock ticks (see note). If <em>interval</em> is equal to TM_INFINITE, the alarm will not be reloaded after it has expired.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>alarm</em> is not a alarm descriptor.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The initial <em>value</em> and <em>interval</em> will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

<p>References <a class="el" href="include_2nucleus_2timer_8h-source.html#l00466">xntimer_start()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g71f2ffec98e3e23fe5d7f87c2cb24d77"></a><!-- doxytag: member="alarm.c::rt_alarm_stop" ref="g71f2ffec98e3e23fe5d7f87c2cb24d77" args="(RT_ALARM *alarm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_alarm_stop           </td>
          <td>(</td>
          <td class="paramtype">RT_ALARM *&nbsp;</td>
          <td class="paramname"> <em>alarm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stop an alarm. 
<p>
Disarm an alarm object previously armed using <a class="el" href="group__alarm.html#g0d9cb8ae623be0f7224ac47b10a0b542" title="Start an alarm.">rt_alarm_start()</a> so that it will not trigger until is is re-armed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>alarm</em>&nbsp;</td><td>The descriptor address of the released alarm.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>alarm</em> is not a alarm descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>alarm</em> is a deleted alarm descriptor.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
<p>References <a class="el" href="include_2nucleus_2timer_8h-source.html#l00498">xntimer_stop()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g6c0caadae03541db8a46751d290c0d76"></a><!-- doxytag: member="alarm.c::rt_alarm_wait" ref="g6c0caadae03541db8a46751d290c0d76" args="(RT_ALARM *alarm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_alarm_wait           </td>
          <td>(</td>
          <td class="paramtype">RT_ALARM *&nbsp;</td>
          <td class="paramname"> <em>alarm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for the next alarm shot. 
<p>
This user-space only call allows the current task to suspend execution until the specified alarm triggers. The priority of the current task is raised above all other Xenomai tasks - except those also undergoing an alarm or interrupt wait (see <a class="el" href="group__interrupt.html#g222e6a9a681f83b13ed5b51021711f4d" title="Wait for the next interrupt.">rt_intr_wait()</a>) - so that it would preempt any of them under normal circumstances (i.e. no scheduler lock).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>alarm</em>&nbsp;</td><td>The descriptor address of the awaited alarm.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>alarm</em> is not an alarm descriptor.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>alarm</em> is a deleted alarm descriptor, including if the deletion occurred while the caller was waiting for its next shot.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the current task before the next alarm shot.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>User-space task</li></ul>
<p>
Rescheduling: always. <dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="user__alarm_8c-example.html#a0">user_alarm.c</a>.</dl>
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Nov 8 19:15:28 2008 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
