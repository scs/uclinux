<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Semaphores services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Semaphores services.<br>
<small>
[<a class="el" href="group__posix.html">POSIX skin.</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Semaphores services.:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__posix__sem.png" border="0" alt="" usemap="#group____posix____sem_map">
<map name="group____posix____sem_map">
<area shape="rect" href="group__posix.html" title="Xenomai POSIX skin is an implementation of a small subset of the Single Unix specification..." alt="" coords="7,6,100,30"></map></td></tr></table></center>
</div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Semaphores services. 
<p>
Semaphores are counters for resources shared between threads. The basic operations on semaphores are: increment the counter atomically, and wait until the counter is non-null and decrement it atomically.<p>
Semaphores have a maximum value past which they cannot be incremented. The macro <em>SEM_VALUE_MAX</em> is defined to be this maximum value. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__sem.html#g39b0c38dd6210ff17b5b7da04598efd0">sem_init</a> (sem_t *sm, int pshared, unsigned value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize an unnamed semaphore.  <a href="#g39b0c38dd6210ff17b5b7da04598efd0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__sem.html#g6dbe34606b393161567a658a32be87af">sem_destroy</a> (sem_t *sm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy an unnamed semaphore.  <a href="#g6dbe34606b393161567a658a32be87af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">sem_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__sem.html#gd935e509cd7f0d2792d08ec83077ca85">sem_open</a> (const char *name, int oflags,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a named semaphore.  <a href="#gd935e509cd7f0d2792d08ec83077ca85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__sem.html#g50375fb52969cf12add3096a2ab83b04">sem_close</a> (sem_t *sm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a named semaphore.  <a href="#g50375fb52969cf12add3096a2ab83b04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__sem.html#g776256d1a473906f8b7490689bfcb75c">sem_unlink</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlink a named semaphore.  <a href="#g776256d1a473906f8b7490689bfcb75c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__sem.html#gb610b10f891a7c892c9ba8ee48e39a09">sem_trywait</a> (sem_t *sm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to lock a semaphore.  <a href="#gb610b10f891a7c892c9ba8ee48e39a09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__sem.html#g1b9226cb6b1c40511c025309c0b6b2ee">sem_wait</a> (sem_t *sm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock a semaphore.  <a href="#g1b9226cb6b1c40511c025309c0b6b2ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__sem.html#g8678e7f5136343ef8d8123a185878f78">sem_timedwait</a> (sem_t *sm, const struct timespec *abs_timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt, during a bounded time, to lock a semaphore.  <a href="#g8678e7f5136343ef8d8123a185878f78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__sem.html#g3ceb2577b76aaad3be6fd83e959c66e3">sem_post</a> (sem_t *sm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a semaphore.  <a href="#g3ceb2577b76aaad3be6fd83e959c66e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__sem.html#g0485350388d685298193153ed0ec0b95">sem_getvalue</a> (sem_t *sm, int *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the value of a semaphore.  <a href="#g0485350388d685298193153ed0ec0b95"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g50375fb52969cf12add3096a2ab83b04"></a><!-- doxytag: member="sem.c::sem_close" ref="g50375fb52969cf12add3096a2ab83b04" args="(sem_t *sm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sem_close           </td>
          <td>(</td>
          <td class="paramtype">sem_t *&nbsp;</td>
          <td class="paramname"> <em>sm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close a named semaphore. 
<p>
This service closes the semaphore <em>sm</em>. The semaphore is destroyed only when unlinked with a call to the <a class="el" href="group__posix__sem.html#g776256d1a473906f8b7490689bfcb75c" title="Unlink a named semaphore.">sem_unlink()</a> service and when each call to <a class="el" href="group__posix__sem.html#gd935e509cd7f0d2792d08ec83077ca85" title="Open a named semaphore.">sem_open()</a> matches a call to this service.<p>
When a semaphore is destroyed, the memory it used is returned to the system heap, so that further references to this semaphore are not guaranteed to fail, as is the case for unnamed semaphores.<p>
This service fails if <em>sm</em> is an unnamed semaphore.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sm</em>&nbsp;</td><td>the semaphore to be closed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:<ul>
<li>EINVAL, the semaphore <em>sm</em> is invalid or is an unnamed semaphore.</li></ul>
</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_close.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6dbe34606b393161567a658a32be87af"></a><!-- doxytag: member="sem.c::sem_destroy" ref="g6dbe34606b393161567a658a32be87af" args="(sem_t *sm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sem_destroy           </td>
          <td>(</td>
          <td class="paramtype">sem_t *&nbsp;</td>
          <td class="paramname"> <em>sm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy an unnamed semaphore. 
<p>
This service destroys the semaphore <em>sm</em>. Threads currently blocked on <em>sm</em> are unblocked and the service they called return -1 with <em>errno</em> set to EINVAL. The semaphore is then considered invalid by all semaphore services (they all fail with <em>errno</em> set to EINVAL) except <a class="el" href="group__posix__sem.html#g39b0c38dd6210ff17b5b7da04598efd0" title="Initialize an unnamed semaphore.">sem_init()</a>.<p>
This service fails if <em>sm</em> is a named semaphore.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sm</em>&nbsp;</td><td>the semaphore to be destroyed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success, </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:<ul>
<li>EINVAL, the semaphore <em>sm</em> is invalid or a named semaphore;</li><li>EPERM, the semaphore <em>sm</em> is not process-shared and does not belong to the current process.</li></ul>
</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_destroy.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0485350388d685298193153ed0ec0b95"></a><!-- doxytag: member="sem.c::sem_getvalue" ref="g0485350388d685298193153ed0ec0b95" args="(sem_t *sm, int *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sem_getvalue           </td>
          <td>(</td>
          <td class="paramtype">sem_t *&nbsp;</td>
          <td class="paramname"> <em>sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the value of a semaphore. 
<p>
This service stores at the address <em>value</em>, the current count of the semaphore <em>sm</em>. The state of the semaphore is unchanged.<p>
If the semaphore is currently locked, the value stored is zero.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sm</em>&nbsp;</td><td>a semaphore;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>address where the semaphore count will be stored on success.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:<ul>
<li>EINVAL, the semaphore is invalid or uninitialized;</li><li>EPERM, the semaphore <em>sm</em> is not process-shared and does not belong to the current process.</li></ul>
</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_getvalue.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g39b0c38dd6210ff17b5b7da04598efd0"></a><!-- doxytag: member="sem.c::sem_init" ref="g39b0c38dd6210ff17b5b7da04598efd0" args="(sem_t *sm, int pshared, unsigned value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sem_init           </td>
          <td>(</td>
          <td class="paramtype">sem_t *&nbsp;</td>
          <td class="paramname"> <em>sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pshared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize an unnamed semaphore. 
<p>
This service initializes the semaphore <em>sm</em>, with the value <em>value</em>.<p>
This service fails if <em>sm</em> is already initialized or is a named semaphore.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sm</em>&nbsp;</td><td>the semaphore to be initialized;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pshared</em>&nbsp;</td><td>if zero, means that the new semaphore may only be used by threads in the same process as the thread calling <a class="el" href="group__posix__sem.html#g39b0c38dd6210ff17b5b7da04598efd0" title="Initialize an unnamed semaphore.">sem_init()</a>; if non zero, means that the new semaphore may be used by any thread that has access to the memory where the semaphore is allocated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>the semaphore initial value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success, </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:<ul>
<li>EBUSY, the semaphore <em>sm</em> was already initialized;</li><li>ENOSPC, insufficient memory exists in the system heap to initialize the semaphore, increase CONFIG_XENO_OPT_SYS_HEAPSZ;</li><li>EINVAL, the <em>value</em> argument exceeds <em>SEM_VALUE_MAX</em>.</li></ul>
</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_init.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd935e509cd7f0d2792d08ec83077ca85"></a><!-- doxytag: member="sem.c::sem_open" ref="gd935e509cd7f0d2792d08ec83077ca85" args="(const char *name, int oflags,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sem_t* sem_open           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>oflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open a named semaphore. 
<p>
This service establishes a connection between the semaphore named <em>name</em> and the calling context (kernel-space as a whole, or user-space process).<p>
If no semaphore named <em>name</em> exists and <em>oflags</em> has the <em>O_CREAT</em> bit set, the semaphore is created by this function, using two more arguments:<ul>
<li>a <em>mode</em> argument, of type <b>mode_t</b>, currently ignored;</li><li>a <em>value</em> argument, of type <b>unsigned</b>, specifying the initial value of the created semaphore.</li></ul>
<p>
If <em>oflags</em> has the two bits <em>O_CREAT</em> and <em>O_EXCL</em> set and the semaphore already exists, this service fails.<p>
<em>name</em> may be any arbitrary string, in which slashes have no particular meaning. However, for portability, using a name which starts with a slash and contains no other slash is recommended.<p>
If <a class="el" href="group__posix__sem.html#gd935e509cd7f0d2792d08ec83077ca85" title="Open a named semaphore.">sem_open()</a> is called from the same context (kernel-space as a whole, or user-space process) several times with the same value of <em>name</em>, the same address is returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the name of the semaphore to be created;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oflags</em>&nbsp;</td><td>flags.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the address of the named semaphore on success; <p>
SEM_FAILED with <em>errno</em> set if:<ul>
<li>ENAMETOOLONG, the length of the <em>name</em> argument exceeds 64 characters;</li><li>EEXIST, the bits <em>O_CREAT</em> and <em>O_EXCL</em> were set in <em>oflags</em> and the named semaphore already exists;</li><li>ENOENT, the bit <em>O_CREAT</em> is not set in <em>oflags</em> and the named semaphore does not exist;</li><li>ENOSPC, insufficient memory exists in the system heap to create the semaphore, increase CONFIG_XENO_OPT_SYS_HEAPSZ;</li><li>EINVAL, the <em>value</em> argument exceeds <em>SEM_VALUE_MAX</em>.</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_open.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3ceb2577b76aaad3be6fd83e959c66e3"></a><!-- doxytag: member="sem.c::sem_post" ref="g3ceb2577b76aaad3be6fd83e959c66e3" args="(sem_t *sm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sem_post           </td>
          <td>(</td>
          <td class="paramtype">sem_t *&nbsp;</td>
          <td class="paramname"> <em>sm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlock a semaphore. 
<p>
This service unlocks the semaphore <em>sm</em>.<p>
If no thread is currently blocked on this semaphore, its count is incremented, otherwise the highest priority thread is unblocked.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sm</em>&nbsp;</td><td>the semaphore to be unlocked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with errno set if:<ul>
<li>EINVAL, the specified semaphore is invalid or uninitialized;</li><li>EPERM, the semaphore <em>sm</em> is not process-shared and does not belong to the current process;</li><li>EAGAIN, the semaphore count is <em>SEM_VALUE_MAX</em>.</li></ul>
</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_post.html">Specification.</a> </dd></dl>

<p>References <a class="el" href="pod_8c-source.html#l02373">xnpod_schedule()</a>, and <a class="el" href="synch_8c-source.html#l00376">xnsynch_wakeup_one_sleeper()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g8678e7f5136343ef8d8123a185878f78"></a><!-- doxytag: member="sem.c::sem_timedwait" ref="g8678e7f5136343ef8d8123a185878f78" args="(sem_t *sm, const struct timespec *abs_timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sem_timedwait           </td>
          <td>(</td>
          <td class="paramtype">sem_t *&nbsp;</td>
          <td class="paramname"> <em>sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&nbsp;</td>
          <td class="paramname"> <em>abs_timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt, during a bounded time, to lock a semaphore. 
<p>
This serivce is equivalent to <a class="el" href="group__posix__sem.html#g1b9226cb6b1c40511c025309c0b6b2ee" title="Lock a semaphore.">sem_wait()</a>, except that the caller is only blocked until the timeout <em>abs_timeout</em> expires.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sm</em>&nbsp;</td><td>the semaphore to be locked;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>abs_timeout</em>&nbsp;</td><td>the timeout, expressed as an absolute value of the CLOCK_REALTIME clock.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:<ul>
<li>EPERM, the caller context is invalid;</li><li>EINVAL, the semaphore is invalid or uninitialized;</li><li>EINVAL, the specified timeout is invalid;</li><li>EPERM, the semaphore <em>sm</em> is not process-shared and does not belong to the current process;</li><li>EINTR, the caller was interrupted by a signal while blocked in this service;</li><li>ETIMEDOUT, the semaphore could not be locked and the specified timeout expired.</li></ul>
</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>Xenomai kernel-space thread,</li><li>Xenomai user-space thread (switches to primary mode).</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_timedwait.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb610b10f891a7c892c9ba8ee48e39a09"></a><!-- doxytag: member="sem.c::sem_trywait" ref="gb610b10f891a7c892c9ba8ee48e39a09" args="(sem_t *sm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sem_trywait           </td>
          <td>(</td>
          <td class="paramtype">sem_t *&nbsp;</td>
          <td class="paramname"> <em>sm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to lock a semaphore. 
<p>
This service is equivalent to <a class="el" href="group__posix__sem.html#g1b9226cb6b1c40511c025309c0b6b2ee" title="Lock a semaphore.">sem_wait()</a>, except that it returns immediately if the semaphore <em>sm</em> is currently locked, and that it is not a cancellation point.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sm</em>&nbsp;</td><td>the semaphore to be locked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:<ul>
<li>EINVAL, the specified semaphore is invalid or uninitialized;</li><li>EPERM, the semaphore <em>sm</em> is not process-shared and does not belong to the current process;</li><li>EAGAIN, the specified semaphore is currently locked.</li></ul>
</td></tr>
  </table>
</dl>
* <dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_trywait.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g776256d1a473906f8b7490689bfcb75c"></a><!-- doxytag: member="sem.c::sem_unlink" ref="g776256d1a473906f8b7490689bfcb75c" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sem_unlink           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlink a named semaphore. 
<p>
This service unlinks the semaphore named <em>name</em>. This semaphore is not destroyed until all references obtained with <a class="el" href="group__posix__sem.html#gd935e509cd7f0d2792d08ec83077ca85" title="Open a named semaphore.">sem_open()</a> are closed by calling <a class="el" href="group__posix__sem.html#g50375fb52969cf12add3096a2ab83b04" title="Close a named semaphore.">sem_close()</a>. However, the unlinked semaphore may no longer be reached with the <a class="el" href="group__posix__sem.html#gd935e509cd7f0d2792d08ec83077ca85" title="Open a named semaphore.">sem_open()</a> service.<p>
When a semaphore is destroyed, the memory it used is returned to the system heap, so that further references to this semaphore are not guaranteed to fail, as is the case for unnamed semaphores.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the name of the semaphore to be unlinked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:<ul>
<li>ENAMETOOLONG, the length of the <em>name</em> argument exceeds 64 characters;</li><li>ENOENT, the named semaphore does not exist.</li></ul>
</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_unlink.html">Specification.</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1b9226cb6b1c40511c025309c0b6b2ee"></a><!-- doxytag: member="sem.c::sem_wait" ref="g1b9226cb6b1c40511c025309c0b6b2ee" args="(sem_t *sm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sem_wait           </td>
          <td>(</td>
          <td class="paramtype">sem_t *&nbsp;</td>
          <td class="paramname"> <em>sm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lock a semaphore. 
<p>
This service locks the semaphore <em>sm</em> if it is currently unlocked (i.e. if its value is greater than 0). If the semaphore is currently locked, the calling thread is suspended until the semaphore is unlocked, or a signal is delivered to the calling thread.<p>
This service is a cancellation point for Xenomai POSIX skin threads (created with the <a class="el" href="group__posix__thread.html#ge6e819ed048e4c4a4ee96fa6f426852c" title="Create a thread.">pthread_create()</a> service). When such a thread is cancelled while blocked in a call to this service, the semaphore state is left unchanged before the cancellation cleanup handlers are called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sm</em>&nbsp;</td><td>the semaphore to be locked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:<ul>
<li>EPERM, the caller context is invalid;</li><li>EINVAL, the semaphore is invalid or uninitialized;</li><li>EPERM, the semaphore <em>sm</em> is not process-shared and does not belong to the current process;</li><li>EINTR, the caller was interrupted by a signal while blocked in this service.</li></ul>
</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Valid contexts:</b></dt><dd><ul>
<li>Xenomai kernel-space thread,</li><li>Xenomai user-space thread (switches to primary mode).</li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/sem_wait.html">Specification.</a> </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Nov 8 19:15:30 2008 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
