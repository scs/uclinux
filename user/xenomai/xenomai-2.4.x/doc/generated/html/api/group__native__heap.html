<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Memory heap services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Memory heap services.<br>
<small>
[<a class="el" href="group__native.html">Native Xenomai API.</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Memory heap services.:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__native__heap.png" border="0" alt="" usemap="#group____native____heap_map">
<map name="group____native____heap_map">
<area shape="rect" href="group__native.html" title="Native Xenomai API." alt="" coords="5,6,149,30"></map></td></tr></table></center>
</div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Memory heaps are regions of memory used for dynamic memory allocation in a time-bounded fashion. Blocks of memory are allocated and freed in an arbitrary order and the pattern of allocation and size of blocks is not known until run time.<p>
The implementation of the memory allocator follows the algorithm described in a USENIX 1988 paper called "Design of a General Purpose Memory Allocator for the 4.3BSD Unix Kernel" by Marshall K. McKusick and Michael J. Karels.<p>
Xenomai memory heaps are built over the nucleus's heap objects, which in turn provide the needed support for sharing a memory area between kernel and user-space using direct memory mapping. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksrc_2skins_2native_2heap_8c.html">heap.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file is part of the Xenomai project. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__heap.html#g1d19ad24dc9f94b969aa0f574170bdc4">rt_heap_create</a> (RT_HEAP *heap, const char *name, size_t heapsize, int mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a memory heap or a shared memory segment.  <a href="#g1d19ad24dc9f94b969aa0f574170bdc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__heap.html#g08f8d244a545fd6a5719ad5708552552">rt_heap_delete</a> (RT_HEAP *heap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a real-time heap.  <a href="#g08f8d244a545fd6a5719ad5708552552"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__heap.html#g52678149ff2b66e47aa8cdcddab653a4">rt_heap_alloc</a> (RT_HEAP *heap, size_t size, RTIME timeout, void **blockp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block or return the single segment base.  <a href="#g52678149ff2b66e47aa8cdcddab653a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__heap.html#g300ca8c868d02dad99790fe39b443f6f">rt_heap_free</a> (RT_HEAP *heap, void *block)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a block.  <a href="#g300ca8c868d02dad99790fe39b443f6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__heap.html#g6af669528e1bcae4f1ed15b292bda08e">rt_heap_inquire</a> (RT_HEAP *heap, <a class="el" href="structrt__heap__info.html">RT_HEAP_INFO</a> *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inquire about a heap.  <a href="#g6af669528e1bcae4f1ed15b292bda08e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__heap.html#ge17a8784a83d2eec94089a86a831a833">rt_heap_bind</a> (RT_HEAP *heap, const char *name, RTIME timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind to a mappable heap.  <a href="#ge17a8784a83d2eec94089a86a831a833"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__native__heap.html#gea086656fe119a563e8c0b6d44f83c8e">rt_heap_unbind</a> (RT_HEAP *heap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unbind from a mappable heap.  <a href="#gea086656fe119a563e8c0b6d44f83c8e"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g52678149ff2b66e47aa8cdcddab653a4"></a><!-- doxytag: member="heap.c::rt_heap_alloc" ref="g52678149ff2b66e47aa8cdcddab653a4" args="(RT_HEAP *heap, size_t size, RTIME timeout, void **blockp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_heap_alloc           </td>
          <td>(</td>
          <td class="paramtype">RT_HEAP *&nbsp;</td>
          <td class="paramname"> <em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>blockp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a block or return the single segment base. 
<p>
This service allocates a block from the heap's internal pool, or returns the address of the single memory segment in the caller's address space. Tasks may wait for some requested amount of memory to become available from local heaps.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>The descriptor address of the heap to allocate a block from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The requested size in bytes of the block. If the heap is managed as a single-block area (H_SINGLE), this value can be either zero, or the same value given to <a class="el" href="group__native__heap.html#g1d19ad24dc9f94b969aa0f574170bdc4" title="Create a memory heap or a shared memory segment.">rt_heap_create()</a>. In that case, the same block covering the entire heap space will always be returned to all callers of this service.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for a block of sufficient size to be available from a local heap (see note). Passing TM_INFINITE causes the caller to block indefinitely until some block is eventually available. Passing TM_NONBLOCK causes the service to return immediately without waiting if no block is available on entry. This parameter has no influence if the heap is managed as a single-block area since the entire heap space is always available.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockp</em>&nbsp;</td><td>A pointer to a memory location which will be written upon success with the address of the allocated block, or the start address of the single memory segment. In the former case, the block should be freed using <a class="el" href="group__native__heap.html#g300ca8c868d02dad99790fe39b443f6f" title="Free a block.">rt_heap_free()</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>heap</em> is not a heap descriptor, or <em>heap</em> is managed as a single-block area (i.e. H_SINGLE mode) and <em>size</em> is non-zero but does not match the original heap size passed to <a class="el" href="group__native__heap.html#g1d19ad24dc9f94b969aa0f574170bdc4" title="Create a memory heap or a shared memory segment.">rt_heap_create()</a>.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>heap</em> is a deleted heap descriptor.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if <em>timeout</em> is different from TM_NONBLOCK and no block is available within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and no block is immediately available on entry.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the waiting task before any block was available.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service should block but was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine only if <em>timeout</em> is equal to TM_NONBLOCK, or the heap is managed as a single-block area.</li></ul>
<p>
<ul>
<li>Kernel-based task</li><li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation. Operations on single-block heaps never start the rescheduling procedure.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>

<p>References <a class="el" href="include_2nucleus_2thread_8h-source.html#l00112">XNBREAK</a>, <a class="el" href="ksrc_2nucleus_2heap_8c-source.html#l00429">xnheap_alloc()</a>, <a class="el" href="include_2nucleus_2thread_8h-source.html#l00111">XNRMID</a>, <a class="el" href="synch_8c-source.html#l00168">xnsynch_sleep_on()</a>, and <a class="el" href="include_2nucleus_2thread_8h-source.html#l00110">XNTIMEO</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge17a8784a83d2eec94089a86a831a833"></a><!-- doxytag: member="heap.c::rt_heap_bind" ref="ge17a8784a83d2eec94089a86a831a833" args="(RT_HEAP *heap, const char *name, RTIME timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_heap_bind           </td>
          <td>(</td>
          <td class="paramtype">RT_HEAP *&nbsp;</td>
          <td class="paramname"> <em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bind to a mappable heap. 
<p>
This user-space only service retrieves the uniform descriptor of a given mappable Xenomai heap identified by its symbolic name. If the heap does not exist on entry, this service blocks the caller until a heap of the given name is created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>A valid NULL-terminated name which identifies the heap to bind to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>The address of a heap descriptor retrieved by the operation. Contents of this memory is undefined upon failure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of clock ticks to wait for the registration to occur (see note). Passing TM_INFINITE causes the caller to block indefinitely until the object is registered. Passing TM_NONBLOCK causes the service to return immediately without waiting if the object is not registered on entry.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EFAULT is returned if <em>heap</em> or <em>name</em> is referencing invalid memory.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__task.html#g770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task.">rt_task_unblock()</a> has been called for the waiting task before the retrieval has completed.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the searched object is not registered on entry.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if the object cannot be retrieved within the specified amount of time.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service should block, but was called from a context which cannot sleep (e.g. interrupt, non-realtime or scheduler locked).</li></ul>
<p>
<ul>
<li>-ENOENT is returned if the special file /dev/rtheap (character-mode, major 10, minor 254) is not available from the filesystem. This device is needed to map the shared heap memory into the caller's address space. udev-based systems should not need manual creation of such device entry. Environments:</li></ul>
<p>
This service can be called from:<p>
<ul>
<li>User-space task (switches to primary mode)</li></ul>
<p>
Rescheduling: always unless the request is immediately satisfied or <em>timeout</em> specifies a non-blocking operation.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the native skin is bound to a periodic time base (see CONFIG_XENO_OPT_NATIVE_PERIOD), or nanoseconds otherwise. </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="shared__mem_8c-example.html#a0">shared_mem.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="g1d19ad24dc9f94b969aa0f574170bdc4"></a><!-- doxytag: member="heap.c::rt_heap_create" ref="g1d19ad24dc9f94b969aa0f574170bdc4" args="(RT_HEAP *heap, const char *name, size_t heapsize, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_heap_create           </td>
          <td>(</td>
          <td class="paramtype">RT_HEAP *&nbsp;</td>
          <td class="paramname"> <em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>heapsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a memory heap or a shared memory segment. 
<p>
Initializes a memory heap suitable for time-bounded allocation requests of dynamic memory. Memory heaps can be local to the kernel address space, or mapped to user-space.<p>
In their simplest form, heaps are only accessible from kernel space, and are merely usable as regular memory allocators.<p>
Heaps existing in kernel space can be mapped by user-space processes to their own address space provided H_MAPPABLE has been passed into the <em>mode</em> parameter.<p>
By default, heaps support allocation of multiple blocks of memory in an arbitrary order. However, it is possible to ask for single-block management by passing the H_SINGLE flag into the <em>mode</em> parameter, in which case the entire memory space managed by the heap is made available as a unique block. In this mode, all allocation requests made through <a class="el" href="group__native__heap.html#g52678149ff2b66e47aa8cdcddab653a4" title="Allocate a block or return the single segment base.">rt_heap_alloc()</a> will then return the same block address, pointing at the beginning of the heap memory.<p>
H_SHARED is a shorthand for creating shared memory segments transparently accessible from kernel and user-space contexts, which are basically single-block, mappable heaps. By proper use of a common <em>name</em>, all tasks can bind themselves to the same heap and thus share the same memory space, which start address should be subsequently retrieved by a call to <a class="el" href="group__native__heap.html#g52678149ff2b66e47aa8cdcddab653a4" title="Allocate a block or return the single segment base.">rt_heap_alloc()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>The address of a heap descriptor Xenomai will use to store the heap-related data. This descriptor must always be valid while the heap is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the heap. When non-NULL and non-empty, this string is copied to a safe place into the descriptor, and passed to the registry package if enabled for indexing the created heap. Mappable heaps must be given a valid name.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>heapsize</em>&nbsp;</td><td>The size (in bytes) of the block pool which is going to be pre-allocated to the heap. Memory blocks will be claimed and released to this pool. The block pool is not extensible, so this value must be compatible with the highest memory pressure that could be expected. A minimum of 2 * PAGE_SIZE will be enforced for mappable heaps, 2 * XNCORE_PAGE_SIZE otherwise.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The heap creation mode. The following flags can be OR'ed into this bitmask, each of them affecting the new heap:</td></tr>
  </table>
</dl>
<ul>
<li>H_FIFO makes tasks pend in FIFO order on the heap when waiting for available blocks.</li></ul>
<p>
<ul>
<li>H_PRIO makes tasks pend in priority order on the heap when waiting for available blocks.</li></ul>
<p>
<ul>
<li>H_MAPPABLE causes the heap to be sharable between kernel and user-space contexts. Otherwise, the new heap is only available for kernel-based usage. This flag is implicitely set when the caller is running in user-space. This feature requires the real-time support in user-space to be configured in (CONFIG_XENO_OPT_PERVASIVE).</li></ul>
<p>
<ul>
<li>H_SINGLE causes the entire heap space to be managed as a single memory block.</li></ul>
<p>
<ul>
<li>H_SHARED is a shorthand for H_MAPPABLE|H_SINGLE, creating a global shared memory segment accessible from both the kernel and user-space contexts.</li></ul>
<p>
<ul>
<li>H_DMA causes the block pool associated to the heap to be allocated in physically contiguous memory, suitable for DMA operations with I/O devices. <em>heapsize</em> beyond 128KiB will be rounded up to a two expononent allocation.</li></ul>
<p>
<ul>
<li>H_NONCACHED causes the heap not to be cached. This is necessary on platforms such as ARM to share a heap between kernel and user-space. Note that this flag is not compatible with the H_DMA flag.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EEXIST is returned if the <em>name</em> is already in use by some registered object.</li></ul>
<p>
<ul>
<li>-EINVAL is returned if <em>heapsize</em> is null, greater than the system limit, or <em>name</em> is null or empty for a mappable heap.</li></ul>
<p>
<ul>
<li>-ENOMEM is returned if not enough system memory is available to create or register the heap. Additionally, and if H_MAPPABLE has been passed in <em>mode</em>, errors while mapping the block pool in the caller's address space might beget this return code too.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from an invalid context.</li></ul>
<p>
<ul>
<li>-ENOSYS is returned if <em>mode</em> specifies H_MAPPABLE, but the real-time support in user-space is unavailable.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>User-space task (switches to secondary mode)</li></ul>
<p>
Rescheduling: possible. 
<p>References <a class="el" href="src_2skins_2native_2heap_8c-source.html#l00113">rt_heap_delete()</a>, <a class="el" href="ksrc_2nucleus_2heap_8c-source.html#l00167">xnheap_init()</a>, <a class="el" href="nucleus_2registry_8c-source.html#l00582">xnregistry_enter()</a>, and <a class="el" href="synch_8c-source.html#l00087">xnsynch_init()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g08f8d244a545fd6a5719ad5708552552"></a><!-- doxytag: member="heap.c::rt_heap_delete" ref="g08f8d244a545fd6a5719ad5708552552" args="(RT_HEAP *heap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_heap_delete           </td>
          <td>(</td>
          <td class="paramtype">RT_HEAP *&nbsp;</td>
          <td class="paramname"> <em>heap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a real-time heap. 
<p>
Destroy a heap and release all the tasks currently pending on it. A heap exists in the system since <a class="el" href="group__native__heap.html#g1d19ad24dc9f94b969aa0f574170bdc4" title="Create a memory heap or a shared memory segment.">rt_heap_create()</a> has been called to create it, so this service must be called in order to destroy it afterwards.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>The descriptor address of the affected heap.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EBUSY is returned if <em>heap</em> is in use by another process and the descriptor is not destroyed.</li></ul>
<p>
<ul>
<li>-EINVAL is returned if <em>heap</em> is not a heap descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>heap</em> is a deleted heap descriptor.</li></ul>
<p>
<ul>
<li>-EPERM is returned if this service was called from an invalid context.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>User-space task (switches to secondary mode).</li></ul>
<p>
Rescheduling: possible. 
<p>Referenced by <a class="el" href="ksrc_2skins_2native_2heap_8c-source.html#l00241">rt_heap_create()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g300ca8c868d02dad99790fe39b443f6f"></a><!-- doxytag: member="heap.c::rt_heap_free" ref="g300ca8c868d02dad99790fe39b443f6f" args="(RT_HEAP *heap, void *block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_heap_free           </td>
          <td>(</td>
          <td class="paramtype">RT_HEAP *&nbsp;</td>
          <td class="paramname"> <em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free a block. 
<p>
This service releases a block to the heap's internal pool. If some task is currently waiting for a block so that it's pending request could be satisfied as a result of the release, it is immediately resumed.<p>
If the heap is defined as a single-block area (i.e. H_SINGLE mode), this service leads to a null-effect and always returns successfully.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>The address of the heap descriptor to which the block <em>block</em> belong.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>The address of the block to free.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success, or -EINVAL if <em>block</em> is not a valid block previously allocated by the <a class="el" href="group__native__heap.html#g52678149ff2b66e47aa8cdcddab653a4" title="Allocate a block or return the single segment base.">rt_heap_alloc()</a> service.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible. 
<p>References <a class="el" href="ksrc_2nucleus_2heap_8c-source.html#l00429">xnheap_alloc()</a>, <a class="el" href="ksrc_2nucleus_2heap_8c-source.html#l00788">xnheap_free()</a>, <a class="el" href="pod_8c-source.html#l02373">xnpod_schedule()</a>, and <a class="el" href="synch_8c-source.html#l00491">xnsynch_wakeup_this_sleeper()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g6af669528e1bcae4f1ed15b292bda08e"></a><!-- doxytag: member="heap.c::rt_heap_inquire" ref="g6af669528e1bcae4f1ed15b292bda08e" args="(RT_HEAP *heap, RT_HEAP_INFO *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_heap_inquire           </td>
          <td>(</td>
          <td class="paramtype">RT_HEAP *&nbsp;</td>
          <td class="paramname"> <em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrt__heap__info.html">RT_HEAP_INFO</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inquire about a heap. 
<p>
Return various information about the status of a given heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>The descriptor address of the inquired heap.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>The address of a structure the heap information will be written to.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned and status information is written to the structure pointed at by <em>info</em> upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>heap</em> is not a message queue descriptor.</li></ul>
<p>
<ul>
<li>-EIDRM is returned if <em>heap</em> is a deleted queue descriptor.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
<p>References <a class="el" href="native_2heap_8h-source.html#l00048">rt_heap_info::heapsize</a>, <a class="el" href="native_2heap_8h-source.html#l00046">rt_heap_info::mode</a>, <a class="el" href="native_2heap_8h-source.html#l00054">rt_heap_info::name</a>, <a class="el" href="native_2heap_8h-source.html#l00044">rt_heap_info::nwaiters</a>, <a class="el" href="native_2heap_8h-source.html#l00050">rt_heap_info::usablemem</a>, and <a class="el" href="native_2heap_8h-source.html#l00052">rt_heap_info::usedmem</a>.</p>

</div>
</div><p>
<a class="anchor" name="gea086656fe119a563e8c0b6d44f83c8e"></a><!-- doxytag: member="heap.c::rt_heap_unbind" ref="gea086656fe119a563e8c0b6d44f83c8e" args="(RT_HEAP *heap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_heap_unbind           </td>
          <td>(</td>
          <td class="paramtype">RT_HEAP *&nbsp;</td>
          <td class="paramname"> <em>heap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unbind from a mappable heap. 
<p>
This user-space only service unbinds the calling task from the heap object previously retrieved by a call to <a class="el" href="group__native__heap.html#ge17a8784a83d2eec94089a86a831a833" title="Bind to a mappable heap.">rt_heap_bind()</a>.<p>
Unbinding from a heap when it is no longer needed is especially important in order to properly release the mapping resources used to attach the heap memory to the caller's address space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>The address of a heap descriptor to unbind from.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is always returned.</dd></dl>
This service can be called from:<p>
<ul>
<li>User-space task.</li></ul>
<p>
Rescheduling: never. <dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="shared__mem_8c-example.html#a2">shared_mem.c</a>.</dl>
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Nov 8 19:15:28 2008 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
