diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/.gitignore ipipe-2.6.14-imx21/.gitignore
--- linux-2.6.14/.gitignore	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/.gitignore	2008-02-21 22:08:59.000000000 +0100
@@ -10,11 +10,17 @@
 *.a
 *.s
 *.ko
+*.so
 *.mod.c
+*.i
+*.lst
+*.symtypes
 
 #
 # Top-level generic files
 #
+tags
+TAGS
 vmlinux*
 System.map
 Module.symvers
@@ -23,8 +29,19 @@ Module.symvers
 # Generated include files
 #
 include/asm
+include/asm-*/asm-offsets.h
 include/config
 include/linux/autoconf.h
 include/linux/compile.h
 include/linux/version.h
+include/linux/utsrelease.h
 
+# stgit generated dirs
+patches-*
+
+# quilt's files
+patches
+series
+
+# cscope files
+cscope.*
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/Makefile ipipe-2.6.14-imx21/Makefile
--- linux-2.6.14/Makefile	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/Makefile	2008-02-21 22:08:59.000000000 +0100
@@ -189,8 +189,8 @@ SUBARCH := $(shell uname -m | sed -e s/i
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
+ARCH		?= arm
+CROSS_COMPILE	?= arm-linux-
 
 # Architecture as present in compile.h
 UTS_MACHINE := $(ARCH)
@@ -517,6 +517,10 @@ CFLAGS		+= $(call add-align,CONFIG_CC_AL
 CFLAGS		+= $(call add-align,CONFIG_CC_ALIGN_LOOPS,-loops)
 CFLAGS		+= $(call add-align,CONFIG_CC_ALIGN_JUMPS,-jumps)
 
+ifdef CONFIG_IPIPE_TRACE_MCOUNT
+CFLAGS          += -pg
+endif
+
 ifdef CONFIG_FRAME_POINTER
 CFLAGS		+= -fno-omit-frame-pointer $(call cc-option,-fno-optimize-sibling-calls,)
 else
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/Kconfig ipipe-2.6.14-imx21/arch/arm/Kconfig
--- linux-2.6.14/arch/arm/Kconfig	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/Kconfig	2008-02-21 22:08:59.000000000 +0100
@@ -2,6 +2,11 @@
 # For a description of the syntax of this configuration file,
 # see Documentation/kbuild/kconfig-language.txt.
 #
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
 
 mainmenu "Linux Kernel Configuration"
 
@@ -197,6 +202,9 @@ config ARCH_VERSATILE
 config ARCH_IMX
 	bool "IMX"
 
+config FAMILY_IMX21
+	bool "IMX21"
+
 config ARCH_H720X
 	bool "Hynix-HMS720x-based"
 	help
@@ -237,6 +245,8 @@ source "arch/arm/mach-lh7a40x/Kconfig"
 
 source "arch/arm/mach-imx/Kconfig"
 
+source "arch/arm/mach-imx21/Kconfig"
+
 source "arch/arm/mach-h720x/Kconfig"
 
 source "arch/arm/mach-versatile/Kconfig"
@@ -339,6 +349,8 @@ config NR_CPUS
 	depends on SMP
 	default "4"
 
+source "kernel/ipipe/Kconfig"
+
 config PREEMPT
 	bool "Preemptible Kernel (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/Makefile ipipe-2.6.14-imx21/arch/arm/Makefile
--- linux-2.6.14/arch/arm/Makefile	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/Makefile	2008-02-21 22:08:59.000000000 +0100
@@ -5,6 +5,11 @@
 # License.  See the file "COPYING" in the main directory of this archive
 # for more details.
 #
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
 # Copyright (C) 1995-2001 by Russell King
 
 LDFLAGS_vmlinux	:=-p --no-undefined -X
@@ -97,6 +102,7 @@ textaddr-$(CONFIG_ARCH_FORTUNET)   := 0x
  machine-$(CONFIG_ARCH_LH7A40X)	   := lh7a40x
  machine-$(CONFIG_ARCH_VERSATILE)  := versatile
  machine-$(CONFIG_ARCH_IMX)	   := imx
+ machine-$(CONFIG_ARCH_IMX21)	   := imx21
  machine-$(CONFIG_ARCH_H720X)	   := h720x
  machine-$(CONFIG_ARCH_AAEC2000)   := aaec2000
 
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/boot/compressed/Makefile ipipe-2.6.14-imx21/arch/arm/boot/compressed/Makefile
--- linux-2.6.14/arch/arm/boot/compressed/Makefile	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/boot/compressed/Makefile	2008-02-21 22:08:59.000000000 +0100
@@ -3,6 +3,12 @@
 #
 # create a compressed vmlinuz image from the original vmlinux
 #
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
+#
 
 HEAD	= head.o
 OBJS	= misc.o
@@ -50,6 +56,19 @@ ifeq ($(CONFIG_PXA_SHARPSL),y)
 OBJS		+= head-sharpsl.o
 endif
 
+ifeq ($(CONFIG_ARCH_AT91RM9200),y)
+OBJS		+= head-at91rm9200.o
+endif
+
+ifeq ($(CONFIG_MACH_CSB536),y)
+OBJS		+= head-csb536.o
+endif
+
+# Support for Cogent csb535 board
+ifeq ($(CONFIG_MACH_CSB535),y)
+OBJS		+= head-csb535.o
+endif
+
 ifeq ($(CONFIG_DEBUG_ICEDCC),y)
 OBJS            += ice-dcc.o
 endif
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/boot/compressed/head-csb535.S ipipe-2.6.14-imx21/arch/arm/boot/compressed/head-csb535.S
--- linux-2.6.14/arch/arm/boot/compressed/head-csb535.S	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/arch/arm/boot/compressed/head-csb535.S	2008-02-21 22:08:59.000000000 +0100
@@ -0,0 +1,31 @@
+/* 
+ * linux/arch/arm/boot/compressed/head-csb535.S
+ * 
+ * Copyright (C) 2005 Jay Monkman <jtm@lopingdog.com>
+ * 
+ * Some code borrowed from Nicolas Pitre's 'head-sa1100.S' file. This
+ * is merged with head.S by the linker.
+ */
+
+#include <linux/config.h>
+#include <asm/mach-types.h>
+
+#ifndef CONFIG_MACH_CSB535
+#error What am I doing here...
+#endif
+
+	.section        ".start", "ax"
+
+__CSB535_start:
+	b	4f
+1:	.word	MACH_TYPE_CSB535  /* Machine type */
+2:	.word   0x10027000        /* PLL regs phys addr */
+3:	.word   0x2e000000        /* Value for PCCR1 - enable GPT clocks */
+
+4:
+	ldr	r1, 2b
+	ldr	r2, 3b
+	str	r2, [r1, #36]    /* Write to PCCR1 */
+
+	ldr	r7, 1b           /* Set machine type */
+
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/boot/compressed/head.S ipipe-2.6.14-imx21/arch/arm/boot/compressed/head.S
--- linux-2.6.14/arch/arm/boot/compressed/head.S	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/boot/compressed/head.S	2008-02-21 22:08:59.000000000 +0100
@@ -6,6 +6,12 @@
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
+ *
+ * March 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ *
  */
 #include <linux/config.h>
 #include <linux/linkage.h>
@@ -92,9 +98,9 @@
 		kputc	#'\n'
 		kphex	r5, 8		/* decompressed kernel start */
 		kputc	#'-'
-		kphex	r8, 8		/* decompressed kernel end  */
-		kputc	#'>'
-		kphex	r4, 8		/* kernel execution address */
+
+		kphex	r9, 8		/* decompressed kernel end  */
+		
 		kputc	#'\n'
 #endif
 		.endm
@@ -124,7 +130,11 @@ start:
 		.word	start			@ absolute load/run zImage address
 		.word	_edata			@ zImage end address
 1:		mov	r7, r1			@ save architecture ID
-		mov	r8, #0			@ save r0
+
+		mov	r8, r2			@ save atags pointer
+#if defined (CONFIG_UMON_SHIM)
+		mov	r10, r0			@ save the uMON command line
+#endif
 
 #ifndef __ARM_ARCH_2__
 		/*
@@ -152,11 +162,92 @@ not_angel:
 
 		/*
 		 * some architecture specific code can be inserted
-		 * by the linker here, but it should preserve r7 and r8.
+                 * by the linker here, but it should preserve r7,r8 and r9.
 		 */
 
 		.text
-		adr	r0, LC0
+
+#if defined(CONFIG_UMON_SHIM)
+
+                /* this "shim" builds an ATAG list in a safe memory */
+		/* area from the uMON command line */
+                /* uMON's call (no -a) command points r0
+		/* to the text of the command line */
+		/* TODO: newer uMON's have a "linux call" cmd */
+
+#if defined(CONFIG_MACH_CSB535)
+#warning TODO:	 get rid of this magic number
+		ldr	r2, =0xc0000000	/* put the tags at the bottom of SDRAM */
+#else
+#error	uMON shim is not implemented for this machine.
+#endif
+		mov	r8, r2		/* save the correct atags pointer */
+	
+		ldr	r1, =5
+		stmia	r2!, {r1}
+		ldr	r1, =0x54410001	/* ATAG_CORE */
+		stmia	r2!, {r1}
+
+		ldr	r1, =0		/* flags */
+		stmia	r2!, {r1}
+		ldr	r1, =4096	/* pagesize */
+		stmia	r2!, {r1}
+		ldr	r1, =0		/* rootdev (usually overridden on cmdline) */
+		stmia	r2!, {r1}
+	
+		ldr	r1, =4
+		stmia	r2!, {r1}
+		ldr	r1, =0x54410002	/* ATAG_MEM */
+		stmia	r2!, {r1}
+
+#if defined(CONFIG_MACH_CSB535)
+#warning TODO: get rid of these magic numbers
+		ldr	r1, =0x2000000	/* size */
+		ldr	r3, =0xc000000	/* start */
+#endif
+
+		stmia	r2!, {r1}
+		stmia	r2!, {r3}
+
+		/* save some room for cmdline length */
+		mov	r4, r2
+		add	r2, r2, #4
+	
+		ldr	r1, =0x54410009	/* ATAG_CMDLINE */
+		stmia	r2!, {r1}
+
+		/* copy over the command line */
+		/* (if one wasn't provided, we'll likely crash here) */
+
+1:		ldmia	r10!, {r1}
+		stmia	r2!, {r1}
+		
+		/* look for the null terminator */
+		ands	r5, r1, #0x000000ff
+		beq	1f	
+		ands	r5, r1, #0x0000ff00
+		beq	1f	
+		ands	r5, r1, #0x00ff0000
+		beq	1f	
+		ands	r5, r1, #0xff000000
+		beq	1f
+
+		b	1b
+	
+		/* put the word count into the ATAG_CMDLINE */
+1:		sub	r5, r2, r4
+		mov	r5, r5, lsr #2
+		stmia	r4, {r5}
+
+		/* terminate */
+		ldr	r1, =0 /* ATAG_NONE */
+		stmia	r2!, {r1}
+		stmia	r2!, {r1}
+
+#endif /* CONFIG_UMON_SHIM */
+
+9:		adr	r0, LC0
+
 		ldmia	r0, {r1, r2, r3, r4, r5, r6, ip, sp}
 		subs	r0, r0, r1		@ calculate the delta offset
 
@@ -257,16 +348,19 @@ not_relocated:	mov	r0, #0
  * r5     = decompressed kernel start
  * r6     = processor ID
  * r7     = architecture ID
- * r8-r14 = unused
+ * r8     = atags pointer
+ * r9-r14 = corrupted
  */
 		add	r1, r5, r0		@ end of decompressed kernel
 		adr	r2, reloc_start
 		ldr	r3, LC1
 		add	r3, r2, r3
-1:		ldmia	r2!, {r8 - r13}		@ copy relocation code
-		stmia	r1!, {r8 - r13}
-		ldmia	r2!, {r8 - r13}
-		stmia	r1!, {r8 - r13}
+
+1:		ldmia	r2!, {r9 - r14}		@ copy relocation code
+		stmia	r1!, {r9 - r14}
+		ldmia	r2!, {r9 - r14}
+		stmia	r1!, {r9 - r14}
+
 		cmp	r2, r3
 		blo	1b
 
@@ -318,9 +412,9 @@ params:		ldr	r0, =params_phys
  *  r7 = architecture number
  *  r8 = run-time address of "start"
  * On exit,
- *  r1, r2, r3, r8, r9, r12 corrupted
+ *  r1, r2, r3, r9, r10, r12 corrupted
  * This routine must preserve:
- *  r4, r5, r6, r7
+ *  r4, r5, r6, r7, r8
  */
 		.align	5
 cache_on:	mov	r3, #8			@ cache_on function
@@ -333,16 +427,30 @@ __setup_mmu:	sub	r3, r4, #16384		@ Page 
  * Initialise the page tables, turning on the cacheable and bufferable
  * bits for the RAM area only.
  */
+
 		mov	r0, r3
-		mov	r8, r0, lsr #18
-		mov	r8, r8, lsl #18		@ start of RAM
-		add	r9, r8, #0x10000000	@ a reasonable RAM size
+		mov	r9, r0, lsr #18
+		mov	r9, r9, lsl #18		@ start of RAM
+#if !defined(CONFIG_ARCH_IMX)
+ 		add	r10, r9, #0x10000000	@ a reasonable RAM size
+#else
+		add	r10, r9, #0x08000000	@ Max for imx is 128MB
+#endif
+
+/*
+*Fin modification
+*/
+		
 		mov	r1, #0x12
 		orr	r1, r1, #3 << 10
 		add	r2, r3, #16384
-1:		cmp	r1, r8			@ if virt > start of RAM
+
+1:		cmp	r1, r9			@ if virt > start of RAM
+	
 		orrhs	r1, r1, #0x0c		@ set cacheable, bufferable
-		cmp	r1, r9			@ if virt > end of RAM
+
+		cmp	r1, r10			@ if virt > end of RAM
+
 		bichs	r1, r1, #0x0c		@ clear cacheable, bufferable
 		str	r1, [r0], #4		@ 1:1 mapping
 		add	r1, r1, #1048576
@@ -411,19 +519,25 @@ __common_cache_on:
  * r5     = decompressed kernel start
  * r6     = processor ID
  * r7     = architecture ID
- * r8-r14 = unused
+ * r8     = atags pointer
+ * r9-r14 = corrupted
  */
 		.align	5
-reloc_start:	add	r8, r5, r0
+
+reloc_start:	add	r9, r5, r0
+
 		debug_reloc_start
 		mov	r1, r4
 1:
 		.rept	4
-		ldmia	r5!, {r0, r2, r3, r9 - r13}	@ relocate kernel
-		stmia	r1!, {r0, r2, r3, r9 - r13}
+		
+		ldmia	r5!, {r0, r2, r3, r10 - r14}	@ relocate kernel
+		stmia	r1!, {r0, r2, r3, r10 - r14}
+		
 		.endr
 
-		cmp	r5, r8
+		cmp	r5, r9
+
 		blo	1b
 		debug_reloc_end
 
@@ -431,6 +545,9 @@ call_kernel:	bl	cache_clean_flush
 		bl	cache_off
 		mov	r0, #0
 		mov	r1, r7			@ restore architecture number
+
+		mov	r2, r8			@ restore atags pointer
+
 		mov	pc, r4			@ call kernel
 
 /*
@@ -718,6 +835,16 @@ memdump:	mov	r12, r0
 		mov	pc, r10
 #endif
 
+#ifdef CONFIG_IPIPE_TRACE_MCOUNT
+                .text
+                .align 0
+                .type mcount %function
+                .global mcount
+mcount:
+		mov pc, lr	@ just return
+#endif
+
+
 reloc_end:
 
 		.align
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/boot/compressed/misc.c ipipe-2.6.14-imx21/arch/arm/boot/compressed/misc.c
--- linux-2.6.14/arch/arm/boot/compressed/misc.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/boot/compressed/misc.c	2008-02-21 22:08:59.000000000 +0100
@@ -14,7 +14,13 @@
  *  only.  This way all non constant variables will end up in the bss segment,
  *  which should point to addresses in RAM and cleared to 0 on start.
  *  This allows for a much quicker boot time.
- */
+ *
+ * March 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ *
+*/
 
 unsigned int __machine_arch_type;
 
@@ -292,6 +298,58 @@ static void error(char *x)
 	while(1);	/* Halt */
 }
 
+#ifdef CONFIG_ARCH_IMX21
+#include <asm/setup.h>
+
+static struct tag *params; /* used to point at the current tag */
+
+static void
+setup_core_tag(void * address,long pagesize)
+{
+    params = (struct tag *)address;         /* Initialise parameters to start at given address */
+
+    params->hdr.tag = ATAG_CORE;            /* start with the core tag */
+    params->hdr.size = tag_size(tag_core); /* size the tag */
+
+    params->u.core.flags = 1;               /* ensure read-only */
+    params->u.core.pagesize = pagesize;     /* systems pagesize (4k) */
+    params->u.core.rootdev = 0;             /* zero root device (typicaly overidden from commandline )*/
+
+    params = tag_next(params);              /* move pointer to next tag */
+}
+
+static void
+setup_mem_tag(unsigned int start, unsigned int len)
+{
+    params->hdr.tag = ATAG_MEM;             /* Memory tag */
+    params->hdr.size = tag_size(tag_mem32);  /* size tag */
+
+    params->u.mem.start = start;            /* Start of memory area (physical address) */
+    params->u.mem.size = len;               /* Length of area */
+
+    params = tag_next(params);              /* move pointer to next tag */
+}
+
+static void
+setup_end_tag(void)
+{
+    params->hdr.tag = ATAG_NONE;            /* Empty tag ends list */
+    params->hdr.size = 0;                   /* zero length */
+}
+
+
+static void
+setup_tags(void)
+{
+    putstr("Creating MX21 tags...");
+    setup_core_tag((int *)0xc0000100, 4096);  /* standard core tag 4k pagesize */
+    setup_mem_tag(0xc0000000, 0x4000000);     /* 64MB @0xc0000000 */
+    setup_end_tag();                          /* end of tags */
+    putstr("Done.\n");
+}
+
+#endif /* CONFIG_ARCH_IMX21 */
+
 #ifndef STANDALONE_DEBUG
 
 ulg
@@ -305,10 +363,22 @@ decompress_kernel(ulg output_start, ulg 
 
 	arch_decomp_setup();
 
+	putstr("ArchID=");
+	puthex(arch_id);
+	putstr("\n");
+	putstr("output_data: ");
+	puthex((int)output_data);
+	putstr("\n");
+
 	makecrc();
 	putstr("Uncompressing Linux...");
 	gunzip();
-	putstr(" done, booting the kernel.\n");
+	putstr(" done vu Guillaume, booting the kernel.\n");
+
+#if defined(CONFIG_ARCH_IMX21) && !defined(CONFIG_MACH_CSB535)
+	setup_tags();
+#endif /* CONFIG_ARCH_IMX21 */
+	
 	return output_ptr;
 }
 #else
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/kernel/Makefile ipipe-2.6.14-imx21/arch/arm/kernel/Makefile
--- linux-2.6.14/arch/arm/kernel/Makefile	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/kernel/Makefile	2008-02-21 22:08:59.000000000 +0100
@@ -19,6 +19,8 @@ obj-$(CONFIG_ARTHUR)		+= arthur.o
 obj-$(CONFIG_ISA_DMA)		+= dma-isa.o
 obj-$(CONFIG_PCI)		+= bios32.o
 obj-$(CONFIG_SMP)		+= smp.o
+obj-$(CONFIG_IPIPE)		+= ipipe-core.o ipipe-root.o
+obj-$(CONFIG_IPIPE_TRACE_MCOUNT)	+= ipipe-mcount.o
 
 obj-$(CONFIG_IWMMXT)		+= iwmmxt.o
 AFLAGS_iwmmxt.o			:= -Wa,-mcpu=iwmmxt
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/kernel/entry-armv.S ipipe-2.6.14-imx21/arch/arm/kernel/entry-armv.S
--- linux-2.6.14/arch/arm/kernel/entry-armv.S	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/kernel/entry-armv.S	2008-02-21 22:08:59.000000000 +0100
@@ -3,6 +3,7 @@
  *
  *  Copyright (C) 1996,1997,1998 Russell King.
  *  ARM700 fix by Matthew Godbolt (linux-user@willothewisp.demon.co.uk)
+ *  Copyright (C) 2005 Stelian Pop.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -27,13 +28,21 @@
  * Interrupt handling.  Preserves r7, r8, r9
  */
 	.macro	irq_handler
-1:	get_irqnr_and_base r0, r6, r5, lr
+#ifdef CONFIG_IPIPE
+	mov	r0, #2
+#endif
+1:	get_irqnr_and_base r1, r6, r5, lr
+	movne	r0, r1
 	movne	r1, sp
 	@
 	@ routine called with r0 = irq number, r1 = struct pt_regs *
 	@
 	adrne	lr, 1b
+#ifdef CONFIG_IPIPE
+	bne	__ipipe_grab_irq
+#else
 	bne	asm_do_IRQ
+#endif
 
 #ifdef CONFIG_SMP
 	/*
@@ -42,11 +51,15 @@
 	 * this macro assumes that irqstat (r6) and base (r5) are
 	 * preserved from get_irqnr_and_base above
 	 */
-	test_for_ipi r0, r6, r5, lr
+	test_for_ipi r1, r6, r5, lr
 	movne	r0, sp
 	adrne	lr, 1b
 	bne	do_IPI
 #endif
+#ifdef CONFIG_IPIPE
+	cmp	r0, #2
+	bleq	__ipipe_check_root_interruptible
+#endif	
 
 	.endm
 
@@ -176,14 +189,25 @@ __irq_svc:
 
 #ifdef CONFIG_PREEMPT
 	get_thread_info tsk
+#ifndef CONFIG_IPIPE
 	ldr	r8, [tsk, #TI_PREEMPT]		@ get preempt count
 	add	r7, r8, #1			@ increment it
 	str	r7, [tsk, #TI_PREEMPT]
 #endif
+#endif
 
 	irq_handler
+#ifdef CONFIG_IPIPE
+	cmp	r0, #0
+	beq	__ipipe_fast_svc_irq_exit
+#endif
+
 #ifdef CONFIG_PREEMPT
 	ldr	r0, [tsk, #TI_FLAGS]		@ get flags
+#ifdef CONFIG_IPIPE
+	ldr	r8, [tsk, #TI_PREEMPT]		@ get preempt count
+	mov     r7, r8
+#endif	
 	tst	r0, #_TIF_NEED_RESCHED
 	blne	svc_preempt
 preempt_return:
@@ -192,6 +216,9 @@ preempt_return:
 	teq	r0, r7
 	strne	r0, [r0, -r0]			@ bug()
 #endif
+#ifdef CONFIG_IPIPE
+__ipipe_fast_svc_irq_exit:
+#endif
 	ldr	r0, [sp, #S_PSR]		@ irqs are already disabled
 	msr	spsr_cxsf, r0
 	ldmia	sp, {r0 - pc}^			@ load r0 - pc, cpsr
@@ -207,19 +234,33 @@ svc_preempt:
 	ldr	r1, [r6, #8]			@ local_bh_count
 	adds	r0, r0, r1
 	movne	pc, lr
+#ifdef CONFIG_IPIPE
+	bl	__ipipe_fast_stall_root
+	enable_irq
+#endif
 	mov	r7, #0				@ preempt_schedule_irq
 	str	r7, [tsk, #TI_PREEMPT]		@ expects preempt_count == 0
 1:	bl	preempt_schedule_irq		@ irq en/disable is done inside
 	ldr	r0, [tsk, #TI_FLAGS]		@ get new tasks TI_FLAGS
 	tst	r0, #_TIF_NEED_RESCHED
-	beq	preempt_return			@ go again
-	b	1b
+	bne	1b
+#ifdef CONFIG_IPIPE
+	disable_irq
+	bl	__ipipe_fast_unstall_root
+#endif
+	b	preempt_return			@ go again
 #endif
 
 	.align	5
 __und_svc:
 	svc_entry
 
+#ifdef CONFIG_IPIPE
+	mov	r1, sp				@ r0 = trapno, r1 = &regs
+	bl	__ipipe_dispatch_event		@ branch to trap handler
+	cmp	r0, #0
+	bne	1f
+#endif /* CONFIG_IPIPE */
 	@
 	@ call emulation code, which returns using r9 if it has emulated
 	@ the instruction, or the more conventional lr if we are to treat
@@ -372,18 +413,28 @@ __irq_usr:
 
 	get_thread_info tsk
 #ifdef CONFIG_PREEMPT
+#ifndef CONFIG_IPIPE
 	ldr	r8, [tsk, #TI_PREEMPT]		@ get preempt count
 	add	r7, r8, #1			@ increment it
 	str	r7, [tsk, #TI_PREEMPT]
 #endif
+#endif
 
 	irq_handler
+#ifdef CONFIG_IPIPE
+	cmp	r0, #0
+	bne	__ipipe_usr_irq_continue
+	slow_restore_user_regs			@ Fast exit path over non-root domains
+__ipipe_usr_irq_continue:
+#endif
 #ifdef CONFIG_PREEMPT
+#ifndef CONFIG_IPIPE
 	ldr	r0, [tsk, #TI_PREEMPT]
 	str	r8, [tsk, #TI_PREEMPT]
 	teq	r0, r7
 	strne	r0, [r0, -r0]
 #endif
+#endif
 
 	mov	why, #0
 	b	ret_to_user
@@ -471,8 +522,8 @@ call_fpe:
 	mov	pc, lr				@ CP#8
 	mov	pc, lr				@ CP#9
 #ifdef CONFIG_VFP
-	b	do_vfp				@ CP#10 (VFP)
-	b	do_vfp				@ CP#11 (VFP)
+	b	_do_vfp				@ CP#10 (VFP)
+	b	_do_vfp				@ CP#11 (VFP)
 #else
 	mov	pc, lr				@ CP#10 (VFP)
 	mov	pc, lr				@ CP#11 (VFP)
@@ -483,10 +534,34 @@ call_fpe:
 	mov	pc, lr				@ CP#15 (Control)
 
 do_fpe:
+#ifdef CONFIG_IPIPE
+	mov	r4, r0
+	mov	r0, #5				@ == IPIPE_TRAP_FPU
+	mov	r1, sp				@ r0 = trapno, r1 = &regs
+	bl	__ipipe_dispatch_event		@ branch to trap handler
+	cmp	r0, #0
+	ldrne	pc, [r9]
+	mov	r0, r4
+#endif
 	ldr	r4, .LCfp
 	add	r10, r10, #TI_FPSTATE		@ r10 = workspace
 	ldr	pc, [r4]			@ Call FP module USR entry point
 
+#ifdef CONFIG_VFP
+_do_vfp:
+#ifdef CONFIG_IPIPE
+	mov	r4, r0
+	mov	r0, #6				@ == IPIPE_TRAP_VFP
+	mov	r1, sp				@ r0 = trapno, r1 = &regs
+	bl	__ipipe_dispatch_event		@ branch to trap handler
+	cmp	r0, #0
+	ldrne	pc, [r9]
+	mov	r0, r4
+#endif
+	b	do_vfp
+#endif
+
+
 /*
  * The FP module is called with these registers set:
  *  r0  = instruction
@@ -519,6 +594,13 @@ __pabt_usr:
  * This is the return code to user mode for abort handlers
  */
 ENTRY(ret_from_exception)
+#ifdef CONFIG_IPIPE
+	bl     __ipipe_check_root
+	cmp     r0, #0
+	bne     1f
+	slow_restore_user_regs          @ Fast exit path over non-root domains
+1:
+#endif /* CONFIG_IPIPE */
 	get_thread_info tsk
 	mov	why, #0
 	b	ret_to_user
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/kernel/entry-common.S ipipe-2.6.14-imx21/arch/arm/kernel/entry-common.S
--- linux-2.6.14/arch/arm/kernel/entry-common.S	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/kernel/entry-common.S	2008-02-21 22:08:59.000000000 +0100
@@ -2,6 +2,7 @@
  *  linux/arch/arm/kernel/entry-common.S
  *
  *  Copyright (C) 2000 Russell King
+ *  Copyright (C) 2005 Stelian Pop.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -20,13 +21,18 @@
  * possible here, and this includes saving r0 back into the SVC
  * stack.
  */
+#ifdef CONFIG_IPIPE
+__ipipe_ret_fast_syscall:
+	ldr	r0, [sp, #S_R0+S_OFF]		@ returned r0
+	/* fall through */
+#endif
 ret_fast_syscall:
 	disable_irq				@ disable interrupts
 	ldr	r1, [tsk, #TI_FLAGS]
 	tst	r1, #_TIF_WORK_MASK
 	bne	fast_work_pending
 
-	@ fast_restore_user_regs
+fast_restore_user_regs:
 	ldr	r1, [sp, #S_OFF + S_PSR]	@ get calling cpsr
 	ldr	lr, [sp, #S_OFF + S_PC]!	@ get pc
 	msr	spsr_cxsf, r1			@ save in spsr_svc
@@ -35,6 +41,13 @@ ret_fast_syscall:
 	add	sp, sp, #S_FRAME_SIZE - S_PC
 	movs	pc, lr				@ return & move spsr_svc into cpsr
 
+#ifdef CONFIG_IPIPE
+__ipipe_fast_exit_syscall:
+	ldr	r0, [sp, #S_R0+S_OFF]		@ returned r0
+	disable_irq				@ disable interrupts
+	b	fast_restore_user_regs
+#endif /* CONFIG_IPIPE */
+
 /*
  * Ok, we need to do extra processing, enter the slow path.
  */
@@ -63,19 +76,15 @@ ret_slow_syscall:
 	tst	r1, #_TIF_WORK_MASK
 	bne	work_pending
 no_work_pending:
-	@ slow_restore_user_regs
-	ldr	r1, [sp, #S_PSR]		@ get calling cpsr
-	ldr	lr, [sp, #S_PC]!		@ get pc
-	msr	spsr_cxsf, r1			@ save in spsr_svc
-	ldmdb	sp, {r0 - lr}^			@ get calling r1 - lr
-	mov	r0, r0
-	add	sp, sp, #S_FRAME_SIZE - S_PC
-	movs	pc, lr				@ return & move spsr_svc into cpsr
+	slow_restore_user_regs
 
 /*
  * This is how we return from a fork.
  */
 ENTRY(ret_from_fork)
+#ifdef CONFIG_IPIPE
+	enable_irq
+#endif /* CONFIG_IPIPE */
 	bl	schedule_tail
 	get_thread_info tsk
 	ldr	r1, [tsk, #TI_FLAGS]		@ check for syscall tracing
@@ -152,6 +161,17 @@ ENTRY(vector_swi)
 	ldr	ip, [tsk, #TI_FLAGS]		@ check for syscall tracing
 	bic	scno, scno, #0xff000000		@ mask off SWI op-code
 	eor	scno, scno, #__NR_SYSCALL_BASE	@ check OS number
+#ifdef CONFIG_IPIPE
+	stmfd	sp!, {r0-r3, ip}
+	add	r1, sp, #S_OFF
+	add	r1, r1, #20
+	mov	r0, scno
+	bl	__ipipe_syscall_root
+	cmp	r0, #0
+	ldmfd	sp!, {r0-r3, ip}
+	blt	__ipipe_ret_fast_syscall
+	bgt	__ipipe_fast_exit_syscall
+#endif /* CONFIG_IPIPE */
 	adr	tbl, sys_call_table		@ load syscall table pointer
 	tst	ip, #_TIF_SYSCALL_TRACE		@ are we tracing syscalls?
 	bne	__sys_trace
@@ -196,6 +216,9 @@ __sys_trace_return:
 __cr_alignment:
 	.word	cr_alignment
 #endif
+#ifdef CONFIG_IPIPE
+	.word	__ipipe_syscall_root
+#endif
 
 	.type	sys_call_table, #object
 ENTRY(sys_call_table)
@@ -288,3 +311,28 @@ sys_mmap2:
 		str	r5, [sp, #4]
 		b	do_mmap2
 #endif
+
+#ifdef CONFIG_FRAME_POINTER
+
+	.text
+	.align 0
+	.type arm_return_addr %function
+	.global arm_return_addr
+
+arm_return_addr:
+	mov	ip, r0
+	mov	r0, fp
+3:
+	cmp	r0, #0
+	beq	1f		@ frame list hit end, bail
+	cmp	ip, #0
+	beq	2f		@ reached desired frame
+	ldr	r0, [r0, #-12]  @ else continue, get next fp
+	sub	ip, ip, #1
+	b	3b
+2:
+	ldr	r0, [r0, #-4]   @ get target return address
+1:
+	mov	pc, lr
+
+#endif
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/kernel/entry-header.S ipipe-2.6.14-imx21/arch/arm/kernel/entry-header.S
--- linux-2.6.14/arch/arm/kernel/entry-header.S	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/kernel/entry-header.S	2008-02-21 22:08:59.000000000 +0100
@@ -67,6 +67,15 @@
 #endif
 	.endm
 
+	.macro slow_restore_user_regs
+	ldr	r1, [sp, #S_PSR]		@ get calling cpsr
+	ldr	lr, [sp, #S_PC]!		@ get pc
+	msr	spsr_cxsf, r1			@ save in spsr_svc
+	ldmdb	sp, {r0 - lr}^			@ get calling r1 - lr
+	mov	r0, r0
+	add	sp, sp, #S_FRAME_SIZE - S_PC
+	movs	pc, lr				@ return & move spsr_svc into cpsr
+	.endm
 
 /*
  * These are the registers used in the syscall handler, and allow us to
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/kernel/head.S ipipe-2.6.14-imx21/arch/arm/kernel/head.S
--- linux-2.6.14/arch/arm/kernel/head.S	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/kernel/head.S	2008-02-21 22:08:59.000000000 +0100
@@ -10,6 +10,12 @@
  * published by the Free Software Foundation.
  *
  *  Kernel startup code for all 32-bit CPUs
+ *
+ * March 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ *
  */
 #include <linux/config.h>
 #include <linux/linkage.h>
@@ -33,6 +39,10 @@
 #define MACHINFO_PGOFFIO	12
 #define MACHINFO_NAME		16
 
+
+#define ATAG_CORE		0x54410001
+#define ATAG_CORE_SIZE		((2*4 + 3*4) >> 2)
+
 #ifndef CONFIG_XIP_KERNEL
 /*
  * We place the page tables 16K below TEXTADDR.  Therefore, we must make sure
@@ -88,6 +98,7 @@
  * This is normally called from the decompressor code.  The requirements
  * are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,
  * r1 = machine nr.
+ * r2 = atags pointer
  *
  * This code is mostly position independent, so if you link the kernel at
  * 0xc0008000, you call this at __pa(0xc0008000).
@@ -110,6 +121,9 @@ ENTRY(stext)
 	bl	__lookup_machine_type		@ r5=machinfo
 	movs	r8, r5				@ invalid machine (r5=0)?
 	beq	__error_a			@ yes, error 'a'
+	
+	bl	__vet_atags			@ determine validity of r2
+
 	bl	__create_page_tables
 
 	/*
@@ -133,7 +147,10 @@ __switch_data:
 	.long	_end				@ r7
 	.long	processor_id			@ r4
 	.long	__machine_arch_type		@ r5
-	.long	cr_alignment			@ r6
+	.long	__atags_pointer			@ r6
+
+	.long	cr_alignment			@ r7	
+
 	.long	init_thread_union + THREAD_START_SP @ sp
 
 /*
@@ -142,12 +159,14 @@ __switch_data:
  *
  *  r0  = cp#15 control register
  *  r1  = machine ID
+ *  r2  = atags pointer
  *  r9  = processor ID
  */
 	.type	__mmap_switched, %function
 __mmap_switched:
 	adr	r3, __switch_data + 4
 
+	
 	ldmia	r3!, {r4, r5, r6, r7}
 	cmp	r4, r5				@ Copy data segment if needed
 1:	cmpne	r5, r6
@@ -160,11 +179,17 @@ __mmap_switched:
 	strcc	fp, [r6],#4
 	bcc	1b
 
-	ldmia	r3, {r4, r5, r6, sp}
+	ldmia	r3, {r4, r5, r6, r7, sp}
+	
 	str	r9, [r4]			@ Save processor ID
 	str	r1, [r5]			@ Save machine type
+
+	str	r2, [r6]			@ Save atags pointer
+
 	bic	r4, r0, #CR_A			@ Clear 'A' bit
-	stmia	r6, {r0, r4}			@ Save control register values
+
+	stmia	r7, {r0, r4}			@ Save control register values
+		
 	b	start_kernel
 
 #if defined(CONFIG_SMP)
@@ -262,6 +287,45 @@ __turn_mmu_on:
 	mov	pc, r13
 
 
+/* Determine validity of the r2 atags pointer.  The heuristic requires
+ * that the pointer be aligned, in the first 16k of physical RAM and
+ * that the ATAG_CORE marker is first and present.  Future revisions
+ * of this function may be more lenient with the physical address and
+ * may also be able to move the ATAGS block if necessary.
+ *
+ * r8  = machinfo
+ *
+ * Returns:
+ *  r2 either valid atags pointer, or zero
+ *  r5, r6 corrupted
+ */
+
+	.type	__vet_atags, %function
+__vet_atags:
+
+	tst	r2, #0x3			@ aligned?
+	bne	1f
+
+	ldr	r5, [r8, #MACHINFO_PHYSRAM]	@ constrain r2 to first 16KiB
+	cmp	r2, r5
+	blo	1f
+	add	r5, r5, #0x4000
+	cmp	r2, r5
+	bhs	1f
+
+	ldr	r5, [r2, #0]			@ is first tag ATAG_CORE?
+	subs	r5, r5, #ATAG_CORE_SIZE
+	bne	1f
+	ldr	r5, [r2, #4]
+	ldr	r6, =ATAG_CORE
+	cmp	r5, r6
+	bne	1f
+
+	mov	pc, lr				@ atag pointer is ok
+
+1:	mov	r2, #0
+	mov	pc, lr
+
 
 /*
  * Setup the initial page tables.  We only setup the barest
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/kernel/ipipe-core.c ipipe-2.6.14-imx21/arch/arm/kernel/ipipe-core.c
--- linux-2.6.14/arch/arm/kernel/ipipe-core.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/arch/arm/kernel/ipipe-core.c	2008-02-21 22:08:59.000000000 +0100
@@ -0,0 +1,239 @@
+/* -*- linux-c -*-
+ * linux/arch/arm/kernel/ipipe-core.c
+ *
+ * Copyright (C) 2002-2005 Philippe Gerum.
+ * Copyright (C) 2004 Wolfgang Grandegger (Adeos/arm port over 2.4).
+ * Copyright (C) 2005 Heikki Lindholm (PowerPC 970 fixes).
+ * Copyright (C) 2005 Stelian Pop.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge MA 02139,
+ * USA; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Architecture-dependent I-PIPE core support for ARM.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/smp.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/bitops.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <asm/system.h>
+#include <asm/atomic.h>
+#include <asm/hardirq.h>
+#include <asm/io.h>
+
+/* Current reload value for the decrementer. */
+unsigned long __ipipe_decr_ticks;
+
+/* Next tick date (timebase value). */
+unsigned long long __ipipe_decr_next[IPIPE_NR_CPUS];
+
+struct pt_regs __ipipe_tick_regs[IPIPE_NR_CPUS];
+
+#ifdef CONFIG_SMP
+
+static cpumask_t __ipipe_cpu_sync_map;
+
+static cpumask_t __ipipe_cpu_lock_map;
+
+static ipipe_spinlock_t __ipipe_cpu_barrier = IPIPE_SPIN_LOCK_UNLOCKED;
+
+static atomic_t __ipipe_critical_count = ATOMIC_INIT(0);
+
+static void (*__ipipe_cpu_sync) (void);
+
+/* Always called with hw interrupts off. */
+
+void __ipipe_do_critical_sync(unsigned irq)
+{
+	ipipe_declare_cpuid;
+
+	ipipe_load_cpuid();
+
+	cpu_set(cpuid, __ipipe_cpu_sync_map);
+
+	/*
+	 * Now we are in sync with the lock requestor running on another
+	 * CPU. Enter a spinning wait until he releases the global
+	 * lock.
+	 */
+	spin_lock_hw(&__ipipe_cpu_barrier);
+
+	/* Got it. Now get out. */
+
+	if (__ipipe_cpu_sync)
+		/* Call the sync routine if any. */
+		__ipipe_cpu_sync();
+
+	spin_unlock_hw(&__ipipe_cpu_barrier);
+
+	cpu_clear(cpuid, __ipipe_cpu_sync_map);
+}
+
+#endif	/* CONFIG_SMP */
+
+/*
+ * ipipe_critical_enter() -- Grab the superlock excluding all CPUs
+ * but the current one from a critical section. This lock is used when
+ * we must enforce a global critical section for a single CPU in a
+ * possibly SMP system whichever context the CPUs are running.
+ */
+unsigned long ipipe_critical_enter(void (*syncfn) (void))
+{
+	unsigned long flags;
+
+	local_irq_save_hw(flags);
+
+#ifdef CONFIG_SMP
+	if (num_online_cpus() > 1) {	/* We might be running a SMP-kernel on a UP box... */
+		ipipe_declare_cpuid;
+		cpumask_t lock_map;
+
+		ipipe_load_cpuid();
+
+		if (!cpu_test_and_set(cpuid, __ipipe_cpu_lock_map)) {
+			while (cpu_test_and_set(BITS_PER_LONG - 1,
+						__ipipe_cpu_lock_map)) {
+				int n = 0;
+				do {
+					cpu_relax();
+				} while (++n < cpuid);
+			}
+
+			spin_lock_hw(&__ipipe_cpu_barrier);
+
+			__ipipe_cpu_sync = syncfn;
+
+			/* Send the sync IPI to all processors but the current one. */
+			send_IPI_allbutself(IPIPE_CRITICAL_VECTOR);
+
+			cpus_andnot(lock_map, cpu_online_map,
+				    __ipipe_cpu_lock_map);
+
+			while (!cpus_equal(__ipipe_cpu_sync_map, lock_map))
+				cpu_relax();
+		}
+
+		atomic_inc(&__ipipe_critical_count);
+	}
+#endif	/* CONFIG_SMP */
+
+	return flags;
+}
+
+/* ipipe_critical_exit() -- Release the superlock. */
+
+void ipipe_critical_exit(unsigned long flags)
+{
+#ifdef CONFIG_SMP
+	if (num_online_cpus() > 1) {	/* We might be running a SMP-kernel on a UP box... */
+		ipipe_declare_cpuid;
+
+		ipipe_load_cpuid();
+
+		if (atomic_dec_and_test(&__ipipe_critical_count)) {
+			spin_unlock_hw(&__ipipe_cpu_barrier);
+
+			while (!cpus_empty(__ipipe_cpu_sync_map))
+				cpu_relax();
+
+			cpu_clear(cpuid, __ipipe_cpu_lock_map);
+			cpu_clear(BITS_PER_LONG - 1, __ipipe_cpu_lock_map);
+		}
+	}
+#endif	/* CONFIG_SMP */
+
+	local_irq_restore_hw(flags);
+}
+
+void __ipipe_init_platform(void)
+{
+	__ipipe_decr_ticks = __ipipe_mach_ticks_per_jiffy;
+}
+
+int ipipe_get_sysinfo(struct ipipe_sysinfo *info)
+{
+	info->ncpus = num_online_cpus();
+	info->cpufreq = ipipe_cpu_freq();
+	info->archdep.tmirq = __ipipe_mach_timerint;
+	info->archdep.tmfreq = info->cpufreq;
+
+	return 0;
+}
+
+/*
+ * ipipe_trigger_irq() -- Push the interrupt at front of the pipeline
+ * just like if it has been actually received from a hw source. Also
+ * works for virtual interrupts.
+ */
+int ipipe_trigger_irq(unsigned irq)
+{
+	unsigned long flags;
+
+	if (irq >= IPIPE_NR_IRQS ||
+	    (ipipe_virtual_irq_p(irq)
+	     && !test_bit(irq - IPIPE_VIRQ_BASE, &__ipipe_virtual_irq_map)))
+		return -EINVAL;
+
+	local_irq_save_hw(flags);
+
+	__ipipe_handle_irq(irq, NULL);
+
+	local_irq_restore_hw(flags);
+
+	return 1;
+}
+
+static void __ipipe_set_decr(void)
+{
+	ipipe_declare_cpuid;
+
+	ipipe_load_cpuid();
+
+	__ipipe_decr_next[cpuid] = __ipipe_read_timebase() + __ipipe_decr_ticks;
+	__ipipe_mach_set_dec(__ipipe_decr_ticks);
+}
+
+int ipipe_tune_timer(unsigned long ns, int flags)
+{
+	unsigned long x, ticks;
+
+	if (flags & IPIPE_RESET_TIMER)
+		ticks = __ipipe_mach_ticks_per_jiffy;
+	else {
+		ticks = (ns / 1000) * (__ipipe_mach_ticks_per_jiffy) / (1000000 / HZ);
+
+		if (ticks > __ipipe_mach_ticks_per_jiffy)
+			return -EINVAL;
+	}
+
+	x = ipipe_critical_enter(&__ipipe_set_decr);	/* Sync with all CPUs */
+	__ipipe_decr_ticks = ticks;
+	__ipipe_set_decr();
+	ipipe_critical_exit(x);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(__ipipe_decr_ticks);
+EXPORT_SYMBOL(__ipipe_decr_next);
+EXPORT_SYMBOL(ipipe_critical_enter);
+EXPORT_SYMBOL(ipipe_critical_exit);
+EXPORT_SYMBOL(ipipe_trigger_irq);
+EXPORT_SYMBOL(ipipe_get_sysinfo);
+EXPORT_SYMBOL(ipipe_tune_timer);
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/kernel/ipipe-mcount.S ipipe-2.6.14-imx21/arch/arm/kernel/ipipe-mcount.S
--- linux-2.6.14/arch/arm/kernel/ipipe-mcount.S	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/arch/arm/kernel/ipipe-mcount.S	2008-02-21 22:08:59.000000000 +0100
@@ -0,0 +1,40 @@
+/*
+ *  linux/arch/arm/kernel/ipipe-mcount.S
+ *
+ *  Copyright (C) 2006 Sebastian Smolorz <ssmolorz@emlix.com>, emlix GmbH
+ */
+
+#include <linux/config.h>
+
+#ifdef CONFIG_FRAME_POINTER
+
+	.text
+	.align 0
+	.type mcount %function
+	.global mcount
+
+mcount:
+
+	ldr	ip, =ipipe_trace_enable	@ leave early, if disabled
+	ldr	ip, [ip]
+	cmp	ip, #0
+	moveq	pc,lr
+
+	mov	ip,  sp
+	stmdb   sp!, {r0 - r3, fp, ip, lr, pc}	@ create stack frame
+
+	mov	r3, #0			@ no additional value (v)
+	ldr	r2, [fp, #-4]		@ get lr (the return address
+					@ of the caller of the
+					@ instrumented function)
+	mov	r1, lr			@ get lr - (the return address
+					@ of the instrumented function)
+	mov	r0, #0			@ IPIPE_TRACE_FN
+
+	sub	fp, ip, #4		@ point fp at this frame
+
+	bl	__ipipe_trace
+
+	ldmdb   fp, {r0 - r3, fp, sp, pc}	@ pop entry frame and return
+
+#endif
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/kernel/ipipe-root.c ipipe-2.6.14-imx21/arch/arm/kernel/ipipe-root.c
--- linux-2.6.14/arch/arm/kernel/ipipe-root.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/arch/arm/kernel/ipipe-root.c	2008-02-21 22:08:59.000000000 +0100
@@ -0,0 +1,419 @@
+/* -*- linux-c -*-
+ * linux/arch/arm/kernel/ipipe-root.c
+ *
+ * Copyright (C) 2002-2005 Philippe Gerum (Adeos/ppc port over 2.6).
+ * Copyright (C) 2004 Wolfgang Grandegger (Adeos/ppc port over 2.4).
+ * Copyright (C) 2005 Stelian Pop.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge MA 02139,
+ * USA; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Architecture-dependent I-pipe support for ARM.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <asm/system.h>
+#include <asm/hardirq.h>
+#include <asm/atomic.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/unistd.h>
+#include <asm/mach/irq.h>
+#include <asm/mmu_context.h>
+
+extern struct irqdesc irq_desc[];
+extern spinlock_t irq_controller_lock;
+extern asmlinkage void asm_do_IRQ(unsigned int irq, struct pt_regs *regs);
+
+static struct irqchip __ipipe_std_irq_dtype[NR_IRQS];
+
+static void __ipipe_override_irq_unmask(unsigned irq)
+{
+	unsigned long flags;
+
+	local_irq_save_hw(flags);
+	ipipe_irq_unlock(irq);
+	__ipipe_std_irq_dtype[irq].unmask(irq);
+	local_irq_restore_hw(flags);
+}
+
+static void __ipipe_override_irq_mask(unsigned irq)
+{
+	unsigned long flags;
+
+	local_irq_save_hw(flags);
+	ipipe_irq_lock(irq);
+	__ipipe_std_irq_dtype[irq].mask(irq);
+	local_irq_restore_hw(flags);
+}
+
+static void __ipipe_override_irq_mask_ack(unsigned irq)
+{
+	unsigned long flags;
+
+	local_irq_save_hw(flags);
+	ipipe_irq_lock(irq);
+	__ipipe_std_irq_dtype[irq].ack(irq);
+	local_irq_restore_hw(flags);
+}
+
+
+static void __ipipe_enable_sync(void)
+{
+	__ipipe_decr_next[ipipe_processor_id()] =
+		__ipipe_read_timebase() + __ipipe_mach_get_dec();
+}
+
+/*
+ * __ipipe_enable_pipeline() -- We are running on the boot CPU, hw
+ * interrupts are off, and secondary CPUs are still lost in space.
+ */
+void __ipipe_enable_pipeline(void)
+{
+	unsigned long flags;
+	unsigned irq;
+
+	flags = ipipe_critical_enter(&__ipipe_enable_sync);
+
+	/* First, virtualize all interrupts from the root domain. */
+
+	for (irq = 0; irq < NR_IRQS; irq++)
+		ipipe_virtualize_irq(ipipe_root_domain,
+				     irq,
+				     (ipipe_irq_handler_t)&asm_do_IRQ, NULL,
+				     ((irq == __ipipe_mach_timerint)
+				      ? &__ipipe_ack_timerirq
+				      : &__ipipe_ack_irq),
+				     IPIPE_HANDLE_MASK | IPIPE_PASS_MASK);
+
+	/*
+	 * Interpose on the IRQ control routines so we can make them
+	 * atomic using hw masking and prevent the interrupt log from
+	 * being untimely flushed.
+	 */
+
+	for (irq = 0; irq < NR_IRQS; irq++)
+		__ipipe_std_irq_dtype[irq] = *irq_desc[irq].chip;
+
+	/*
+	 * The original controller structs are often shared, so we first
+	 * save them all before changing any of them. Notice that we don't
+	 * override the ack() handler since we will enforce the necessary
+	 * setup in __ipipe_ack_irq().
+	 */
+
+	for (irq = 0; irq < NR_IRQS; irq++) {
+		if (irq_desc[irq].chip->mask != NULL)
+			irq_desc[irq].chip->mask = __ipipe_override_irq_mask;
+
+		if (irq_desc[irq].chip->unmask != NULL)
+			irq_desc[irq].chip->unmask = __ipipe_override_irq_unmask;
+
+		if (irq_desc[irq].chip->ack != NULL)
+			irq_desc[irq].chip->ack = __ipipe_override_irq_mask_ack;
+	}
+
+	__ipipe_decr_next[ipipe_processor_id()] =
+		__ipipe_read_timebase() + __ipipe_mach_get_dec();
+
+	ipipe_critical_exit(flags);
+}
+
+int __ipipe_ack_irq(unsigned irq)
+{
+	unsigned long flags;
+	ipipe_declare_cpuid;
+
+	/*
+	 * No need to mask IRQs at hw level: we are always called from
+	 * __ipipe_handle_irq(), so interrupts are already off. We
+	 * stall the pipeline so that spin_lock_irq*() ops won't
+	 * unintentionally flush it, since this could cause infinite
+	 * recursion.
+	 */
+
+	ipipe_load_cpuid();
+	flags = ipipe_test_and_stall_pipeline();
+	preempt_disable();
+	spin_lock_hw(&irq_controller_lock);
+	__ipipe_std_irq_dtype[irq].ack(irq);
+	spin_unlock_hw(&irq_controller_lock);
+	preempt_enable_no_resched();
+	ipipe_restore_pipeline_nosync(per_cpu(ipipe_percpu_domain, cpuid), flags, cpuid);
+
+	return 1;
+}
+
+int __ipipe_ack_timerirq(unsigned irq)
+{
+	unsigned long flags;
+	ipipe_declare_cpuid;
+
+	ipipe_load_cpuid();
+	flags = ipipe_test_and_stall_pipeline();
+	preempt_disable();
+	spin_lock_hw(&irq_controller_lock);
+	__ipipe_mach_acktimer();
+	__ipipe_std_irq_dtype[irq].ack(irq);
+#ifdef irq_finish
+	irq_finish(irq);
+#endif /* irq_finish */
+	__ipipe_std_irq_dtype[irq].unmask(irq);
+	spin_unlock_hw(&irq_controller_lock);
+	preempt_enable_no_resched();
+	ipipe_restore_pipeline_nosync(per_cpu(ipipe_percpu_domain, cpuid), flags, cpuid);
+
+	return 1;
+}
+
+/*
+ * __ipipe_handle_irq() -- IPIPE's generic IRQ handler. An optimistic
+ * interrupt protection log is maintained here for each domain. Hw
+ * interrupts are off on entry.
+ */
+void __ipipe_handle_irq(int irq, struct pt_regs *regs)
+{
+	struct ipipe_domain *this_domain, *next_domain;
+	struct list_head *head, *pos;
+	ipipe_declare_cpuid;
+	int m_ack, s_ack;
+
+	m_ack = (regs == NULL);
+
+	if (irq >= IPIPE_NR_IRQS) {
+		printk(KERN_ERR "I-pipe: spurious interrupt %d\n", irq);
+		return;
+	}
+
+	ipipe_load_cpuid();
+
+	this_domain = per_cpu(ipipe_percpu_domain, cpuid);
+
+	if (test_bit(IPIPE_STICKY_FLAG, &this_domain->irqs[irq].control))
+		head = &this_domain->p_link;
+	else {
+		head = __ipipe_pipeline.next;
+		next_domain = list_entry(head, struct ipipe_domain, p_link);
+		if (likely(test_bit(IPIPE_WIRED_FLAG, &next_domain->irqs[irq].control))) {
+			if (!m_ack && next_domain->irqs[irq].acknowledge != NULL)
+				next_domain->irqs[irq].acknowledge(irq);
+			if (likely(__ipipe_dispatch_wired(next_domain, irq)))
+				goto finalize;
+			return;
+		}
+	}
+
+	/* Ack the interrupt. */
+
+	s_ack = m_ack;
+	pos = head;
+
+	while (pos != &__ipipe_pipeline) {
+		next_domain = list_entry(pos, struct ipipe_domain, p_link);
+
+		/*
+		 * For each domain handling the incoming IRQ, mark it as
+		 * pending in its log.
+		 */
+		if (test_bit(IPIPE_HANDLE_FLAG,
+			     &next_domain->irqs[irq].control)) {
+			/*
+			 * Domains that handle this IRQ are polled for
+			 * acknowledging it by decreasing priority order. The
+			 * interrupt must be made pending _first_ in the
+			 * domain's status flags before the PIC is unlocked.
+			 */
+
+			next_domain->cpudata[cpuid].irq_counters[irq].total_hits++;
+			next_domain->cpudata[cpuid].irq_counters[irq].pending_hits++;
+			__ipipe_set_irq_bit(next_domain, cpuid, irq);
+
+			/*
+			 * Always get the first master acknowledge available.
+			 * Once we've got it, allow slave acknowledge
+			 * handlers to run (until one of them stops us).
+			 */
+			if (next_domain->irqs[irq].acknowledge != NULL) {
+				if (!m_ack)
+					m_ack = next_domain->irqs[irq].acknowledge(irq);
+				else if (test_bit
+					 (IPIPE_SHARED_FLAG,
+					  &next_domain->irqs[irq].control) && !s_ack)
+					s_ack = next_domain->irqs[irq].acknowledge(irq);
+			}
+		}
+
+		/*
+		 * If the domain does not want the IRQ to be passed down the
+		 * interrupt pipe, exit the loop now.
+		 */
+
+		if (!test_bit(IPIPE_PASS_FLAG, &next_domain->irqs[irq].control))
+			break;
+
+		pos = next_domain->p_link.next;
+	}
+
+finalize:
+	/*
+	 * Now walk the pipeline, yielding control to the highest
+	 * priority domain that has pending interrupt(s) or
+	 * immediately to the current domain if the interrupt has been
+	 * marked as 'sticky'. This search does not go beyond the
+	 * current domain in the pipeline.
+	 */
+
+	__ipipe_walk_pipeline(head, cpuid);
+}
+
+asmlinkage int __ipipe_grab_irq(int irq, struct pt_regs *regs)
+{
+	ipipe_declare_cpuid;
+
+	if (irq == __ipipe_mach_timerint) {
+
+		__ipipe_tick_regs[cpuid].ARM_cpsr = regs->ARM_cpsr;
+		__ipipe_tick_regs[cpuid].ARM_pc = regs->ARM_pc;
+
+		if (__ipipe_decr_ticks != __ipipe_mach_ticks_per_jiffy) {
+			unsigned long long next_date, now;
+
+			next_date = __ipipe_decr_next[cpuid];
+
+			while ((now = __ipipe_read_timebase()) >= next_date)
+				next_date += __ipipe_decr_ticks;
+
+			__ipipe_mach_set_dec(next_date - now);
+
+			__ipipe_decr_next[cpuid] = next_date;
+		}
+	}
+
+#ifdef CONFIG_IPIPE_TRACE_IRQSOFF
+	ipipe_trace_begin(regs->ARM_ORIG_r0);
+#endif
+
+	if (__ipipe_mach_irq_mux_p(irq))
+		__ipipe_mach_demux_irq(irq, regs);
+	else
+		__ipipe_handle_irq(irq, regs);
+
+#ifdef CONFIG_IPIPE_TRACE_IRQSOFF
+	ipipe_trace_end(regs->ARM_ORIG_r0);
+#endif
+
+#ifdef irq_finish
+	if (irq != __ipipe_mach_timerint)
+		irq_finish(irq);
+#endif /* irq_finish */
+	ipipe_load_cpuid();
+
+	return (per_cpu(ipipe_percpu_domain, cpuid) == ipipe_root_domain &&
+		!test_bit(IPIPE_STALL_FLAG,
+			  &ipipe_root_domain->cpudata[cpuid].status));
+}
+
+asmlinkage int __ipipe_check_root(void)
+{
+	return per_cpu(ipipe_percpu_domain, ipipe_processor_id()) == ipipe_root_domain;
+}
+
+asmlinkage int __ipipe_check_root_interruptible(void)
+{
+	ipipe_declare_cpuid;
+
+	ipipe_load_cpuid();
+
+	return (per_cpu(ipipe_percpu_domain, cpuid) == ipipe_root_domain &&	
+		!test_bit(IPIPE_STALL_FLAG,
+			  &ipipe_root_domain->cpudata[cpuid].status));
+}
+
+/* Called from entry-armv.S with hw interrupts off */
+asmlinkage void __ipipe_fast_stall_root(void)
+{
+	ipipe_declare_cpuid;
+
+	ipipe_load_cpuid();
+
+	set_bit(IPIPE_STALL_FLAG, &ipipe_root_domain->cpudata[cpuid].status);	
+}
+
+/* Called from entry-armv.S with hw interrupts off */
+asmlinkage void __ipipe_fast_unstall_root(void)
+{
+	ipipe_declare_cpuid;
+
+	ipipe_load_cpuid();
+
+	__clear_bit(IPIPE_STALL_FLAG, &ipipe_root_domain->cpudata[cpuid].status);
+}
+
+asmlinkage int __ipipe_syscall_root(unsigned long scno, struct pt_regs *regs)
+{
+	ipipe_declare_cpuid;
+	unsigned long flags, origr7;
+
+	/* We use r7 to pass the syscall number to the other domains */
+	origr7 = regs->ARM_r7;
+	regs->ARM_r7 = __NR_SYSCALL_BASE + scno;
+
+	/*
+	 * This routine either returns:
+	 * 0 -- if the syscall is to be passed to Linux;
+	 * >0 -- if the syscall should not be passed to Linux, and no
+	 * tail work should be performed;
+	 * <0 -- if the syscall should not be passed to Linux but the
+	 * tail work has to be performed (for handling signals etc).
+	 */
+
+	if (__ipipe_syscall_watched_p(current, regs->ARM_r7) &&
+	    __ipipe_event_monitored_p(IPIPE_EVENT_SYSCALL) &&
+	    __ipipe_dispatch_event(IPIPE_EVENT_SYSCALL,regs) > 0) {
+		if (ipipe_current_domain == ipipe_root_domain && !in_atomic()) {
+			/*
+			 * Sync pending VIRQs before _TIF_NEED_RESCHED
+			 * is tested.
+			 */
+			ipipe_lock_cpu(flags);
+			if ((ipipe_root_domain->cpudata[cpuid].irq_pending_hi & IPIPE_IRQMASK_VIRT) != 0)
+				__ipipe_sync_pipeline(IPIPE_IRQMASK_VIRT);
+			ipipe_unlock_cpu(flags);
+			regs->ARM_r7 = origr7;
+			return -1;
+		}
+		regs->ARM_r7 = origr7;
+		return 1;
+	}
+
+	regs->ARM_r7 = origr7;
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(show_stack);
+#ifndef MULTI_CPU
+EXPORT_SYMBOL_GPL(cpu_do_switch_mm);
+#endif
+
+#ifdef CONFIG_IPIPE_TRACE_MCOUNT
+void notrace mcount(void);
+EXPORT_SYMBOL(mcount);
+#endif /* CONFIG_IPIPE_TRACE_MCOUNT */
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/kernel/irq.c ipipe-2.6.14-imx21/arch/arm/kernel/irq.c
--- linux-2.6.14/arch/arm/kernel/irq.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/kernel/irq.c	2008-02-21 22:08:59.000000000 +0100
@@ -54,10 +54,11 @@
 
 static int noirqdebug;
 static volatile unsigned long irq_err_count;
-static DEFINE_SPINLOCK(irq_controller_lock);
+DEFINE_SPINLOCK(irq_controller_lock);
 static LIST_HEAD(irq_pending);
 
 struct irqdesc irq_desc[NR_IRQS];
+EXPORT_SYMBOL(irq_desc);
 void (*init_arch_irq)(void) __initdata = NULL;
 
 /*
@@ -411,7 +412,9 @@ do_edge_IRQ(unsigned int irq, struct irq
 	/*
 	 * Acknowledge and clear the IRQ, but don't mask it.
 	 */
+#ifndef CONFIG_IPIPE
 	desc->chip->ack(irq);
+#endif /* CONFIG_IPIPE */
 
 	/*
 	 * Mark the IRQ currently in progress.
@@ -449,8 +452,10 @@ do_edge_IRQ(unsigned int irq, struct irq
 	 * currently running.  Delay it.
 	 */
 	desc->pending = 1;
+#ifndef CONFIG_IPIPE
 	desc->chip->mask(irq);
 	desc->chip->ack(irq);
+#endif /* CONFIG_IPIPE */
 }
 
 /*
@@ -467,7 +472,9 @@ do_level_IRQ(unsigned int irq, struct ir
 	/*
 	 * Acknowledge, clear _AND_ disable the interrupt.
 	 */
+#ifndef CONFIG_IPIPE
 	desc->chip->ack(irq);
+#endif /* CONFIG_IPIPE */
 
 	if (likely(!desc->disable_depth)) {
 		kstat_cpu(cpu).irqs[irq]++;
@@ -553,7 +560,9 @@ asmlinkage void asm_do_IRQ(unsigned int 
 	if (!list_empty(&irq_pending))
 		do_pending_irqs(regs);
 
+#ifndef CONFIG_IPIPE
 	irq_finish(irq);
+#endif /* CONFIG_IPIPE */
 
 	spin_unlock(&irq_controller_lock);
 	irq_exit();
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/kernel/process.c ipipe-2.6.14-imx21/arch/arm/kernel/process.c
--- linux-2.6.14/arch/arm/kernel/process.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/kernel/process.c	2008-02-21 22:08:59.000000000 +0100
@@ -39,6 +39,10 @@ extern void setup_mm_for_reboot(char mod
 
 static volatile int hlt_counter;
 
+#ifdef CONFIG_IPIPE
+static volatile int idle_mode = 1; 
+#endif
+
 #include <asm/arch/system.h>
 
 void disable_hlt(void)
@@ -67,6 +71,27 @@ static int __init hlt_setup(char *__unus
 	return 1;
 }
 
+#ifdef CONFIG_IPIPE
+static int __init idle_setup(char *str)
+{
+	if(!strncmp(str, "poll",strlen("poll"))) {
+		idle_mode = 0;
+		printk(KERN_INFO
+	       	       "I-pipe : CPU idle mode selected : %s\n",
+	               str);
+	}
+	else {
+		idle_mode = 1;
+		printk(KERN_INFO
+	       	       "I-pipe : Unknown CPU idle mode : %s -> default mode selected\n",
+	               str);
+	}
+	return 1;
+
+}
+__setup("idle=", idle_setup);
+#endif
+
 __setup("nohlt", nohlt_setup);
 __setup("hlt", hlt_setup);
 
@@ -88,6 +113,12 @@ void default_idle(void)
 	local_irq_disable();
 	if (!need_resched() && !hlt_counter) {
 		timer_dyn_reprogram();
+#ifdef CONFIG_IPIPE
+			__ipipe_unstall_root();
+#ifdef CONFIG_IPIPE_TRACE_IRQSOFF
+			ipipe_trace_end(0x8000000E);
+#endif /* CONFIG_IPIPE_TRACE_IRQSOFF */
+#endif /* CONFIG_IPIPE */
 		arch_idle();
 	}
 	local_irq_enable();
@@ -107,10 +138,22 @@ void cpu_idle(void)
 		void (*idle)(void) = pm_idle;
 		if (!idle)
 			idle = default_idle;
+		ipipe_suspend_domain();
 		preempt_disable();
 		leds_event(led_idle_start);
 		while (!need_resched())
+#ifdef CONFIG_IPIPE
+		//Test if the kernel start with polling
+		//option for the idle of CPU
+		if(idle_mode == 0) {
+			;
+                }
+		else {
 			idle();
+		}	
+#else
+		idle();
+#endif
 		leds_event(led_idle_end);
 		preempt_enable();
 		schedule();
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/kernel/setup.c ipipe-2.6.14-imx21/arch/arm/kernel/setup.c
--- linux-2.6.14/arch/arm/kernel/setup.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/kernel/setup.c	2008-02-21 22:08:59.000000000 +0100
@@ -6,6 +6,12 @@
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
+ *
+ * March 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ *
  */
 #include <linux/config.h>
 #include <linux/module.h>
@@ -66,6 +72,8 @@ unsigned int processor_id;
 unsigned int __machine_arch_type;
 EXPORT_SYMBOL(__machine_arch_type);
 
+unsigned int __atags_pointer __initdata;
+
 unsigned int system_rev;
 EXPORT_SYMBOL(system_rev);
 
@@ -737,7 +745,12 @@ void __init setup_arch(char **cmdline_p)
 	if (mdesc->soft_reboot)
 		reboot_setup("s");
 
-	if (mdesc->boot_params)
+	if (__atags_pointer) {
+	  tags = phys_to_virt (__atags_pointer);
+	  if (ATAG_CORE == tags->hdr.tag)
+	    printk ("ATAGS found at 0x%x\n", __atags_pointer);
+	}
+	else if (mdesc->boot_params)
 		tags = phys_to_virt(mdesc->boot_params);
 
 	/*
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-imx21/Kconfig ipipe-2.6.14-imx21/arch/arm/mach-imx21/Kconfig
--- linux-2.6.14/arch/arm/mach-imx21/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/arch/arm/mach-imx21/Kconfig	2008-02-21 22:08:59.000000000 +0100
@@ -0,0 +1,37 @@
+menu "IMX Implementations"
+	depends on FAMILY_IMX21
+
+choice
+	prompt "Select IMX21-based board"
+	default ARCH_MX2ADS
+
+config MACH_CSB535
+	bool "CSB535"
+	depends on FAMILY_IMX21
+	select ARCH_IMX21
+	help
+	  Say Y here if you are using the Cogent CSB535 board.
+
+config ARCH_MX2ADS
+	bool "mx2ads"
+	depends on FAMILY_IMX21
+	select ARCH_IMX21
+	help
+	  Say Y here if you are using the Freescale MX21ADS board
+ 
+endchoice
+
+config UMON_SHIM
+	bool "Shim uMON's call command"
+	depends on MACH_CSB535
+	default n
+	help
+		Select Y to add an assembly language "shim" to the bootloader
+		that maps the parameters as they are passed by older versions
+		of uMON to the ATAGS parameter passing convention supported by
+		the latest arm-linux kernels.  If in doubt, select yes.
+
+endmenu
+
+config ARCH_IMX21
+	bool
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-imx21/Makefile ipipe-2.6.14-imx21/arch/arm/mach-imx21/Makefile
--- linux-2.6.14/arch/arm/mach-imx21/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/arch/arm/mach-imx21/Makefile	2008-02-21 22:08:59.000000000 +0100
@@ -0,0 +1,20 @@
+#
+# Makefile for the linux kernel.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+
+# Object file lists.
+
+obj-y			+= irq.o time.o dma.o generic.o
+
+# Specific board support
+obj-$(CONFIG_ARCH_MX2ADS) += mx2ads.o
+obj-$(CONFIG_MACH_CSB535) += csb535.o
+
+# Support for blinky lights
+led-y := leds.o
+
+obj-$(CONFIG_LEDS)	+=  $(led-y)
+led-$(CONFIG_ARCH_MX2ADS) += leds-mx2ads.o
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-imx21/Makefile.boot ipipe-2.6.14-imx21/arch/arm/mach-imx21/Makefile.boot
--- linux-2.6.14/arch/arm/mach-imx21/Makefile.boot	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/arch/arm/mach-imx21/Makefile.boot	2008-02-21 22:08:59.000000000 +0100
@@ -0,0 +1,3 @@
+    zreladdr-$(CONFIG_ARCH_MX2ADS)	:= 0xc0008000
+    zreladdr-$(CONFIG_MACH_CSB535)	:= 0xc0008000
+
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-imx21/csb535.c ipipe-2.6.14-imx21/arch/arm/mach-imx21/csb535.c
--- linux-2.6.14/arch/arm/mach-imx21/csb535.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/arch/arm/mach-imx21/csb535.c	2008-02-21 22:08:59.000000000 +0100
@@ -0,0 +1,208 @@
+/*
+ * arch/arm/mach-imx21/csb535.c
+ *
+ * Initially based on:
+ *	linux-2.6.7-imx/arch/arm/ mach-imx /scb9328.c
+ *	Copyright (c) 2004 Sascha Hauer <sascha@saschahauer.de>
+ *
+ * 2004 (c) MontaVista Software, Inc.
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (c) 2005 TimeSys Corporation 
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ * March 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <asm/system.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <linux/interrupt.h>
+#include "generic.h"
+#include <asm/serial.h>
+#include <asm/arch/imx21fb.h>
+
+#if defined(CONFIG_CIRRUS)
+static struct resource cs8900_resources[] = {
+    [0] = {
+        .start  = CSB535_ETH_PHYS,
+        .end    = CSB535_ETH_PHYS + CSB535_ETH_SIZE - 1,
+        .flags  = IORESOURCE_MEM,
+    },
+    [1] = {
+        .start  = CSB535_ETH_IRQ,
+        .end    = CSB535_ETH_IRQ,
+        .flags  = IORESOURCE_IRQ,
+    },
+};
+
+static struct platform_device cs8900_device = {
+    .name            = "cs8900",
+    .id              = 0,
+    .num_resources   = ARRAY_SIZE(cs8900_resources),
+    .resource        = cs8900_resources,
+};
+#endif /* defined(CONFIG_CIRRUS) */
+
+/* TODO, figure out correct IRQ */
+static struct resource cpuvers_resources[] = {
+	[0] = {
+		.start	= IMX21_CS1_VIRT+0x400000,
+		.end	= IMX21_CS1_VIRT+0x400000 + 2,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+	    .start	= 0,
+		.end	= 0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device cpuvers_device = {
+	.name		= "imx21-cpuvers",
+	.num_resources	= ARRAY_SIZE(cpuvers_resources),
+	.resource	= cpuvers_resources,
+};
+
+/* TODO, figure out correct IRQ */
+static struct resource mx21cfg_resources[] = {
+	[0] = {
+		.start	= IMX21_CS1_VIRT+0x800000,
+		.end	= IMX21_CS1_VIRT+0x800000 + 2,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+	    .start	= 0,
+		.end	= 0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mx21cfg_device = {
+	.name		= "imx21-mx21cfg",
+	.num_resources	= ARRAY_SIZE(mx21cfg_resources),
+	.resource	= mx21cfg_resources,
+};
+
+static struct platform_device *devices[] __initdata = {
+#if defined(CONFIG_CIRRUS)
+	&cs8900_device,
+#endif
+	&cpuvers_device,
+	&mx21cfg_device,
+};
+
+static void __init
+fixup_mx21(struct machine_desc *desc, struct tag *tags,
+	   char **cmdline, struct meminfo *mi)
+
+{
+}
+
+static void csb535_lcd_power(int on)
+{
+	if(on)
+		MMIO_REG |= MMIO_LCDON;
+	else
+		MMIO_REG &= ~MMIO_LCDON;
+}
+
+// #define EXPERIMENTAL
+#ifdef EXPERIMENTAL
+
+/* LCD settings for Microtips MTG-F24160BFWNSEB-01 */
+static struct imxfb_mach_info csb535_fb_info __initdata = {
+	.pixclock	= 0, 		.bpp		= 1,
+	.xres		= 240,		.yres		= 160,
+
+	.hsync_len	= 0,		.vsync_len	= 0,
+	.left_margin	= 0,		.upper_margin	= 0,
+	.right_margin	= 0,		.lower_margin	= 0,
+
+	.lpcr	= LPCR_PBSIZ(LPCR_PBSIZ_PANEL_BUS_WIDTH_4) | LPCR_BPIX(LPCR_BPIX_BITS_PER_PIXEL_1) | PCR_SCLKSEL | PCR_PCD(7),
+	.lpccr	= 0,
+	.lscr	= 0, 
+
+	.lcd_power = csb535_lcd_power,
+};
+#else
+
+/* LCD settings for Sharp LCD LQ035Q7DB02 */
+static struct imxfb_mach_info csb535_fb_info __initdata = {
+	.pixclock	= 0, 		.bpp		= 16,
+	.xres		= 240,		.yres		= 320,
+
+	.hsync_len	= 1,		.vsync_len	= 1,
+	.left_margin	= 15,		.upper_margin	= 9,
+	.right_margin	= 6,		.lower_margin	= 7,
+
+	.lpcr	= LPCR_TFT | LPCR_COLOR | LPCR_PBSIZ(LPCR_PBSIZ_PANEL_BUS_WIDTH_8) | LPCR_BPIX(LPCR_BPIX_BITS_PER_PIXEL_16) | LPCR_PIXPOL | LPCR_OEPOL | LPCR_SCLKSEL | LPCR_SHARP | LPCR_PCD(3),
+	.lpccr	= LPCCR_CLS_HI_WIDTH(169) | LPCCR_SCR(LPCCR_SCR_PIXEL_CLOCK) | LPCCR_CC_EN | LPCCR_PW(0xff),
+	.lscr	= LSCR_PS_RISE_DELAY(0) | LSCR_CLS_RISE_DELAY(18) | LSCR_REV_TOGGLE_DELAY(3) | LSCR_GRAY2(0) | LSCR_GRAY1(0), 
+
+	.lcd_power = csb535_lcd_power,
+
+
+};
+#endif
+
+static void __init
+csb535_init(void)
+{
+	/* Configure the system clocks */
+	imx21_system_clk_init();	
+	
+	/* Set LCD display platform_data information*/
+	set_imx_fb_info(&csb535_fb_info);
+		
+	/* Enable the LCD display */
+	csb535_lcd_power(1);
+
+#if defined(CONFIG_CIRRUS)
+        imx21_gpio_mode(GPIO_PORTD | 31 | GPIO_IN);
+#endif
+	
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+static struct map_desc csb535_io_desc[] __initdata = {
+	/* virtual     physical    length      type */
+	{IMX21_CS0_VIRT, IMX21_CS0_PHYS, IMX21_CS0_SIZE, MT_DEVICE},
+	{IMX21_CS1_VIRT, IMX21_CS1_PHYS, IMX21_CS1_SIZE, MT_DEVICE},
+};
+
+static void __init
+csb535_map_io(void)
+{
+	imx21_map_io();
+	iotable_init(csb535_io_desc, ARRAY_SIZE(csb535_io_desc));
+}
+
+MACHINE_START(CSB535, "Cogent CSB535")
+	/* Maintainer: Jay Monkman <jtm@lopingdog.com> */
+	.phys_ram	= 0xc0000000,
+	.phys_io	= 0xc8000000,
+	.io_pg_offst	= ((0xe0200000) >> 18) & 0xfffc,
+	.boot_params	= 0xc0000100,
+	.fixup          = fixup_mx21,
+	.map_io		= csb535_map_io,
+	.init_irq	= imx21_init_irq,
+	.timer		= &imx21_timer,
+	.init_machine	= csb535_init,
+MACHINE_END
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-imx21/dma.c ipipe-2.6.14-imx21/arch/arm/mach-imx21/dma.c
--- linux-2.6.14/arch/arm/mach-imx21/dma.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/arch/arm/mach-imx21/dma.c	2008-02-21 22:08:59.000000000 +0100
@@ -0,0 +1,218 @@
+/*
+ *  linux/arch/arm/mach-imx21/dma.c
+ *
+ *  imx DMA registration and IRQ dispatching
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  03/03/2004 Sascha Hauer <sascha@saschahauer.de>
+ *             initial version heavily inspired by
+ *             linux/arch/arm/mach-pxa/dma.c
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/dma.h>
+
+static struct dma_channel {
+	char *name;
+	void (*irq_handler) (int, void *, struct pt_regs *);
+	void (*err_handler) (int, void *, struct pt_regs *);
+	void *data;
+} dma_channels[11];
+
+/* set err_handler to NULL to have the standard info-only error handler */
+int
+imx_request_dma(char *name, imx_dma_prio prio,
+		void (*irq_handler) (int, void *, struct pt_regs *),
+		void (*err_handler) (int, void *, struct pt_regs *), void *data)
+{
+#if 0
+    unsigned long flags;
+	int i, found = 0;
+
+	/* basic sanity checks */
+	if (!name || !irq_handler)
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	/* try grabbing a DMA channel with the requested priority */
+	for (i = prio; i < prio + (prio == DMA_PRIO_LOW) ? 8 : 4; i++) {
+		if (!dma_channels[i].name) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		/* requested prio group is full, try hier priorities */
+		for (i = prio - 1; i >= 0; i--) {
+			if (!dma_channels[i].name) {
+				found = 1;
+				break;
+			}
+		}
+	}
+
+	if (found) {
+		DIMR &= ~(1 << i);
+		dma_channels[i].name = name;
+		dma_channels[i].irq_handler = irq_handler;
+		dma_channels[i].err_handler = err_handler;
+		dma_channels[i].data = data;
+	} else {
+		printk(KERN_WARNING "No more available DMA channels for %s\n",
+		       name);
+		i = -ENODEV;
+	}
+
+	local_irq_restore(flags);
+	return i;
+#else
+	return 0;
+	
+#endif
+}
+
+void
+imx_free_dma(int dma_ch)
+{
+#if 0
+        unsigned long flags;
+
+	if (!dma_channels[dma_ch].name) {
+		printk(KERN_CRIT
+		       "%s: trying to free channel %d which is already freed\n",
+		       __FUNCTION__, dma_ch);
+		return;
+	}
+
+	local_irq_save(flags);
+	DIMR &= ~(1 << dma_ch);
+	dma_channels[dma_ch].name = NULL;
+	local_irq_restore(flags);
+#endif
+}
+
+static irqreturn_t
+dma_err_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+#if 0
+	int i;
+	struct dma_channel *channel;
+	unsigned int err_mask = DBTOSR | DRTOSR | DSESR | DBOSR;
+
+	for (i = 0; i < 11; i++) {
+		channel = &dma_channels[i];
+
+		if ( (err_mask & 1<<i) && channel->name && channel->err_handler) {
+			channel->err_handler(i, channel->data, regs);
+			continue;
+		}
+
+		if (DBTOSR & (1 << i)) {
+			printk(KERN_WARNING
+			       "Burst timeout on channel %d (%s)\n",
+			       i, channel->name);
+			DBTOSR |= (1 << i);
+		}
+		if (DRTOSR & (1 << i)) {
+			printk(KERN_WARNING
+			       "Request timeout on channel %d (%s)\n",
+			       i, channel->name);
+			DRTOSR |= (1 << i);
+		}
+		if (DSESR & (1 << i)) {
+			printk(KERN_WARNING
+			       "Transfer timeout on channel %d (%s)\n",
+			       i, channel->name);
+			DSESR |= (1 << i);
+		}
+		if (DBOSR & (1 << i)) {
+			printk(KERN_WARNING
+			       "Buffer overflow timeout on channel %d (%s)\n",
+			       i, channel->name);
+			DBOSR |= (1 << i);
+		}
+		DISR = (1 << i);
+	}
+#endif	
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t
+dma_irq_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+#if 0
+	int i, disr = DISR;
+
+	for (i = 0; i < 11; i++) {
+		if (disr & (1 << i)) {
+			struct dma_channel *channel = &dma_channels[i];
+			if (channel->name && channel->irq_handler) {
+				channel->irq_handler(i, channel->data, regs);
+			} else {
+				/*
+				 * IRQ for an unregistered DMA channel:
+				 * let's clear the interrupts and disable it.
+				 */
+				printk(KERN_WARNING
+				       "spurious IRQ for DMA channel %d\n", i);
+			}
+		}
+	}
+	DISR = disr;
+#endif
+	return IRQ_HANDLED;
+}
+
+static int __init
+imx_dma_init(void)
+{
+#if 0
+	int ret;
+
+	/* reset DMA module */
+	DCR = DCR_DRST;
+
+	ret = request_irq(DMA_INT, dma_irq_handler, 0, "DMA", NULL);
+	if (ret) {
+		printk(KERN_CRIT "Wow!  Can't register IRQ for DMA\n");
+		return ret;
+	}
+
+	ret = request_irq(DMA_ERR, dma_err_handler, 0, "DMA", NULL);
+	if (ret) {
+		printk(KERN_CRIT "Wow!  Can't register ERRIRQ for DMA\n");
+		free_irq(DMA_INT, NULL);
+	}
+
+	/* enable DMA module */
+	DCR = DCR_DEN;
+
+	/* clear all interrupts */
+	DISR = 0x3ff;
+
+	/* enable interrupts */
+	DIMR = 0;
+
+	return ret;
+#else
+	return 0;
+#endif
+}
+
+arch_initcall(imx_dma_init);
+
+EXPORT_SYMBOL(imx_request_dma);
+EXPORT_SYMBOL(imx_free_dma);
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-imx21/generic.c ipipe-2.6.14-imx21/arch/arm/mach-imx21/generic.c
--- linux-2.6.14/arch/arm/mach-imx21/generic.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/arch/arm/mach-imx21/generic.c	2008-02-21 22:08:59.000000000 +0100
@@ -0,0 +1,459 @@
+/*
+ *  arch/arm/mach-imx21/generic.c
+ *
+ *  author: Sascha Hauer
+ *  Created: april 20th, 2004
+ *  Copyright: Synertronixx GmbH
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * Modified By: Stephen Donecker (sdonecker@sbcglobal.net)
+ *
+ * Common code for i.MX machines
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/hardware.h>
+
+#include <asm/mach/map.h>
+
+#include <asm-arm/arch-imx21/imx21fb.h>
+
+/* List current CRM register contents */
+#define DEBUG_CRM 1
+
+void imx21_gpio_mode(int gpio_mode);
+void imx_set_enet_irq(void);
+void imx_clear_enet_irq(void);
+void imx21_system_clk_init(void);
+
+void imx21_gpio_mode(int gpio_mode)
+{
+	unsigned int pin = gpio_mode & GPIO_PIN_MASK;
+	unsigned int port = (gpio_mode & GPIO_PORT_MASK) >> GPIO_PORT_POS;
+	unsigned int ocr = (gpio_mode & GPIO_OCR_MASK) >> GPIO_OCR_POS;
+	unsigned int tmp;
+
+	/* Pullup enable */
+	if(gpio_mode & GPIO_PU_MASK)
+		PUEN(port) |= (1<<pin);
+	else
+		PUEN(port) &= ~(1<<pin);
+
+	/* Data direction */
+	if(gpio_mode & GPIO_DIR_MASK)
+		DDIR(port) |= (1<<pin);
+	else
+		DDIR(port) &= ~(1<<pin);
+
+	/* Primary function, alternate function, or GPIO */
+        switch(gpio_mode & GPIO_FUNC_MASK)
+	{
+		case GPIO_PF:
+			GIUS(port) &= ~(1<<pin);
+			GPR(port) &= ~(1<<pin);
+			break;
+		case GPIO_AF:
+			GIUS(port) &= ~(1<<pin);
+			GPR(port) |= (1<<pin);
+			break;
+		case GPIO_GP:
+			GIUS(port) |= (1<<pin);
+			/* GPR register: don't care when GIUS set to GPIO */
+			break;
+		default:
+			GIUS(port) &= ~(1<<pin);
+			GPR(port) &= ~(1<<pin);
+	}
+	
+	if(pin<16) {
+		tmp = OCR1(port);
+		tmp &= ~( 3<<(pin*2));
+		tmp |= (ocr << (pin*2));
+		OCR1(port) = tmp;
+
+		if( gpio_mode &	GPIO_AOUT )
+			ICONFA1(port) &= ~( 3<<(pin*2));
+		if( gpio_mode &	GPIO_BOUT )
+			ICONFB1(port) &= ~( 3<<(pin*2));
+	} else {
+		tmp = OCR2(port);
+		tmp &= ~( 3<<((pin-16)*2));
+		tmp |= (ocr << ((pin-16)*2));
+		OCR2(port) = tmp;
+
+		if( gpio_mode &	GPIO_AOUT )
+			ICONFA2(port) &= ~( 3<<((pin-16)*2));
+		if( gpio_mode &	GPIO_BOUT )
+			ICONFB2(port) &= ~( 3<<((pin-16)*2));
+	}
+}
+EXPORT_SYMBOL(imx21_gpio_mode);
+
+void imx_set_enet_irq()
+{
+    IMR(GPIO_E) |= NET_IRQ_BIT;
+    DDIR(GPIO_E) &= ~NET_IRQ_BIT;
+}
+
+void imx_clr_enet_irq()
+{
+    ISR(GPIO_E) = NET_IRQ_BIT;
+}
+
+EXPORT_SYMBOL(imx_clr_enet_irq);
+
+void imx21_system_clk_init()
+{
+	/*
+	 * System clock initialization
+	 *
+	 * The following register settings are similar to the ones currently
+	 * configured in the Freescale distributions of Redboot and Grub. 
+	 * All common clock settings should go here and specific settings should
+	 * go in their respective drivers. 
+	 */
+	
+	printk("Initializing system clocks\n");
+#if 1 
+	/* Enable the frequency premultiplier (FPM) to multiply by 512 */
+	CRM_CSCR |= CSCR_FPM_EN;
+	
+	/* Select the FPM output as the input to the MPLL and the SPLL */
+	CRM_CSCR &= ~(CSCR_MCU_SEL | CSCR_SP_SEL);
+	
+	/* Enable the MPLL and the SPLL */
+	CRM_CSCR |= (CSCR_MPEN | CSCR_SPEN);
+
+	/*
+	 * Set the MPLL so the output frequency is 266MHz by setting 
+	 * PD=0, MFD=123, MFI=7, and MFN=115 when fref=32.768kHz
+	 */
+#warning "Changed by JTM"
+//	CRM_MPCTL0 = (MPCTL0_PD(0) | MPCTL0_MFD(123) | MPCTL0_MFI(7) | MPCTL0_MFN(115));
+
+	/* Set the prescaler (PRESC) to divide by 1 */
+	CRM_CSCR &= ~CSCR_PRESC_MASK;
+	CRM_CSCR |= CSCR_PRESC(0);	
+
+	/* Enable the peripheral clock divider (IPDIV) to divide by 2 */
+	CRM_CSCR |= CSCR_IPDIV; 
+
+	/* Set the system bus clock divider (BCLKDIV) to divide by 2 */
+//	CRM_CSCR &= ~CSCR_BCLKDIV_MASK;
+	CRM_CSCR |= CSCR_BCLKDIV(1);
+
+#warning "Changed by JTM"
+	/* Set the peripheral clock divider 1 (PERDIV1) to divide by 6 */
+//	CRM_PCDR1 &= ~PCDR1_PERDIV1_MASK;
+//	CRM_PCDR1 |= PCDR1_PERDIV1(5); 
+
+	/* Enable HCLK input to the BROM module */
+	CRM_PCCR0 |= PCCR0_HCLK_BROM_EN;
+
+	/* Restart the MPLL and wait for the CSCR_MPLL_RESTART bit to clear */
+	CRM_CSCR |= CSCR_MPLL_RESTART;
+	while (CRM_CSCR & CSCR_MPLL_RESTART)
+	    ;
+	
+	/* 
+	 * Set the SPLL so the output frequency is 288MHz by setting
+	 * PD=0, MFD=626, MFI=8, and MFN=365 when fref=32.768kHz
+	 */
+	CRM_SPCTL0 = (SPCTL0_PD(0) | SPCTL0_MFD(626) | SPCTL0_MFI(8) | SPCTL0_MFN(365)); 
+	
+	/* Restart the SPLL and wait for the CSCR_SPLL_RESTART bit to clear */
+	CRM_CSCR |= CSCR_SPLL_RESTART;
+	while (CRM_CSCR & CSCR_SPLL_RESTART)
+	    ;
+	
+	/* Set the peripheral clock divider 3 (PERDIV3) to divide by 6 */
+	CRM_PCDR1 &= ~PCDR1_PERDIV3_MASK;
+	CRM_PCDR1 |= PCDR1_PERDIV3(5);
+#endif
+#if DEBUG_CRM
+	/* Let's take a look at the current CRM register settings */
+	printk("CRM_CSCR: 0x%08x\n",CRM_CSCR);
+	printk("CRM_MPCTL0: 0x%08x\n",CRM_MPCTL0);
+	printk("CRM_MPCTL1: 0x%08x\n",CRM_MPCTL1);
+	printk("CRM_SPCTL0: 0x%08x\n",CRM_SPCTL0);
+	printk("CRM_SPCTL1: 0x%08x\n",CRM_SPCTL1);
+	printk("CRM_OSC26MCTL: 0x%08x\n",CRM_OSC26MCTL);
+	printk("CRM_PCDR0: 0x%08x\n",CRM_PCDR0);
+	printk("CRM_PCDR1: 0x%08x\n",CRM_PCDR1);
+	printk("CRM_PCCR0: 0x%08x\n",CRM_PCCR0);
+	printk("CRM_PCCR1: 0x%08x\n",CRM_PCCR1);
+	printk("CRM_CCSR: 0x%08x\n",CRM_CCSR);
+	printk("CRM_WKGDCTL: 0x%08x\n",CRM_WKGDCTL);
+#endif
+	
+}
+
+/*
+ *  get the system pll clock in Hz
+ *
+ *                  mfi + mfn / (mfd +1)
+ *  f = 2 * f_ref * --------------------
+ *                        pd + 1
+ */
+
+/* TODO: Remove hardcoded values and write routines to retrieve all clk info. */
+static unsigned int imx_decode_pll(unsigned int pll)
+{
+	u32 mfi = (pll >> 10) & 0xf;
+	u32 mfn = pll & 0x3ff;
+	u32 mfd = (pll >> 16) & 0x3ff;
+	u32 pd =  (pll >> 26) & 0xf;
+	u32 f_ref = (CRM_CSCR & CSCR_MCU_SEL) ? 26000000 : (CLK32 * 512);
+
+	mfi = mfi <= 5 ? 5 : mfi;
+
+	return (2 * (f_ref>>10) * ( (mfi<<10) + (mfn<<10) / (mfd+1) )) / (pd+1);
+}
+
+unsigned int imx_get_system_clk(void)
+{
+	return imx_decode_pll(CRM_SPCTL0);
+}
+EXPORT_SYMBOL(imx_get_system_clk);
+
+unsigned int imx_get_mcu_clk(void)
+{
+	return imx_decode_pll(CRM_MPCTL0);
+}
+EXPORT_SYMBOL(imx_get_mcu_clk);
+
+/*
+ *  get peripheral clock 1 ( UART[12], Timer[12], PWM )
+ */
+unsigned int imx_get_perclk1(void)
+{
+	return imx_get_system_clk() / (((CRM_PCDR1 & PCDR1_PERDIV1_MASK) >> PCDR1_PERDIV1_POS)+1);
+}
+EXPORT_SYMBOL(imx_get_perclk1);
+
+/*
+ *  get peripheral clock 2 ( SDHC, CSPI )
+ */
+unsigned int imx_get_perclk2(void)
+{
+	return imx_get_system_clk() / (((CRM_PCDR1 & PCDR1_PERDIV2_MASK) >> PCDR1_PERDIV2_POS)+1);
+}
+EXPORT_SYMBOL(imx_get_perclk2);
+
+/*
+ *  get peripheral clock 3 ( LCDC )
+ */
+unsigned int imx_get_perclk3(void)
+{
+	return imx_get_system_clk() / (((CRM_PCDR1 & PCDR1_PERDIV3_MASK) >> PCDR1_PERDIV3_POS)+1);
+}
+EXPORT_SYMBOL(imx_get_perclk3);
+
+/*
+ *  get peripheral clock 4 (CSI)
+ */
+unsigned int imx_get_perclk4(void)
+{
+	return imx_get_system_clk() / (((CRM_PCDR1 & PCDR1_PERDIV4_MASK) >> PCDR1_PERDIV4_POS)+1);
+}
+
+EXPORT_SYMBOL(imx_get_perclk4);
+
+/*
+ *  get hclk ( SDRAM, CSI, Memory Stick, I2C, DMA )
+ */
+#if 0
+unsigned int imx_get_hclk(void)
+{
+	return imx_get_system_clk() / (((CSCR>>10) & 0xf)+1);
+}
+EXPORT_SYMBOL(imx_get_hclk);
+
+#endif
+
+#if 0
+static struct resource imx_mmc_resources[] = {
+	[0] = {
+		.start	= 0x10013000,
+		.end	= 0x100130FF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= (SDHC_INT),
+		.end	= (SDHC_INT),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device imx_mmc_device = {
+	.name		= "imx-mmc",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(imx_mmc_resources),
+	.resource	= imx_mmc_resources,
+};
+
+#endif
+
+static struct resource imx21_uart1_resources[] = {
+	[0] = {
+		.start	= 0x1000A000,
+		.end	= 0x1000A0FF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= (INT_UART1),
+		.end	= (INT_UART1),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device imx21_uart1_device = {
+	.name		= "imx21-uart",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(imx21_uart1_resources),
+	.resource	= imx21_uart1_resources,
+};
+
+static struct resource imx21_uart2_resources[] = {
+	[0] = {
+		.start	= 0x1000B000,
+		.end	= 0x1000B0FF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= (INT_UART2),
+		.end	= (INT_UART2),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device imx21_uart2_device = {
+	.name		= "imx21-uart",
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(imx21_uart2_resources),
+	.resource	= imx21_uart2_resources,
+};
+
+
+static struct resource imx21_uart3_resources[] = {
+	[0] = {
+		.start	= 0x1000C000,
+		.end	= 0x1000C0FF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= (INT_UART3),
+		.end	= (INT_UART3),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device imx21_uart3_device = {
+	.name		= "imx21-uart",
+	.id		= 2,
+	.num_resources	= ARRAY_SIZE(imx21_uart3_resources),
+	.resource	= imx21_uart3_resources,
+};
+
+static struct resource imx21_uart4_resources[] = {
+	[0] = {
+		.start	= 0x1000a000,
+		.end	= 0x1000a0FF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= (INT_UART4),
+		.end	= (INT_UART4),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device imx21_uart4_device = {
+	.name		= "imx21-uart",
+	.id		= 3,
+	.num_resources	= ARRAY_SIZE(imx21_uart4_resources),
+	.resource	= imx21_uart4_resources,
+};
+
+static struct imxfb_mach_info imx_fb_info;
+
+void __init set_imx_fb_info(struct imxfb_mach_info *hard_imx_fb_info)
+{
+	memcpy(&imx_fb_info,hard_imx_fb_info,sizeof(struct imxfb_mach_info));
+}
+EXPORT_SYMBOL(set_imx_fb_info);
+
+static struct resource imxfb_resources[] = {
+	[0] = {
+		.start	= 0x10021000,
+		.end	= 0x100210ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= INT_LCDC,
+		.end	= INT_LCDC,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 fb_dma_mask = ~(u64)0;
+
+static struct platform_device imxfb_device = {
+	.name		= "imx-fb",
+	.id		= 0,
+	.dev		= {
+ 		.platform_data	= &imx_fb_info,
+		.dma_mask	= &fb_dma_mask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(imxfb_resources),
+	.resource	= imxfb_resources,
+};
+
+static struct platform_device *devices[] __initdata = {
+    /* 	&imx_mmc_device, */
+	&imxfb_device,
+	&imx21_uart1_device,
+	&imx21_uart2_device,
+	// add these later
+	//	&imx21_uart3_device,
+	//	&imx21_uart4_device,
+};
+
+static struct map_desc imx21_io_desc[] __initdata = {
+	/* virtual     physical    length      type */
+    {IMX21_IO_BASE, IMX21_IO_PHYS, IMX21_IO_SIZE, MT_DEVICE},
+    //    {IMX21_EMI_VIRT, IMX21_EMI_PHYS, IMX21_EMI_SIZE, MT_DEVICE},
+};
+
+void __init
+imx21_map_io(void)
+{
+	iotable_init(imx21_io_desc, ARRAY_SIZE(imx21_io_desc));
+}
+
+static int __init imx21_init(void)
+{
+    return platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+subsys_initcall(imx21_init);
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-imx21/generic.h ipipe-2.6.14-imx21/arch/arm/mach-imx21/generic.h
--- linux-2.6.14/arch/arm/mach-imx21/generic.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/arch/arm/mach-imx21/generic.h	2008-02-21 22:08:59.000000000 +0100
@@ -0,0 +1,19 @@
+/*
+ *  linux/arch/arm/mach-imx21/generic.h
+ *
+ * Author:	Sascha Hauer <sascha@saschahauer.de>
+ * Copyright:	Synertronixx GmbH
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+extern void __init imx21_map_io(void);
+extern void __init imx21_init_irq(void);
+
+struct sys_timer;
+extern struct sys_timer imx21_timer;
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-imx21/irq.c ipipe-2.6.14-imx21/arch/arm/mach-imx21/irq.c
--- linux-2.6.14/arch/arm/mach-imx21/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/arch/arm/mach-imx21/irq.c	2008-02-21 22:08:59.000000000 +0100
@@ -0,0 +1,278 @@
+/*
+ *  linux/arch/arm/mach-imx21/irq.c
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
+ *  Modified By: Ron Melvin (ron.melvin@timesys.com)
+ *  Copyright (C) 2005, TimeSys Corporation 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  03/03/2004   Sascha Hauer <sascha@saschahauer.de>
+ *               Copied from the motorola bsp package and added gpio demux
+ *               interrupt handler
+ *
+ * April 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board with Xenomai by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ * 
+  */
+#include <linux/init.h>
+extern int x1;
+#include <linux/list.h>
+extern int x2;
+#include <linux/timer.h>
+extern int x3;
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include <asm/mach/irq.h>
+
+/*
+ *
+ * We simply use the ENABLE DISABLE registers inside of the IMX21
+ * to turn on/off specific interrupts.  FIXME- We should
+ * also add support for the accelerated interrupt controller
+ * by putting offets to irq jump code in the appropriate
+ * places.
+ *
+ */
+
+#define INTENNUM_OFF              0x8
+#define INTDISNUM_OFF             0xC
+
+#define VA_AITC_BASE              IO_ADDRESS(MX2ADS_AITC_BASE)
+#define IMX21_AITC_INTDISNUM       (VA_AITC_BASE + INTDISNUM_OFF)
+#define IMX21_AITC_INTENNUM        (VA_AITC_BASE + INTENNUM_OFF)
+
+#if 0
+#define DEBUG_IRQ(fmt...)	printk(fmt)
+#else
+#define DEBUG_IRQ(fmt...)	do { } while (0)
+#endif
+
+static void
+imx21_mask_irq(unsigned int irq)
+{
+	__raw_writel(irq, IMX21_AITC_INTDISNUM);
+}
+
+static void
+imx21_unmask_irq(unsigned int irq)
+{
+	__raw_writel(irq, IMX21_AITC_INTENNUM);
+}
+
+static int
+imx21_gpio_irq_type(unsigned int _irq, unsigned int type)
+{
+	unsigned int irq_type = 0, irq, reg, bit;
+
+	irq = _irq - IRQ_GPIOA(0);
+	reg = irq >> 5;
+	bit = 1 << (irq % 32);
+
+	if (type == IRQT_PROBE) {
+		/* Don't mess with enabled GPIOs using preconfigured edges or
+		   GPIOs set to alternate function during probe */
+		/* TODO: support probe */
+//              if ((GPIO_IRQ_rising_edge[idx] | GPIO_IRQ_falling_edge[idx]) &
+//                  GPIO_bit(gpio))
+//                      return 0;
+//              if (GAFR(gpio) & (0x3 << (((gpio) & 0xf)*2)))
+//                      return 0;
+//              type = __IRQT_RISEDGE | __IRQT_FALEDGE;
+	}
+
+	GIUS(reg) |= bit;
+	DDIR(reg) &= ~(bit);
+
+	DEBUG_IRQ("setting type of irq %d to ", _irq);
+
+	if (type & __IRQT_RISEDGE) {
+		DEBUG_IRQ("rising edges\n");
+		irq_type = 0x0;
+	}
+	if (type & __IRQT_FALEDGE) {
+		DEBUG_IRQ("falling edges\n");
+		irq_type = 0x1;
+	}
+	if (type & __IRQT_LOWLVL) {
+		DEBUG_IRQ("low level\n");
+		irq_type = 0x3;
+	}
+	if (type & __IRQT_HIGHLVL) {
+		DEBUG_IRQ("high level\n");
+		irq_type = 0x2;
+	}
+
+	if (irq % 32 < 16) {
+		ICR1(reg) = (ICR1(reg) & ~(0x3 << ((irq % 16) * 2))) |
+		    (irq_type << ((irq % 16) * 2));
+	} else {
+		ICR2(reg) = (ICR2(reg) & ~(0x3 << ((irq % 16) * 2))) |
+		    (irq_type << ((irq % 16) * 2));
+	}
+
+	return 0;
+
+}
+
+static void
+imx21_gpio_ack_irq(unsigned int irq)
+{
+	DEBUG_IRQ("%s: irq %d  isr %d\n", __FUNCTION__, irq,
+                  IRQ_TO_REG(irq));
+	ISR(IRQ_TO_REG(irq)) |= 1 << ((irq - IRQ_GPIOA(0)) % 32);
+}
+
+static void
+imx21_gpio_mask_irq(unsigned int irq)
+{
+	DEBUG_IRQ("%s: irq %d\n", __FUNCTION__, irq);
+	IMR(IRQ_TO_REG(irq)) &= ~( 1 << ((irq - IRQ_GPIOA(0)) % 32));
+}
+
+static void
+imx21_gpio_unmask_irq(unsigned int irq)
+{
+	DEBUG_IRQ("%s: irq %d\n", __FUNCTION__, irq);
+	IMR(IRQ_TO_REG(irq)) |= 1 << ((irq - IRQ_GPIOA(0)) % 32);
+        PMASK = PMASK | (1 << IRQ_TO_REG(irq));
+}
+
+static void
+imx21_gpio_handler(unsigned int irq_unused, struct irqdesc *desc,
+                   struct pt_regs *regs)
+{
+    unsigned int mask;
+    unsigned int port;
+    unsigned int irq_base;
+    unsigned int irq = 0;
+
+    for (port = 0; port < 6; port++) {
+        if (ISR(port) & IMR(port)) {
+            break;
+        }
+    }
+
+    mask = ISR(port);
+    irq_base = IRQ_GPIOA(0) + (port * 32);
+
+    desc = irq_desc + irq_base;
+    while (mask) {
+        if (mask & 1) {
+            DEBUG_IRQ("handling irq %d (port %d)\n", irq, port);
+            desc_handle_irq(irq + irq_base, desc, regs);
+            ISR(port) = (1 << irq);
+        }
+        irq++;
+        desc++;
+        mask >>= 1;
+    }
+}
+
+#ifdef CONFIG_IPIPE
+void __ipipe_mach_demux_irq(unsigned irq_unused, struct pt_regs *regs)
+{
+    struct irqdesc *desc, *desc_unused = irq_desc + irq_unused;
+    unsigned int mask;
+    unsigned int port;
+    unsigned int irq_base;
+    unsigned int irq = 0;
+
+    for (port = 0; port < 6; port++) {
+        if (ISR(port) & IMR(port)) {
+            break;
+        }
+    }
+
+    mask = ISR(port);
+    irq_base = IRQ_GPIOA(0) + (port * 32);
+
+    desc = irq_desc + irq_base;
+    while (mask) {
+        if (mask & 1) {
+            DEBUG_IRQ("handling irq %d (port %d)\n", irq, port);
+	    __ipipe_handle_irq(irq + irq_base, regs);	    
+            ISR(port) = (1 << irq);
+        }
+        irq++;
+        desc++;
+        mask >>= 1;
+    }
+
+    desc_unused->chip->unmask(irq_unused);
+}
+#endif /* CONFIG_IPIPE */
+
+static struct irqchip imx21_gpio_chip = {
+	.ack = imx21_gpio_ack_irq,
+	.mask = imx21_gpio_mask_irq,
+	.unmask = imx21_gpio_unmask_irq,
+	.set_type = imx21_gpio_irq_type,
+};
+
+static struct irqchip imx21_internal_chip = {
+	.ack = imx21_mask_irq,
+	.mask = imx21_mask_irq,
+	.unmask = imx21_unmask_irq,
+};
+
+void __init
+imx21_init_irq(void)
+{
+	unsigned int irq;
+
+	DEBUG_IRQ("Initializing imx21 interrupts\n");
+
+	/* Mask all interrupts initially */
+	IMR(0) = 0;
+	IMR(1) = 0;
+	IMR(2) = 0;
+	IMR(3) = 0;
+	IMR(4) = 0;
+	IMR(5) = 0;
+
+	/* Define priorities for all interrupts lines */
+	AITC_NIPRIORITY7 = 0x00000000 ;
+	AITC_NIPRIORITY6 = 0x00000000 ;	
+	AITC_NIPRIORITY5 = 0x00000000 ;	
+	AITC_NIPRIORITY4 = 0x00000000 ;	
+	AITC_NIPRIORITY3 = 0x00000f00 ;
+	AITC_NIPRIORITY2 = 0x00000000 ;	
+	AITC_NIPRIORITY1 = 0x00000000 ;	
+	AITC_NIPRIORITY0 = 0x00000000 ;	
+
+	for (irq = 0; irq < IMX21_IRQS; irq++) {
+		set_irq_chip(irq, &imx21_internal_chip);
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+	for (irq = IRQ_GPIOA(0); irq < IRQ_GPIOF(32); irq++) {
+		set_irq_chip(irq, &imx21_gpio_chip);
+		set_irq_handler(irq, do_edge_IRQ);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+	set_irq_chained_handler(INT_GPIO, imx21_gpio_handler);
+
+	/* Disable all interrupts initially. */
+	/* In IMX21 this is done in the bootloader. */
+}
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-imx21/leds-mx2ads.c ipipe-2.6.14-imx21/arch/arm/mach-imx21/leds-mx2ads.c
--- linux-2.6.14/arch/arm/mach-imx21/leds-mx2ads.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/arch/arm/mach-imx21/leds-mx2ads.c	2008-02-21 22:08:59.000000000 +0100
@@ -0,0 +1,54 @@
+/*
+ * linux/arch/arm/mach-imx21/leds-mx2ads.c
+ *
+ * Copyright (c) 2004 Sascha Hauer <sascha@saschahauer.de>
+ *
+ * Original (leds-footbridge.c) by Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/hardware.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+#include "leds.h"
+
+/*
+ * The MX1ADS Board has only one usable LED,
+ * so select only the timer led or the
+ * cpu usage led
+ */
+void
+mx1ads_leds_event(led_event_t ledevt)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	switch (ledevt) {
+#ifdef CONFIG_LEDS_CPU
+	case led_idle_start:
+		DR(0) &= ~(1<<2);
+		break;
+
+	case led_idle_end:
+		DR(0) |= 1<<2;
+		break;
+#endif
+
+#ifdef CONFIG_LEDS_TIMER
+	case led_timer:
+		DR(0) ^= 1<<2;
+#endif
+	default:
+		break;
+	}
+	local_irq_restore(flags);
+}
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-imx21/leds.c ipipe-2.6.14-imx21/arch/arm/mach-imx21/leds.c
--- linux-2.6.14/arch/arm/mach-imx21/leds.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/arch/arm/mach-imx21/leds.c	2008-02-21 22:08:59.000000000 +0100
@@ -0,0 +1,31 @@
+/*
+ * linux/arch/arm/mach-imx21/leds.h
+ *
+ * Copyright (C) 2004 Sascha Hauer <sascha@saschahauer.de>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+
+#include "leds.h"
+
+static int __init
+leds_init(void)
+{
+	if (machine_is_mx1ads()) {
+		leds_event = mx1ads_leds_event;
+	}
+
+	return 0;
+}
+
+__initcall(leds_init);
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-imx21/leds.h ipipe-2.6.14-imx21/arch/arm/mach-imx21/leds.h
--- linux-2.6.14/arch/arm/mach-imx21/leds.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/arch/arm/mach-imx21/leds.h	2008-02-21 22:08:59.000000000 +0100
@@ -0,0 +1,9 @@
+/*
+ * include/asm-arm/arch-imx21/leds.h
+ *
+ * Copyright (c) 2004 Sascha Hauer <sascha@saschahauer.de>
+ *
+ * blinky lights for IMX-based systems
+ *
+ */
+extern void mx1ads_leds_event(led_event_t evt);
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-imx21/mx2ads.c ipipe-2.6.14-imx21/arch/arm/mach-imx21/mx2ads.c
--- linux-2.6.14/arch/arm/mach-imx21/mx2ads.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/arch/arm/mach-imx21/mx2ads.c	2008-02-21 22:08:59.000000000 +0100
@@ -0,0 +1,210 @@
+/*
+ * arch/arm/mach-imx21/mx2ads.c
+ *
+ * Initially based on:
+ *	linux-2.6.7-imx/arch/arm/ mach-imx /scb9328.c
+ *	Copyright (c) 2004 Sascha Hauer <sascha@saschahauer.de>
+ *
+ * 2004 (c) MontaVista Software, Inc.
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (c) 2005 TimeSys Corporation 
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <asm/system.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <linux/interrupt.h>
+#include "generic.h"
+#include <asm/serial.h>
+#include <asm/arch/imx21fb.h>
+
+static struct resource enet_resources[] = {
+	[0] = {
+		.start	= IMX21_CS1_VIRT,
+		.end	= IMX21_CS1_VIRT + 16,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+	        .start	= INT_UART3,
+		.end	= INT_UART3,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device enet_device = {
+	.name		= "imx21-ethernet",
+	.num_resources	= ARRAY_SIZE(enet_resources),
+	.resource	= enet_resources,
+};
+
+/* TODO, figure out correct IRQ */
+static struct resource extuart_resources[] = {
+	[0] = {
+		.start	= IMX21_CS1_VIRT+0x200000,
+		.end	= IMX21_CS1_VIRT+0x200000 + 16,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+	    .start	= 0,
+		.end	= 0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device extuart_device = {
+	.name		= "imx21-ext-uart",
+	.num_resources	= ARRAY_SIZE(extuart_resources),
+	.resource	= extuart_resources,
+};
+
+/* TODO, figure out correct IRQ */
+static struct resource cpuvers_resources[] = {
+	[0] = {
+		.start	= IMX21_CS1_VIRT+0x400000,
+		.end	= IMX21_CS1_VIRT+0x400000 + 2,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+	    .start	= 0,
+		.end	= 0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device cpuvers_device = {
+	.name		= "imx21-cpuvers",
+	.num_resources	= ARRAY_SIZE(cpuvers_resources),
+	.resource	= cpuvers_resources,
+};
+
+/* TODO, figure out correct IRQ */
+static struct resource mx21cfg_resources[] = {
+	[0] = {
+		.start	= IMX21_CS1_VIRT+0x800000,
+		.end	= IMX21_CS1_VIRT+0x800000 + 2,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+	    .start	= 0,
+		.end	= 0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mx21cfg_device = {
+	.name		= "imx21-mx21cfg",
+	.num_resources	= ARRAY_SIZE(mx21cfg_resources),
+	.resource	= mx21cfg_resources,
+};
+
+static struct platform_device *devices[] __initdata = {
+	&enet_device,
+	&extuart_device,
+	&cpuvers_device,
+	&mx21cfg_device,
+};
+
+static void __init
+fixup_mx21(struct machine_desc *desc, struct tag *tags,
+	   char **cmdline, struct meminfo *mi)
+
+{
+}
+
+static void mx2ads_lcd_power(int on)
+{
+	if(on)
+		MMIO_REG |= MMIO_LCDON;
+	else
+		MMIO_REG &= ~MMIO_LCDON;
+}
+
+// #define EXPERIMENTAL
+#ifdef EXPERIMENTAL
+
+/* LCD settings for Microtips MTG-F24160BFWNSEB-01 */
+static struct imxfb_mach_info mx2ads_fb_info __initdata = {
+	.pixclock	= 0, 		.bpp		= 1,
+	.xres		= 240,		.yres		= 160,
+
+	.hsync_len	= 0,		.vsync_len	= 0,
+	.left_margin	= 0,		.upper_margin	= 0,
+	.right_margin	= 0,		.lower_margin	= 0,
+
+	.lpcr	= LPCR_PBSIZ(LPCR_PBSIZ_PANEL_BUS_WIDTH_4) | LPCR_BPIX(LPCR_BPIX_BITS_PER_PIXEL_1) | PCR_SCLKSEL | PCR_PCD(7),
+	.lpccr	= 0,
+	.lscr	= 0, 
+
+	.lcd_power = mx2ads_lcd_power,
+};
+#else
+
+/* LCD settings for Sharp LCD LQ035Q7DB02 */
+static struct imxfb_mach_info mx2ads_fb_info __initdata = {
+	.pixclock	= 0, 		.bpp		= 16,
+	.xres		= 240,		.yres		= 320,
+
+	.hsync_len	= 1,		.vsync_len	= 1,
+	.left_margin	= 15,		.upper_margin	= 9,
+	.right_margin	= 6,		.lower_margin	= 7,
+
+	.lpcr	= LPCR_TFT | LPCR_COLOR | LPCR_PBSIZ(LPCR_PBSIZ_PANEL_BUS_WIDTH_8) | LPCR_BPIX(LPCR_BPIX_BITS_PER_PIXEL_16) | LPCR_PIXPOL | LPCR_OEPOL | LPCR_SCLKSEL | LPCR_SHARP | LPCR_PCD(7),
+	.lpccr	= LPCCR_CLS_HI_WIDTH(169) | LPCCR_SCR(LPCCR_SCR_PIXEL_CLOCK) | LPCCR_CC_EN | LPCCR_PW(0xff),
+	.lscr	= LSCR_PS_RISE_DELAY(0) | LSCR_CLS_RISE_DELAY(18) | LSCR_REV_TOGGLE_DELAY(3) | LSCR_GRAY2(0) | LSCR_GRAY1(0), 
+
+	.lcd_power = mx2ads_lcd_power,
+};
+#endif
+
+static void __init
+mx2ads_init(void)
+{
+	/* Configure the system clocks */
+	imx21_system_clk_init();	
+	
+	/* Set LCD display platform_data information*/
+	set_imx_fb_info(&mx2ads_fb_info);
+		
+	/* Enable the LCD display */
+	mx2ads_lcd_power(1);
+	
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+static struct map_desc mx2ads_io_desc[] __initdata = {
+	/* virtual     physical    length      type */
+	{IMX21_CS0_VIRT, IMX21_CS0_PHYS, IMX21_CS0_SIZE, MT_DEVICE},
+	{IMX21_CS1_VIRT, IMX21_CS1_PHYS, IMX21_CS1_SIZE, MT_DEVICE},
+};
+
+static void __init
+mx2ads_map_io(void)
+{
+	imx21_map_io();
+	iotable_init(mx2ads_io_desc, ARRAY_SIZE(mx2ads_io_desc));
+}
+
+MACHINE_START(MX2ADS, "Motorola MX2ADS")
+	MAINTAINER("Timesys Inc.")
+	BOOT_MEM(0xc0000000, 0xc8000000, 0xe0200000)
+	BOOT_PARAMS(0xc0000100)
+        FIXUP(fixup_mx21)
+	MAPIO(mx2ads_map_io)
+	INITIRQ(imx21_init_irq)
+	.timer		= &imx21_timer,
+	INIT_MACHINE(mx2ads_init)
+MACHINE_END
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-imx21/time.c ipipe-2.6.14-imx21/arch/arm/mach-imx21/time.c
--- linux-2.6.14/arch/arm/mach-imx21/time.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/arch/arm/mach-imx21/time.c	2008-02-21 22:08:59.000000000 +0100
@@ -0,0 +1,241 @@
+/*
+ *  linux/arch/arm/mach-imx21/time.c
+ *
+ *  Copyright (C) 2000-2001 Deep Blue Solutions
+ *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
+ *
+ *  Modified By: Ron Melvin (ron.melvin@timesys.com)
+ *  Copyright (C) 2005 TimeSys Corporation *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * April 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board with Xenomai by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ *
+ * * 24.04.06 : modification of value __ipipe_mach_ticks_per_jiff
+ *              the value dependent of timer clock frequency and HZ constant
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/module.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/leds.h>
+#include <asm/irq.h>
+#include <asm/mach/time.h>
+
+#include <asm/arch/csb535.h>
+
+static unsigned long timer_reload;
+static unsigned long timer_interval;
+static unsigned long timer_lxlost;
+static int tscok;
+
+#ifdef CONFIG_IPIPE
+int __ipipe_mach_timerint = INT_GPT1;
+static unsigned long long __ipipe_mach_tsc;
+static DEFINE_SPINLOCK(timer_lock);
+int __ipipe_mach_timerstolen = 0;
+EXPORT_SYMBOL(__ipipe_mach_timerstolen);
+/*
+ * timer_frequency = 17'616'076,8 Hz
+ * ticks/jiffy = timer_freq / Hz
+ */
+unsigned int __ipipe_mach_ticks_per_jiffy = CLKPERCLK1 / HZ;
+EXPORT_SYMBOL(__ipipe_mach_ticks_per_jiffy);
+#endif /* CONFIG_IPIPE */
+
+/*
+ * Called with IRQ disabled from do_gettimeofday().
+ */
+static inline unsigned long imx_getticksoffset(void)
+{
+
+	if (!tscok)
+		return 0;
+	
+	//Return the value of Timer 1
+	return IMX21_TCN(GPT1);
+	
+}
+
+/*
+ * Reprogram the timer
+ */
+static inline void  set_dec(unsigned long reload)
+{
+
+	//Configure timer in a now state
+	IMX21_TCTL(GPT1) = 0 ;
+	//Load the compare value (next IRQ)
+	IMX21_TCMP(GPT1) = reload;
+	//Restart the timer (in free run mode (FRR))
+	IMX21_TCTL(GPT1) = TCTL_CLK_PCLK1 | TCTL_IRQ_COMP | TCTL_TEN | TCTL_FRR | TCTL_OM |TCTL_CC ;
+
+	timer_reload = reload;
+
+}
+
+#ifdef CONFIG_IPIPE
+void inline __ipipe_mach_acktimer(void)
+{
+	
+	/*
+	 * TODO : Could be optimize 
+	*/
+	if ( IMX21_TSTAT(GPT1) )
+	    IMX21_TSTAT(GPT1) = TSTAT_COMP;
+	
+}
+EXPORT_SYMBOL(__ipipe_mach_acktimer);
+
+unsigned long long __ipipe_mach_get_tsc(void)
+{
+	
+	unsigned long long result;
+	unsigned long flags;
+
+	spin_lock_irqsave_hw(&timer_lock, flags);
+	result = __ipipe_mach_tsc + imx_getticksoffset();
+	spin_unlock_irqrestore_hw(&timer_lock, flags);
+	return result;
+
+}
+EXPORT_SYMBOL(__ipipe_mach_get_tsc);
+
+void __ipipe_mach_set_dec(unsigned long reload)
+{
+	unsigned long ticks;
+	unsigned long flags;
+
+	spin_lock_irqsave_hw(&timer_lock, flags);
+	ticks = imx_getticksoffset();
+	__ipipe_mach_tsc += ticks;
+	set_dec(reload);
+	timer_lxlost += ticks;
+	spin_unlock_irqrestore_hw(&timer_lock, flags);
+
+}
+EXPORT_SYMBOL(__ipipe_mach_set_dec);
+
+void __ipipe_mach_release_timer(void)
+{
+       __ipipe_mach_set_dec(__ipipe_mach_ticks_per_jiffy);
+}
+EXPORT_SYMBOL(__ipipe_mach_release_timer);
+
+unsigned long __ipipe_mach_get_dec(void)
+{
+	unsigned ticks;
+	
+	ticks = IMX21_TCN(GPT1);
+
+	if (ticks < timer_reload) {
+		return timer_reload - ticks;
+	}
+	else {
+		return 0xffffffff + timer_reload - ticks;
+	}
+}
+EXPORT_SYMBOL(__ipipe_mach_get_dec);
+#endif /* CONFIG_IPIPE */
+
+unsigned long imx21_gettimeoffset(void)
+{
+
+	/*
+	 * Convert ticks to usecs
+	 */
+	return ((10000 * (timer_lxlost + imx_getticksoffset())) / __ipipe_mach_ticks_per_jiffy);
+		
+}
+
+static irqreturn_t
+imx21_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	write_seqlock(&xtime_lock);
+
+	timer_lxlost = 0;
+
+#ifdef CONFIG_IPIPE
+	/*
+	 * If Linux is the only domain, ack the timer and reprogram it
+	 */
+	if (!__ipipe_mach_timerstolen) {
+		__ipipe_mach_tsc += imx_getticksoffset();
+#else
+		if (IMX21_TSTAT(GPT1) ) {
+	    		IMX21_TSTAT(GPT1) = TSTAT_COMP;
+		}
+#endif
+		/*
+		 * Reprogram timer with "__ipipe_mach_ticks_per_jiffy";
+		 */
+		IMX21_TCTL(GPT1) = 0 ;
+		IMX21_TCMP(GPT1) = __ipipe_mach_ticks_per_jiffy;
+		IMX21_TCTL(GPT1) = TCTL_CLK_PCLK1 | TCTL_IRQ_COMP | TCTL_TEN | TCTL_FRR | TCTL_OM | TCTL_CC ;
+		
+#ifdef CONFIG_IPIPE
+	}
+#endif	
+
+	timer_tick(regs);
+	write_sequnlock(&xtime_lock);
+
+	return IRQ_HANDLED;
+
+}
+
+static struct irqaction imx21_timer_irq = {
+	.name		= "i.Mx21 Timer Tick",
+	.flags		= SA_INTERRUPT | SA_TIMER,
+	.handler	= imx21_timer_interrupt
+};
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+static void __init imx21_timer_init(void)
+{
+
+	/*
+	 * Configure all timers in a now state
+	 */
+	IMX21_TCTL(GPT1) = 0;
+	IMX21_TCTL(GPT2) = 0;
+	IMX21_TCTL(GPT3) = 0;
+	/*
+	 * Configure the timer
+         */
+	IMX21_TPRER(GPT1) = 0;
+
+	/*
+	 * Make irqs happen for the system timer
+	 */
+	setup_irq(INT_GPT1, &imx21_timer_irq);
+
+	/*
+         * Reprogram the timer and start it !
+	 */
+	set_dec(__ipipe_mach_ticks_per_jiffy);
+
+	tscok = 1;
+
+}
+
+struct sys_timer imx21_timer = {
+	.init		= imx21_timer_init,
+	.offset		= imx21_gettimeoffset,
+};
+
+
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-integrator/core.c ipipe-2.6.14-imx21/arch/arm/mach-integrator/core.c
--- linux-2.6.14/arch/arm/mach-integrator/core.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/mach-integrator/core.c	2008-02-21 22:08:59.000000000 +0100
@@ -2,6 +2,7 @@
  *  linux/arch/arm/mach-integrator/core.c
  *
  *  Copyright (C) 2000-2003 Deep Blue Solutions Ltd
+ *  Copyright (C) 2005 Stelian Pop.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2, as
@@ -148,53 +149,57 @@ EXPORT_SYMBOL(cm_control);
 /*
  * How long is the timer interval?
  */
-#define TIMER_INTERVAL	(TICKS_PER_uSEC * mSEC_10)
-#if TIMER_INTERVAL >= 0x100000
-#define TICKS2USECS(x)	(256 * (x) / TICKS_PER_uSEC)
-#elif TIMER_INTERVAL >= 0x10000
-#define TICKS2USECS(x)	(16 * (x) / TICKS_PER_uSEC)
-#else
 #define TICKS2USECS(x)	((x) / TICKS_PER_uSEC)
-#endif
 
 static unsigned long timer_reload;
+static unsigned long timer_interval;
+static unsigned long timer_lxlost;
+static int tscok;
+
+#ifdef CONFIG_IPIPE
+int __ipipe_mach_timerint = IRQ_TIMERINT1;
+static unsigned long long __ipipe_mach_tsc;
+static DEFINE_SPINLOCK(timer_lock);
+
+int __ipipe_mach_timerstolen = 0;
+EXPORT_SYMBOL(__ipipe_mach_timerstolen);
+#endif
 
 /*
- * Returns number of ms since last clock interrupt.  Note that interrupts
- * will have been disabled by do_gettimeoffset()
+ * Called with IRQ disabled from do_gettimeofday().
  */
-unsigned long integrator_gettimeoffset(void)
+static inline unsigned long integrator_getticksoffset(void)
 {
-	unsigned long ticks1, ticks2, status;
+	unsigned long ticks;
 
-	/*
-	 * Get the current number of ticks.  Note that there is a race
-	 * condition between us reading the timer and checking for
-	 * an interrupt.  We get around this by ensuring that the
-	 * counter has not reloaded between our two reads.
-	 */
-	ticks2 = readl(TIMER1_VA_BASE + TIMER_VALUE) & 0xffff;
-	do {
-		ticks1 = ticks2;
-		status = __raw_readl(VA_IC_BASE + IRQ_RAW_STATUS);
-		ticks2 = readl(TIMER1_VA_BASE + TIMER_VALUE) & 0xffff;
-	} while (ticks2 > ticks1);
+	if (!tscok)
+		return 0;
 
-	/*
-	 * Number of ticks since last interrupt.
-	 */
-	ticks1 = timer_reload - ticks2;
+	ticks = readl(TIMER1_VA_BASE + TIMER_VALUE) & 0xffff;
 
-	/*
-	 * Interrupt pending?  If so, we've reloaded once already.
-	 */
-	if (status & (1 << IRQ_TIMERINT1))
-		ticks1 += timer_reload;
+	if (ticks > timer_reload)
+		ticks = 0xffff + timer_reload - ticks;
+	else
+		ticks = timer_reload - ticks;
 
+	if (timer_interval < 0x10000)
+		return ticks;
+	else if (timer_interval < 0x100000)
+		return ticks * 16;
+	else
+		return ticks * 256;
+}
+
+/*
+ * Returns number of ms since last clock interrupt.  Note that interrupts
+ * will have been disabled by do_gettimeoffset()
+ */
+unsigned long integrator_gettimeoffset(void)
+{
 	/*
 	 * Convert the ticks to usecs
 	 */
-	return TICKS2USECS(ticks1);
+	return TICKS2USECS(timer_lxlost + integrator_getticksoffset());
 }
 
 /*
@@ -205,10 +210,22 @@ integrator_timer_interrupt(int irq, void
 {
 	write_seqlock(&xtime_lock);
 
+	timer_lxlost = 0;
+
+#ifdef CONFIG_IPIPE
 	/*
-	 * clear the interrupt
+	 * If Linux is the only domain, ack the timer and reprogram it
 	 */
-	writel(1, TIMER1_VA_BASE + TIMER_INTCLR);
+	if (!__ipipe_mach_timerstolen) {
+		__ipipe_mach_tsc += integrator_getticksoffset();
+#else
+		writel(1, TIMER1_VA_BASE + TIMER_INTCLR);
+#endif
+
+		writel(timer_reload, TIMER1_VA_BASE + TIMER_LOAD);
+#ifdef CONFIG_IPIPE
+	}
+#endif
 
 	/*
 	 * the clock tick routines are only processed on the
@@ -239,24 +256,30 @@ static struct irqaction integrator_timer
 	.handler	= integrator_timer_interrupt,
 };
 
-/*
- * Set up timer interrupt, and return the current time in seconds.
- */
-void __init integrator_time_init(unsigned long reload, unsigned int ctrl)
+static inline void set_dec(unsigned long reload)
 {
-	unsigned int timer_ctrl = TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC;
+	unsigned int ctrl = TIMER_CTRL_ENABLE | TIMER_CTRL_IE;
 
 	timer_reload = reload;
-	timer_ctrl |= ctrl;
+	timer_interval = reload;
 
-	if (timer_reload > 0x100000) {
+	if (timer_reload >= 0x100000) {
 		timer_reload >>= 8;
-		timer_ctrl |= TIMER_CTRL_DIV256;
-	} else if (timer_reload > 0x010000) {
+		ctrl |= TIMER_CTRL_DIV256;
+	} else if (timer_reload >= 0x010000) {
 		timer_reload >>= 4;
-		timer_ctrl |= TIMER_CTRL_DIV16;
+		ctrl |= TIMER_CTRL_DIV16;
 	}
 
+	writel(ctrl, TIMER1_VA_BASE + TIMER_CTRL);
+	writel(timer_reload, TIMER1_VA_BASE + TIMER_LOAD);
+}
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+void __init integrator_time_init(unsigned long reload, unsigned int ctrl)
+{
 	/*
 	 * Initialise to a known state (all timers off)
 	 */
@@ -264,12 +287,57 @@ void __init integrator_time_init(unsigne
 	writel(0, TIMER1_VA_BASE + TIMER_CTRL);
 	writel(0, TIMER2_VA_BASE + TIMER_CTRL);
 
-	writel(timer_reload, TIMER1_VA_BASE + TIMER_LOAD);
-	writel(timer_reload, TIMER1_VA_BASE + TIMER_VALUE);
-	writel(timer_ctrl, TIMER1_VA_BASE + TIMER_CTRL);
+	set_dec(reload);
 
 	/*
 	 * Make irqs happen for the system timer
 	 */
 	setup_irq(IRQ_TIMERINT1, &integrator_timer_irq);
+
+	tscok = 1;
+}
+
+#ifdef CONFIG_IPIPE
+void __ipipe_mach_acktimer(void)
+{
+	writel(1, TIMER1_VA_BASE + TIMER_INTCLR);
 }
+
+notrace unsigned long long __ipipe_mach_get_tsc(void)
+{
+	unsigned long long result;
+	unsigned long flags;
+
+	spin_lock_irqsave_hw(&timer_lock, flags);
+	result = __ipipe_mach_tsc + integrator_getticksoffset();
+	spin_unlock_irqrestore_hw(&timer_lock, flags);
+	return result;
+}
+EXPORT_SYMBOL(__ipipe_mach_get_tsc);
+
+void __ipipe_mach_set_dec(unsigned long reload)
+{
+	unsigned long ticks;
+	unsigned long flags;
+
+	spin_lock_irqsave_hw(&timer_lock, flags);
+	ticks = integrator_getticksoffset();
+	__ipipe_mach_tsc += ticks;
+	timer_lxlost += ticks;
+
+	set_dec(reload);
+	spin_unlock_irqrestore_hw(&timer_lock, flags);
+}
+EXPORT_SYMBOL(__ipipe_mach_set_dec);
+
+void __ipipe_mach_release_timer(void)
+{
+       __ipipe_mach_set_dec(__ipipe_mach_ticks_per_jiffy);
+}
+EXPORT_SYMBOL(__ipipe_mach_release_timer);
+
+unsigned long __ipipe_mach_get_dec(void)
+{
+	return readl(TIMER1_VA_BASE + TIMER_VALUE);
+}
+#endif /* CONFIG_IPIPE */
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-integrator/integrator_cp.c ipipe-2.6.14-imx21/arch/arm/mach-integrator/integrator_cp.c
--- linux-2.6.14/arch/arm/mach-integrator/integrator_cp.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/mach-integrator/integrator_cp.c	2008-02-21 22:08:59.000000000 +0100
@@ -2,6 +2,7 @@
  *  linux/arch/arm/mach-integrator/integrator_cp.c
  *
  *  Copyright (C) 2003 Deep Blue Solutions Ltd
+ *  Copyright (C) 2005 Stelian Pop.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -16,6 +17,7 @@
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/sysdev.h>
+#include <linux/ipipe.h>
 
 #include <asm/hardware.h>
 #include <asm/io.h>
@@ -174,6 +176,31 @@ sic_handle_irq(unsigned int irq, struct 
 	} while (status);
 }
 
+#ifdef CONFIG_IPIPE
+void __ipipe_mach_demux_irq(unsigned irq, struct pt_regs *regs)
+{
+	unsigned long status = sic_readl(INTCP_VA_SIC_BASE + IRQ_STATUS);
+	struct irqdesc *desc_unused = irq_desc + irq;
+	unsigned irq_unused = irq;
+
+	if (status == 0) {
+		do_bad_IRQ(irq, desc_unused, regs);
+		return;
+	}
+
+	do {
+		irq = ffs(status) - 1;
+		status &= ~(1 << irq);
+
+		irq += IRQ_SIC_START;
+
+		__ipipe_handle_irq(irq, regs);
+	} while (status);
+
+	desc_unused->chip->unmask(irq_unused);
+}
+#endif /* CONFIG_IPIPE */
+
 static void __init intcp_init_irq(void)
 {
 	unsigned int i;
@@ -521,9 +548,14 @@ static void __init intcp_init(void)
 
 #define TIMER_CTRL_IE	(1 << 5)			/* Interrupt Enable */
 
+#ifdef CONFIG_IPIPE
+unsigned int __ipipe_mach_ticks_per_jiffy = 1000000 * TICKS_PER_uSEC / HZ;
+EXPORT_SYMBOL(__ipipe_mach_ticks_per_jiffy);
+#endif
+
 static void __init intcp_timer_init(void)
 {
-	integrator_time_init(1000000 / HZ, TIMER_CTRL_IE);
+	integrator_time_init(1000000 * TICKS_PER_uSEC / HZ, TIMER_CTRL_IE);
 }
 
 static struct sys_timer cp_timer = {
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-pxa/irq.c ipipe-2.6.14-imx21/arch/arm/mach-pxa/irq.c
--- linux-2.6.14/arch/arm/mach-pxa/irq.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/mach-pxa/irq.c	2008-02-21 22:09:00.000000000 +0100
@@ -16,6 +16,7 @@
 #include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/ptrace.h>
+#include <linux/ipipe.h>
 
 #include <asm/hardware.h>
 #include <asm/irq.h>
@@ -214,6 +215,42 @@ static void pxa_gpio_demux_handler(unsig
 	} while (loop);
 }
 
+#ifdef CONFIG_IPIPE
+void __ipipe_mach_demux_irq(unsigned irq, struct pt_regs *regs)
+{
+	struct irqdesc *desc_unused = irq_desc + irq;
+	unsigned irq_unused = irq;
+	unsigned int i, mask[4];
+	int loop;
+
+	do {
+		loop = 0;
+
+		mask[0] = GEDR0 & ~3;
+		mask[1] = GEDR1;
+		mask[2] = GEDR2;
+#if PXA_LAST_GPIO < 96
+		i = 3;
+#else /* PXA_LAST_GPIO >= 96 */
+		mask[3] = GEDR3;
+		i = 4;
+#endif /* PXA_LAST_GPIO >= 96 */
+		for (; i; i--) {
+			loop |= mask[i - 1];
+			while (mask[i - 1]) {
+				irq = fls(mask[i - 1]) - 1;
+				mask[i - 1] &= ~(1 << irq);
+				irq = IRQ_GPIO((i - 1) * 32 + irq);
+
+				__ipipe_handle_irq(irq, regs);
+			}
+		}
+	} while (loop);
+
+	desc_unused->chip->unmask(irq_unused);
+}
+#endif /* CONFIG_IPIPE */
+
 static void pxa_ack_muxed_gpio(unsigned int irq)
 {
 	int gpio = irq - IRQ_GPIO(2) + 2;
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-pxa/time.c ipipe-2.6.14-imx21/arch/arm/mach-pxa/time.c
--- linux-2.6.14/arch/arm/mach-pxa/time.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/mach-pxa/time.c	2008-02-21 22:09:00.000000000 +0100
@@ -19,6 +19,7 @@
 #include <linux/signal.h>
 #include <linux/errno.h>
 #include <linux/sched.h>
+#include <linux/module.h>
 
 #include <asm/system.h>
 #include <asm/hardware.h>
@@ -30,6 +31,23 @@
 #include <asm/arch/pxa-regs.h>
 
 
+#ifdef CONFIG_IPIPE
+#ifdef CONFIG_NO_IDLE_HZ
+#error "dynamic tick timer not yet supported with IPIPE"
+#endif /* CONFIG_NO_IDLE_HZ */
+int __ipipe_mach_timerint = IRQ_OST0;
+EXPORT_SYMBOL(__ipipe_mach_timerint);
+
+int __ipipe_mach_timerstolen = 0;
+EXPORT_SYMBOL(__ipipe_mach_timerstolen);
+
+unsigned int __ipipe_mach_ticks_per_jiffy = LATCH;
+EXPORT_SYMBOL(__ipipe_mach_ticks_per_jiffy);
+
+static int pxa_timer_initialized;
+static unsigned long last_jiffy_time;
+#endif /* CONFIG_IPIPE */
+
 static inline unsigned long pxa_get_rtc_time(void)
 {
 	return RCNR;
@@ -54,6 +72,9 @@ static unsigned long pxa_gettimeoffset (
 {
 	long ticks_to_match, elapsed, usec;
 
+#ifdef CONFIG_IPIPE
+	if (!__ipipe_mach_timerstolen) {
+#endif
 	/* Get ticks before next timer match */
 	ticks_to_match = OSMR0 - OSCR;
 
@@ -63,6 +84,10 @@ static unsigned long pxa_gettimeoffset (
 	/* don't get fooled by the workaround in pxa_timer_interrupt() */
 	if (elapsed <= 0)
 		return 0;
+#ifdef CONFIG_IPIPE
+	} else
+		elapsed = OSCR - last_jiffy_time;
+#endif
 
 	/* Now convert them to usec */
 	usec = (unsigned long)(elapsed * (tick_nsec / 1000))/LATCH;
@@ -105,9 +130,27 @@ pxa_timer_interrupt(int irq, void *dev_i
 	 * affect things only when the timer IRQ has been delayed by nearly
 	 * exactly one tick period which should be a pretty rare event.
 	 */
+#ifdef CONFIG_IPIPE
+	/*
+	 * - if Linux is running natively (no ipipe), ack and reprogram the timer
+	 * - if Linux is running under ipipe, but it still has the control over
+	 *   the timer (no Xenomai for example), then reprogram the timer (ipipe
+	 *   has already acked it)
+	 * - if some other domain has taken over the timer, then do nothing
+	 *   (ipipe has acked it, and the other domain has reprogramed it)
+	 */
+	if (__ipipe_mach_timerstolen) {
+		timer_tick(regs);
+		last_jiffy_time += LATCH;
+	} else
+#endif /* CONFIG_IPIPE */
 	do {
 		timer_tick(regs);
+#ifdef CONFIG_IPIPE
+		last_jiffy_time += LATCH;
+#else /* !CONFIG_IPIPE */
 		OSSR = OSSR_M0;  /* Clear match on timer 0 */
+#endif /* !CONFIG_IPIPE */
 		next_match = (OSMR0 += LATCH);
 	} while( (signed long)(next_match - OSCR) <= 8 );
 
@@ -137,6 +180,10 @@ static void __init pxa_timer_init(void)
 	setup_irq(IRQ_OST0, &pxa_timer_irq);
 	OIER |= OIER_E0;	/* enable match on timer 0 to cause interrupts */
 	OSCR = 0;		/* initialize free-running timer, force first match */
+
+#ifdef CONFIG_IPIPE
+	pxa_timer_initialized = 1;
+#endif /* CONFIG_IPIPE */
 }
 
 #ifdef CONFIG_NO_IDLE_HZ
@@ -214,3 +261,75 @@ struct sys_timer pxa_timer = {
 	.dyn_tick	= &pxa_dyn_tick,
 #endif
 };
+
+#ifdef CONFIG_IPIPE
+void __ipipe_mach_acktimer(void)
+{
+	OSSR = OSSR_M0;  /* Clear match on timer 0 */
+}
+
+notrace unsigned long long __ipipe_mach_get_tsc(void)
+{
+	if (likely(pxa_timer_initialized)) {
+		static union {
+#ifdef __BIG_ENDIAN
+			struct {
+				unsigned long high;
+				unsigned long low;
+			};
+#else /* __LITTLE_ENDIAN */
+			struct {
+				unsigned long low;
+				unsigned long high;
+			};
+#endif /* __LITTLE_ENDIAN */
+			unsigned long long full;
+		} tsc[NR_CPUS], *local_tsc;
+		unsigned long stamp, flags;
+		unsigned long long result;
+
+		local_irq_save_hw(flags);
+		local_tsc = &tsc[ipipe_processor_id()];
+		stamp = OSCR;
+		if (unlikely(stamp < local_tsc->low))
+			/* 32 bit counter wrapped, increment high word. */
+			local_tsc->high++;
+		local_tsc->low = stamp;
+		result = local_tsc->full;
+		local_irq_restore_hw(flags);
+
+		return result;
+	}
+	
+        return 0;
+}
+EXPORT_SYMBOL(__ipipe_mach_get_tsc);
+
+/*
+ * Reprogram the timer
+ */
+
+void __ipipe_mach_set_dec(unsigned long delay)
+{
+	if (delay > 8) {
+		unsigned long flags;
+
+		local_irq_save_hw(flags);
+		OSMR0 = delay + OSCR;
+		local_irq_restore_hw(flags);
+	} else
+		ipipe_trigger_irq(IRQ_OST0);
+}
+EXPORT_SYMBOL(__ipipe_mach_set_dec);
+
+void __ipipe_mach_release_timer(void)
+{
+       __ipipe_mach_set_dec(__ipipe_mach_ticks_per_jiffy);
+}
+EXPORT_SYMBOL(__ipipe_mach_release_timer);
+
+unsigned long __ipipe_mach_get_dec(void)
+{
+	return OSMR0 - OSCR;
+}
+#endif /* CONFIG_IPIPE */
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-s3c2410/irq.c ipipe-2.6.14-imx21/arch/arm/mach-s3c2410/irq.c
--- linux-2.6.14/arch/arm/mach-s3c2410/irq.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/mach-s3c2410/irq.c	2008-02-21 22:09:00.000000000 +0100
@@ -3,6 +3,8 @@
  * Copyright (c) 2003,2004 Simtec Electronics
  *	Ben Dooks <ben@simtec.co.uk>
  *
+ * Copyright (C) 2006 Sebastian Smolorz <ssmolorz@emlix.com>, emlix GmbH
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -48,7 +50,10 @@
  *
  *   25-Jul-2005  Ben Dooks
  *		  Split the S3C2440 IRQ code to seperate file
-*/
+ *
+ *   30-Oct-2006  Sebastian Smolorz
+ *		  Added Adeos/I-pipe support
+ */
 
 #include <linux/init.h>
 #include <linux/module.h>
@@ -56,6 +61,7 @@
 #include <linux/ioport.h>
 #include <linux/ptrace.h>
 #include <linux/sysdev.h>
+#include <linux/ipipe.h>
 
 #include <asm/hardware.h>
 #include <asm/irq.h>
@@ -70,6 +76,14 @@
 #include "pm.h"
 #include "irq.h"
 
+#ifdef CONFIG_IPIPE
+#ifdef CONFIG_CPU_S3C2440
+extern void __ipipe_s3c_irq_demux_wdtac97(unsigned int irq,
+					  struct pt_regs *regs);
+extern void __ipipe_s3c_irq_demux_cam(unsigned int irq, struct pt_regs *regs);
+#endif /* CONFIG_CPU_S3C2440 */
+#endif /* CONFIG_IPIPE */
+
 /* wakeup irq control */
 
 #ifdef CONFIG_PM
@@ -573,6 +587,79 @@ s3c_irq_demux_uart2(unsigned int irq,
 }
 
 
+#ifdef CONFIG_IPIPE
+static void __ipipe_s3c_irq_demux_uart(unsigned int start,
+					unsigned int subsrc,
+					struct pt_regs *regs)
+{
+	unsigned int offset = start - IRQ_S3CUART_RX0;
+
+	subsrc >>= offset;
+	subsrc &= 7;
+
+	if (subsrc != 0) {
+		if (subsrc & 1)
+			__ipipe_handle_irq(start, regs);
+		if (subsrc & 2)
+			__ipipe_handle_irq(start+1, regs);
+		if (subsrc & 4)
+			__ipipe_handle_irq(start+2, regs);
+	}
+}
+
+static void __ipipe_s3c_irq_demux_adc(unsigned int subsrc,
+					struct pt_regs *regs)
+{
+	subsrc >>= 9;
+	subsrc &= 3;
+
+	if (subsrc != 0) {
+		if (subsrc & 1)
+			__ipipe_handle_irq(IRQ_TC, regs);
+		if (subsrc & 2)
+			__ipipe_handle_irq(IRQ_ADC, regs);
+	}
+}
+
+void __ipipe_mach_demux_irq(unsigned irq, struct pt_regs *regs)
+{
+	unsigned int subsrc, submsk;
+	struct irqdesc *desc_unused = irq_desc + irq;
+
+	/* read the current pending interrupts, and the mask
+	 * for what it is available */
+	subsrc = __raw_readl(S3C2410_SUBSRCPND);
+	submsk = __raw_readl(S3C2410_INTSUBMSK);
+
+	subsrc &= ~submsk;
+
+	switch (irq) {
+	case IRQ_UART0:
+		__ipipe_s3c_irq_demux_uart(IRQ_S3CUART_RX0, subsrc, regs);
+		break;
+	case IRQ_UART1:
+		__ipipe_s3c_irq_demux_uart(IRQ_S3CUART_RX1, subsrc, regs);
+		break;
+	case IRQ_UART2:
+		__ipipe_s3c_irq_demux_uart(IRQ_S3CUART_RX2, subsrc, regs);
+		break;
+	case IRQ_ADCPARENT:
+		__ipipe_s3c_irq_demux_adc(subsrc, regs);
+		break;
+#ifdef CONFIG_CPU_S3C2440
+	case IRQ_WDT:
+		__ipipe_s3c_irq_demux_wdtac97(subsrc, regs);
+		break;
+	case IRQ_CAM:
+		__ipipe_s3c_irq_demux_cam(subsrc, regs);
+		break;
+#endif /* CONFIG_CPU_S3C2440 */
+	}
+
+	desc_unused->chip->unmask(irq);
+}
+#endif /* CONFIG_IPIPE */
+
 /* s3c24xx_init_irq
  *
  * Initialise S3C2410 IRQ system
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-s3c2410/s3c2440-irq.c ipipe-2.6.14-imx21/arch/arm/mach-s3c2410/s3c2440-irq.c
--- linux-2.6.14/arch/arm/mach-s3c2410/s3c2440-irq.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/mach-s3c2410/s3c2440-irq.c	2008-02-21 22:09:00.000000000 +0100
@@ -3,6 +3,8 @@
  * Copyright (c) 2003,2004 Simtec Electronics
  *	Ben Dooks <ben@simtec.co.uk>
  *
+ * Copyright (C) 2006 Sebastian Smolorz <ssmolorz@emlix.com>, emlix GmbH
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -19,8 +21,10 @@
  *
  * Changelog:
  *	25-Jul-2005 BJD		Split from irq.c
+ *   	11-Oct-2006 Sebastian Smolorz
+ *		    Added Adeos/Ipipe support
  *
-*/
+ */
 
 #include <linux/init.h>
 #include <linux/module.h>
@@ -28,6 +32,7 @@
 #include <linux/ioport.h>
 #include <linux/ptrace.h>
 #include <linux/sysdev.h>
+#include <linux/ipipe.h>
 
 #include <asm/hardware.h>
 #include <asm/irq.h>
@@ -157,6 +162,34 @@ static struct irqchip s3c_irq_cam = {
 	.ack	    = s3c_irq_cam_ack,
 };
 
+#ifdef CONFIG_IPIPE
+void __ipipe_s3c_irq_demux_wdtac97(unsigned int subsrc, struct pt_regs *regs)
+{
+	subsrc >>= 13;
+	subsrc &= 3;
+
+	if (subsrc != 0) {
+		if (subsrc & 1)
+			__ipipe_handle_irq(IRQ_S3C2440_WDT, regs);
+		if (subsrc & 2)
+			__ipipe_handle_irq(IRQ_S3C2440_AC97, regs);
+	}
+}
+
+void __ipipe_s3c_irq_demux_cam(unsigned int subsrc, struct pt_regs *regs)
+{
+	subsrc >>= 11;
+	subsrc &= 3;
+
+	if (subsrc != 0) {
+		if (subsrc & 1)
+			__ipipe_handle_irq(IRQ_S3C2440_CAM_C, regs);
+		if (subsrc & 2)
+			__ipipe_handle_irq(IRQ_S3C2440_CAM_P, regs);
+	}
+}
+#endif /* CONFIG_IPIPE */
+
 static int s3c2440_irq_add(struct sys_device *sysdev)
 {
 	unsigned int irqno;
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-s3c2410/time.c ipipe-2.6.14-imx21/arch/arm/mach-s3c2410/time.c
--- linux-2.6.14/arch/arm/mach-s3c2410/time.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/mach-s3c2410/time.c	2008-02-21 22:09:00.000000000 +0100
@@ -3,6 +3,8 @@
  * Copyright (C) 2003-2005 Simtec Electronics
  *	Ben Dooks, <ben@simtec.co.uk>
  *
+ * Copyright (C) 2006 Sebastian Smolorz <ssmolorz@emlix.com>, emlix GmbH
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -24,6 +26,7 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/err.h>
+#include <linux/module.h>
 
 #include <asm/system.h>
 #include <asm/leds.h>
@@ -40,7 +43,6 @@
 #include "clock.h"
 #include "cpu.h"
 
-static unsigned long timer_startval;
 static unsigned long timer_usec_ticks;
 
 #define TIMER_USEC_SHIFT 16
@@ -55,6 +57,24 @@ static unsigned long timer_usec_ticks;
  * Original patch by Dimitry Andric, updated by Ben Dooks
 */
 
+static unsigned long last_free_running_tcnt = 0;
+static unsigned long free_running_tcon = 0;
+static unsigned long timer_lxlost = 0;
+
+#ifdef CONFIG_IPIPE
+unsigned int __ipipe_mach_ticks_per_jiffy;
+EXPORT_SYMBOL(__ipipe_mach_ticks_per_jiffy);
+
+int __ipipe_mach_timerint = IRQ_TIMER4;
+EXPORT_SYMBOL(__ipipe_mach_timerint);
+
+static unsigned long long __ipipe_mach_tsc = 0;
+static unsigned long timer_ackval = 1UL << (IRQ_TIMER4 - IRQ_EINT0);
+static DEFINE_SPINLOCK(timer_lock);
+
+int __ipipe_mach_timerstolen = 0;
+EXPORT_SYMBOL(__ipipe_mach_timerstolen);
+#endif /* CONFIG_IPIPE */
 
 /* timer_mask_usec_ticks
  *
@@ -85,44 +105,46 @@ static inline unsigned long timer_ticks_
 	return res >> TIMER_USEC_SHIFT;
 }
 
-/***
- * Returns microsecond  since last clock interrupt.  Note that interrupts
- * will have been disabled by do_gettimeoffset()
- * IRQs are disabled before entering here from do_gettimeofday()
- */
-
-#define SRCPND_TIMER4 (1<<(IRQ_TIMER4 - IRQ_EINT0))
 
-static unsigned long s3c2410_gettimeoffset (void)
+static inline unsigned long timer_freerunning_getvalue(void)
 {
-	unsigned long tdone;
-	unsigned long irqpend;
-	unsigned long tval;
-
-	/* work out how many ticks have gone since last timer interrupt */
+	return __raw_readl(S3C2410_TCNTO(3));
+}
 
-        tval =  __raw_readl(S3C2410_TCNTO(4));
-	tdone = timer_startval - tval;
+static inline unsigned long timer_freerunning_getticksoffset(unsigned long tval)
+{
+	long tdone;
 
-	/* check to see if there is an interrupt pending */
+	tdone =  last_free_running_tcnt - tval;
+	if (tdone < 0)
+		tdone += 0x10000;
 
-	irqpend = __raw_readl(S3C2410_SRCPND);
-	if (irqpend & SRCPND_TIMER4) {
-		/* re-read the timer, and try and fix up for the missed
-		 * interrupt. Note, the interrupt may go off before the
-		 * timer has re-loaded from wrapping.
-		 */
+	return tdone;
+}
 
-		tval =  __raw_readl(S3C2410_TCNTO(4));
-		tdone = timer_startval - tval;
+static inline unsigned long getticksoffset(void)
+{
+	return timer_freerunning_getticksoffset(timer_freerunning_getvalue());
+}
 
-		if (tval != 0)
-			tdone += timer_startval;
-	}
+#ifdef CONFIG_IPIPE
+static inline unsigned long getticksoffset_tscupdate(void)
+{
+	unsigned long tval;
+	unsigned long ticks;
 
-	return timer_ticks_to_usec(tdone);
+	tval = timer_freerunning_getvalue();
+	ticks = timer_freerunning_getticksoffset(tval);
+	last_free_running_tcnt = tval;
+	__ipipe_mach_tsc += ticks;
+	return ticks;
 }
+#endif /* CONFIG_IPIPE */
 
+static unsigned long s3c2410_gettimeoffset (void)
+{
+	return timer_ticks_to_usec(timer_lxlost + getticksoffset());
+}
 
 /*
  * IRQ handler for the timer
@@ -131,6 +153,14 @@ static irqreturn_t
 s3c2410_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	write_seqlock(&xtime_lock);
+
+#ifdef CONFIG_IPIPE
+	timer_lxlost = 0;
+
+	if (!__ipipe_mach_timerstolen)
+		getticksoffset_tscupdate();
+#endif /* CONFIG_IPIPE */
+
 	timer_tick(regs);
 	write_sequnlock(&xtime_lock);
 	return IRQ_HANDLED;
@@ -143,10 +173,10 @@ static struct irqaction s3c2410_timer_ir
 };
 
 /*
- * Set up timer interrupt, and return the current time in seconds.
+ * Set up timer interrupt.
  *
- * Currently we only use timer4, as it is the only timer which has no
- * other function that can be exploited externally
+ * Currently we use timer4 as event timer and timer3 as tick counter which
+ * permanently counts ticks without interrupt generation.
  */
 static void s3c2410_timer_setup (void)
 {
@@ -154,6 +184,7 @@ static void s3c2410_timer_setup (void)
 	unsigned long tcnt;
 	unsigned long tcfg1;
 	unsigned long tcfg0;
+	unsigned long intmask;
 
 	tcnt = 0xffff;  /* default value for tcnt */
 
@@ -170,8 +201,8 @@ static void s3c2410_timer_setup (void)
 		timer_usec_ticks = timer_mask_usec_ticks(1, 12000000);
 		tcnt = 12000000 / HZ;
 
-		tcfg1 &= ~S3C2410_TCFG1_MUX4_MASK;
-		tcfg1 |= S3C2410_TCFG1_MUX4_TCLK1;
+		tcfg1 &= ~(S3C2410_TCFG1_MUX4_MASK | S3C2410_TCFG1_MUX3_MASK);
+		tcfg1 |= (S3C2410_TCFG1_MUX4_TCLK1 | S3C2410_TCFG1_MUX3_TCLK1);
 	} else {
 		unsigned long pclk;
 		struct clk *clk;
@@ -200,8 +231,8 @@ static void s3c2410_timer_setup (void)
 
 		timer_usec_ticks = timer_mask_usec_ticks(6, pclk);
 
-		tcfg1 &= ~S3C2410_TCFG1_MUX4_MASK;
-		tcfg1 |= S3C2410_TCFG1_MUX4_DIV2;
+		tcfg1 &= ~(S3C2410_TCFG1_MUX4_MASK | S3C2410_TCFG1_MUX3_MASK);
+		tcfg1 |= (S3C2410_TCFG1_MUX4_DIV2 | S3C2410_TCFG1_MUX3_DIV2);
 
 		tcfg0 &= ~S3C2410_TCFG_PRESCALER1_MASK;
 		tcfg0 |= ((6 - 1) / 2) << S3C2410_TCFG_PRESCALER1_SHIFT;
@@ -209,6 +240,10 @@ static void s3c2410_timer_setup (void)
 		tcnt = (pclk / 6) / HZ;
 	}
 
+#ifdef CONFIG_IPIPE
+	__ipipe_mach_ticks_per_jiffy = tcnt;
+#endif /* CONFIG_IPIPE */
+
 	/* timers reload after counting zero, so reduce the count by 1 */
 
 	tcnt--;
@@ -225,23 +260,37 @@ static void s3c2410_timer_setup (void)
 	__raw_writel(tcfg1, S3C2410_TCFG1);
 	__raw_writel(tcfg0, S3C2410_TCFG0);
 
-	timer_startval = tcnt;
-	__raw_writel(tcnt, S3C2410_TCNTB(4));
-
-	/* ensure timer is stopped... */
+	/* ensure timers are stopped... */
+	tcon &= ~(0x3f<<17);
+	__raw_writel(tcon, S3C2410_TCON);
 
-	tcon &= ~(7<<20);
-	tcon |= S3C2410_TCON_T4RELOAD;
-	tcon |= S3C2410_TCON_T4MANUALUPD;
+	/* Mask timer3 interrupt. */
+	intmask = __raw_readl(S3C2410_INTMSK);
+	intmask |= 1UL << (IRQ_TIMER3 - IRQ_EINT0);
+	__raw_writel(intmask, S3C2410_INTMSK);
 
-	__raw_writel(tcon, S3C2410_TCON);
+	/* Set timer values */
 	__raw_writel(tcnt, S3C2410_TCNTB(4));
 	__raw_writel(tcnt, S3C2410_TCMPB(4));
+	__raw_writel(0xffff, S3C2410_TCNTB(3));
+	__raw_writel(0xffff, S3C2410_TCMPB(3));
 
-	/* start the timer running */
-	tcon |= S3C2410_TCON_T4START;
-	tcon &= ~S3C2410_TCON_T4MANUALUPD;
+	/* Set base tcon value for later programming of timer 4 by Xenomai. */
+	free_running_tcon = tcon |  S3C2410_TCON_T3RELOAD | S3C2410_TCON_T3START;
+
+	/* Set auto reloads for both timers. */
+	tcon |= S3C2410_TCON_T3RELOAD | S3C2410_TCON_T4RELOAD;
+
+	/* Manual update */
+	__raw_writel(tcon | S3C2410_TCON_T3MANUALUPD
+			  | S3C2410_TCON_T4MANUALUPD, S3C2410_TCON);
+
+	tcon |= S3C2410_TCON_T3START | S3C2410_TCON_T4START;
+	/* Start timers.*/
 	__raw_writel(tcon, S3C2410_TCON);
+
+	/* Save start value of timer 3 as begining of first period. */
+	last_free_running_tcnt = 0xffff;
 }
 
 static void __init s3c2410_timer_init (void)
@@ -255,3 +304,56 @@ struct sys_timer s3c24xx_timer = {
 	.offset		= s3c2410_gettimeoffset,
 	.resume		= s3c2410_timer_setup
 };
+
+#ifdef CONFIG_IPIPE
+void __ipipe_mach_acktimer(void)
+{
+	__raw_writel(timer_ackval, S3C2410_SRCPND);
+	__raw_writel(timer_ackval, S3C2410_INTPND);
+}
+
+notrace unsigned long long __ipipe_mach_get_tsc(void)
+{
+	unsigned long long result;
+	unsigned long flags;
+
+	spin_lock_irqsave_hw(&timer_lock, flags);
+	result = __ipipe_mach_tsc + getticksoffset();
+	spin_unlock_irqrestore_hw(&timer_lock, flags);
+	return result;
+}
+EXPORT_SYMBOL(__ipipe_mach_get_tsc);
+
+static inline void set_dec(unsigned long reload)
+{
+	__raw_writel(reload, S3C2410_TCNTB(4));
+	/* Manual update */
+	__raw_writel(free_running_tcon | S3C2410_TCON_T4MANUALUPD, S3C2410_TCON);
+	/* Start timer */
+	__raw_writel(free_running_tcon | S3C2410_TCON_T4START, S3C2410_TCON);
+}
+
+void __ipipe_mach_set_dec(unsigned long reload)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave_hw(&timer_lock, flags);
+	timer_lxlost += getticksoffset_tscupdate();
+	set_dec(reload);
+	spin_unlock_irqrestore_hw(&timer_lock, flags);
+}
+EXPORT_SYMBOL(__ipipe_mach_set_dec);
+
+void __ipipe_mach_release_timer(void)
+{
+	free_running_tcon |= S3C2410_TCON_T4RELOAD;
+	__ipipe_mach_set_dec(__ipipe_mach_ticks_per_jiffy - 1);
+	free_running_tcon &= ~S3C2410_TCON_T4RELOAD;
+}
+EXPORT_SYMBOL(__ipipe_mach_release_timer);
+
+unsigned long __ipipe_mach_get_dec(void)
+{
+	return __raw_readl(S3C2410_TCNTO(4));
+}
+#endif /* CONFIG_IPIPE */
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-sa1100/irq.c ipipe-2.6.14-imx21/arch/arm/mach-sa1100/irq.c
--- linux-2.6.14/arch/arm/mach-sa1100/irq.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/mach-sa1100/irq.c	2008-02-21 22:09:00.000000000 +0100
@@ -14,6 +14,7 @@
 #include <linux/ioport.h>
 #include <linux/ptrace.h>
 #include <linux/sysdev.h>
+#include <linux/ipipe.h>
 
 #include <asm/hardware.h>
 #include <asm/irq.h>
@@ -136,6 +137,37 @@ sa1100_high_gpio_handler(unsigned int ir
 	} while (mask);
 }
 
+#ifdef CONFIG_IPIPE
+void __ipipe_mach_demux_irq(unsigned irq, struct pt_regs *regs)
+{
+	struct irqdesc *desc_unused = irq_desc + irq;
+	unsigned irq_unused = irq;
+	unsigned int mask;
+
+	mask = GEDR & 0xfffff800;
+	do {
+		/*
+		 * clear down all currently active IRQ sources.
+		 * We will be processing them all.
+		 */
+		GEDR = mask;
+
+		irq = IRQ_GPIO11;
+		mask >>= 11;
+		do {
+			if (mask & 1)
+				__ipipe_handle_irq(irq, regs);
+			mask >>= 1;
+			irq++;
+		} while (mask);
+
+		mask = GEDR & 0xfffff800;
+	} while (mask);
+
+	desc_unused->chip->unmask(irq_unused);
+}
+#endif /* CONFIG_IPIPE */
+
 /*
  * Like GPIO0 to 10, GPIO11-27 IRQs need to be handled specially.
  * In addition, the IRQs are all collected up into one bit in the
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mach-sa1100/time.c ipipe-2.6.14-imx21/arch/arm/mach-sa1100/time.c
--- linux-2.6.14/arch/arm/mach-sa1100/time.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/mach-sa1100/time.c	2008-02-21 22:09:00.000000000 +0100
@@ -13,6 +13,7 @@
 #include <linux/interrupt.h>
 #include <linux/timex.h>
 #include <linux/signal.h>
+#include <linux/module.h>
 
 #include <asm/mach/time.h>
 #include <asm/hardware.h>
@@ -20,6 +21,23 @@
 #define RTC_DEF_DIVIDER		(32768 - 1)
 #define RTC_DEF_TRIM            0
 
+#ifdef CONFIG_IPIPE
+#ifdef CONFIG_NO_IDLE_HZ
+#error "dynamic tick timer not yet supported with IPIPE"
+#endif /* CONFIG_NO_IDLE_HZ */
+int __ipipe_mach_timerint = IRQ_OST0;
+EXPORT_SYMBOL(__ipipe_mach_timerint);
+
+int __ipipe_mach_timerstolen = 0;
+EXPORT_SYMBOL(__ipipe_mach_timerstolen);
+
+unsigned int __ipipe_mach_ticks_per_jiffy = LATCH;
+EXPORT_SYMBOL(__ipipe_mach_ticks_per_jiffy);
+
+static int sa1100_timer_initialized;
+static unsigned long last_jiffy_time;
+#endif /* CONFIG_IPIPE */
+
 static unsigned long __init sa1100_get_rtc_time(void)
 {
 	/*
@@ -58,11 +76,18 @@ static unsigned long sa1100_gettimeoffse
 {
 	unsigned long ticks_to_match, elapsed, usec;
 
+#ifdef CONFIG_IPIPE
+	if (!__ipipe_mach_timerstolen) {
+#endif
 	/* Get ticks before next timer match */
 	ticks_to_match = OSMR0 - OSCR;
 
 	/* We need elapsed ticks since last match */
 	elapsed = LATCH - ticks_to_match;
+#ifdef CONFIG_IPIPE
+	} else
+		elapsed = OSCR - last_jiffy_time;
+#endif
 
 	/* Now convert them to usec */
 	usec = (unsigned long)(elapsed * (tick_nsec / 1000))/LATCH;
@@ -97,9 +122,27 @@ sa1100_timer_interrupt(int irq, void *de
 	 * ensured, hence we can use do_gettimeofday() from interrupt
 	 * handlers.
 	 */
+#ifdef CONFIG_IPIPE
+	/*
+	 * - if Linux is running natively (no ipipe), ack and reprogram the timer
+	 * - if Linux is running under ipipe, but it still has the control over
+	 *   the timer (no Xenomai for example), then reprogram the timer (ipipe
+	 *   has already acked it)
+	 * - if some other domain has taken over the timer, then do nothing
+	 *   (ipipe has acked it, and the other domain has reprogramed it)
+	 */
+	if (__ipipe_mach_timerstolen) {
+		timer_tick(regs);
+		last_jiffy_time += LATCH;
+	} else
+#endif /* CONFIG_IPIPE */
 	do {
 		timer_tick(regs);
+#ifdef CONFIG_IPIPE
+		last_jiffy_time += LATCH;
+#else /* !CONFIG_IPIPE */
 		OSSR = OSSR_M0;  /* Clear match on timer 0 */
+#endif /* !CONFIG_IPIPE */
 		next_match = (OSMR0 += LATCH);
 	} while ((signed long)(next_match - OSCR) <= 0);
 
@@ -129,6 +172,10 @@ static void __init sa1100_timer_init(voi
 	setup_irq(IRQ_OST0, &sa1100_timer_irq);
 	OIER |= OIER_E0;	/* enable match on timer 0 to cause interrupts */
 	OSCR = 0;		/* initialize free-running timer, force first match */
+
+ #ifdef CONFIG_IPIPE
+ 	sa1100_timer_initialized = 1;
+ #endif /* CONFIG_IPIPE */
 }
 
 #ifdef CONFIG_NO_IDLE_HZ
@@ -207,3 +254,72 @@ struct sys_timer sa1100_timer = {
 	.dyn_tick	= &sa1100_dyn_tick,
 #endif
 };
+
+#ifdef CONFIG_IPIPE
+void __ipipe_mach_acktimer(void)
+{
+	OSSR = OSSR_M0;  /* Clear match on timer 0 */
+}
+
+notrace unsigned long long __ipipe_mach_get_tsc(void)
+{
+	if (likely(sa1100_timer_initialized)) {
+		static union {
+#ifdef __BIG_ENDIAN
+			struct {
+				unsigned long high;
+				unsigned long low;
+			};
+#else /* __LITTLE_ENDIAN */
+			struct {
+				unsigned long low;
+				unsigned long high;
+			};
+#endif /* __LITTLE_ENDIAN */
+			unsigned long long full;
+		} tsc[NR_CPUS], *local_tsc;
+		unsigned long stamp, flags;
+		unsigned long long result;
+
+		local_irq_save_hw(flags);
+		local_tsc = &tsc[ipipe_processor_id()];
+		stamp = OSCR;
+		if (unlikely(stamp < local_tsc->low))
+			/* 32 bit counter wrapped, increment high word. */
+			local_tsc->high++;
+		local_tsc->low = stamp;
+		result = local_tsc->full;
+		local_irq_restore_hw(flags);
+
+		return result;
+	}
+	
+        return 0;
+}
+EXPORT_SYMBOL(__ipipe_mach_get_tsc);
+
+/*
+ * Reprogram the timer
+ */
+
+void __ipipe_mach_set_dec(unsigned long delay)
+{
+	unsigned long flags;
+
+	local_irq_save_hw(flags);
+        OSMR0 = delay + OSCR;
+	local_irq_restore_hw(flags);
+}
+EXPORT_SYMBOL(__ipipe_mach_set_dec);
+
+void __ipipe_mach_release_timer(void)
+{
+       __ipipe_mach_set_dec(__ipipe_mach_ticks_per_jiffy);
+}
+EXPORT_SYMBOL(__ipipe_mach_release_timer);
+
+unsigned long __ipipe_mach_get_dec(void)
+{
+	return OSMR0 - OSCR;
+}
+#endif /* CONFIG_IPIPE */
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mm/Kconfig ipipe-2.6.14-imx21/arch/arm/mm/Kconfig
--- linux-2.6.14/arch/arm/mm/Kconfig	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/mm/Kconfig	2008-02-21 22:09:00.000000000 +0100
@@ -1,3 +1,10 @@
+#
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
+
 comment "Processor Type"
 
 config CPU_32
@@ -120,9 +127,9 @@ config CPU_ARM925T
 
 # ARM926T
 config CPU_ARM926T
-	bool "Support ARM926T processor" if ARCH_INTEGRATOR
-	depends on ARCH_INTEGRATOR || ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX
-	default y if ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX
+	bool "Support ARM926T processor" if ARCH_INTEGRATOR || ARCH_IMX21
+	depends on ARCH_INTEGRATOR || ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX || FAMILY_IMX21
+	default y if ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX || ARCH_IMX21
 	select CPU_32v5
 	select CPU_ABRT_EV5TJ
 	select CPU_CACHE_VIVT
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mm/copypage-v4mc.c ipipe-2.6.14-imx21/arch/arm/mm/copypage-v4mc.c
--- linux-2.6.14/arch/arm/mm/copypage-v4mc.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/mm/copypage-v4mc.c	2008-02-21 22:09:00.000000000 +0100
@@ -43,7 +43,7 @@ static DEFINE_SPINLOCK(minicache_lock);
  * instruction.  If your processor does not supply this, you have to write your
  * own copy_user_page that does the right thing.
  */
-static void __attribute__((naked))
+static void notrace __attribute__((naked))
 mc_copy_user_page(void *from, void *to)
 {
 	asm volatile(
@@ -82,7 +82,7 @@ void v4_mc_copy_user_page(void *kto, con
 /*
  * ARMv4 optimised clear_user_page
  */
-void __attribute__((naked))
+void notrace __attribute__((naked))
 v4_mc_clear_user_page(void *kaddr, unsigned long vaddr)
 {
 	asm volatile(
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mm/copypage-xscale.c ipipe-2.6.14-imx21/arch/arm/mm/copypage-xscale.c
--- linux-2.6.14/arch/arm/mm/copypage-xscale.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/mm/copypage-xscale.c	2008-02-21 22:09:00.000000000 +0100
@@ -41,7 +41,7 @@ static DEFINE_SPINLOCK(minicache_lock);
  * Dcache aliasing issue.  The writes will be forwarded to the write buffer,
  * and merged as appropriate.
  */
-static void __attribute__((naked))
+static void notrace __attribute__((naked))
 mc_copy_user_page(void *from, void *to)
 {
 	/*
@@ -104,7 +104,7 @@ void xscale_mc_copy_user_page(void *kto,
 /*
  * XScale optimised clear_user_page
  */
-void __attribute__((naked))
+void notrace __attribute__((naked))
 xscale_mc_clear_user_page(void *kaddr, unsigned long vaddr)
 {
 	asm volatile(
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/arch/arm/mm/fault.c ipipe-2.6.14-imx21/arch/arm/mm/fault.c
--- linux-2.6.14/arch/arm/mm/fault.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/arch/arm/mm/fault.c	2008-02-21 22:09:00.000000000 +0100
@@ -223,6 +223,9 @@ do_page_fault(unsigned long addr, unsign
 	struct mm_struct *mm;
 	int fault, sig, code;
 
+	if (ipipe_trap_notify(IPIPE_TRAP_ACCESS,regs))
+		return 0;
+
 	tsk = current;
 	mm  = tsk->mm;
 
@@ -354,6 +357,9 @@ do_translation_fault(unsigned long addr,
 bad_area:
 	tsk = current;
 
+	if (ipipe_trap_notify(IPIPE_TRAP_ACCESS,regs))
+		return 0;
+
 	do_bad_area(tsk, tsk->active_mm, addr, fsr, regs);
 	return 0;
 }
@@ -366,6 +372,10 @@ static int
 do_sect_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
 {
 	struct task_struct *tsk = current;
+
+	if (ipipe_trap_notify(IPIPE_TRAP_SECTION,regs))
+		return 0;
+
 	do_bad_area(tsk, tsk->active_mm, addr, fsr, regs);
 	return 0;
 }
@@ -376,6 +386,9 @@ do_sect_fault(unsigned long addr, unsign
 static int
 do_bad(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
 {
+	if (ipipe_trap_notify(IPIPE_TRAP_DABT,regs))
+		return 0;
+
 	return 1;
 }
 
@@ -451,6 +464,9 @@ do_DataAbort(unsigned long addr, unsigne
 	if (!inf->fn(addr, fsr, regs))
 		return;
 
+	if (ipipe_trap_notify(IPIPE_TRAP_UNKNOWN,regs))
+		return;
+
 	printk(KERN_ALERT "Unhandled fault: %s (0x%03x) at 0x%08lx\n",
 		inf->name, fsr, addr);
 
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/config_2.6.14_imx21_cogent535fs ipipe-2.6.14-imx21/config_2.6.14_imx21_cogent535fs
--- linux-2.6.14/config_2.6.14_imx21_cogent535fs	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/config_2.6.14_imx21_cogent535fs	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,798 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.14
+# Tue Apr 11 13:36:23 2006
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODULE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_CAMELOT is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_IMX is not set
+CONFIG_FAMILY_IMX21=y
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_AAEC2000 is not set
+
+#
+# IMX Implementations
+#
+CONFIG_MACH_CSB535=y
+# CONFIG_ARCH_MX2ADS is not set
+CONFIG_UMON_SHIM=y
+CONFIG_ARCH_IMX21=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+
+#
+# Bus support
+#
+CONFIG_ISA_DMA_API=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_PREEMPT=y
+# CONFIG_NO_IDLE_HZ is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="console=ttySMX0,57600n8 ip=bootp root=/dev/nfs"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+CONFIG_FPE_NWFPE_XP=y
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+CONFIG_MTD_CSB535=y
+# CONFIG_MTD_EDB7312 is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=y
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+CONFIG_CIRRUS=y
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_CONSOLE is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_IMX21=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_SOFT_CURSOR is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/drivers/mtd/maps/Kconfig ipipe-2.6.14-imx21/drivers/mtd/maps/Kconfig
--- linux-2.6.14/drivers/mtd/maps/Kconfig	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/drivers/mtd/maps/Kconfig	2008-02-21 22:09:00.000000000 +0100
@@ -1,3 +1,10 @@
+#
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
+
 # drivers/mtd/maps/Kconfig
 # $Id: Kconfig,v 1.55 2005/07/02 01:53:24 tpoynor Exp $
 
@@ -410,6 +417,16 @@ config MTD_CDB89712
 	  This enables access to the flash or ROM chips on the CDB89712 board.
 	  If you have such a board, say 'Y'.
 
+config MTD_CSB535
+	tristate "CFI Flash device mapped on Cogent CSB535"
+	depends on ARM && MTD_CFI && MACH_CSB535
+	help
+	  This enables access to the flash chip on the Cogent CSB535
+	  single board computer.  The default behavior of the startup
+	  script the comes with BSPs for that board is to pass the address
+	  of a file romfs.img, which is assumed to be a romfs filesystem image
+	  to be used as the initial root filesystem.
+
 config MTD_SA1100
 	tristate "CFI Flash device mapped on StrongARM SA11x0"
 	depends on ARM && MTD_CFI && ARCH_SA1100 && MTD_PARTITIONS
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/drivers/mtd/maps/Makefile ipipe-2.6.14-imx21/drivers/mtd/maps/Makefile
--- linux-2.6.14/drivers/mtd/maps/Makefile	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/drivers/mtd/maps/Makefile	2008-02-21 22:09:00.000000000 +0100
@@ -1,6 +1,12 @@
 #
 # linux/drivers/maps/Makefile
 #
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
+#
 # $Id: Makefile.common,v 1.30 2005/07/02 01:53:24 tpoynor Exp $
 
 ifeq ($(CONFIG_MTD_COMPLEX_MAPPINGS),y)
@@ -70,3 +76,4 @@ obj-$(CONFIG_MTD_DMV182)	+= dmv182.o
 obj-$(CONFIG_MTD_SHARP_SL)	+= sharpsl-flash.o
 obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
 obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
+obj-$(CONFIG_MTD_CSB535)	+= csbxxx.o
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/drivers/mtd/maps/csbxxx.c ipipe-2.6.14-imx21/drivers/mtd/maps/csbxxx.c
--- linux-2.6.14/drivers/mtd/maps/csbxxx.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/drivers/mtd/maps/csbxxx.c	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,159 @@
+/*
+ *
+ * Map driver for the Cogent CSBxxx boards.
+ *
+ * Author:	Bill Gatliff
+ * Copyright:	(C) 2005 Bill Gatliff <bgat@billgatliff.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+
+#define MTDID "flash00"
+#define MSG_PREFIX "csbxxx: "
+
+#if defined(CONFIG_MACH_CSB337) \
+  || defined(CONFIG_MACH_CSB437TL) \
+  || defined(CONFIG_MACH_CSB637)
+#define WINDOW_ADDR 0x10000000
+#define WINDOW_SIZE 0x1000000
+#elif defined(CONFIG_MACH_CSB625)
+#define WINDOW_ADDR 0x00000000
+#define WINDOW_SIZE 0x1000000
+#elif defined(CONFIG_MACH_CSB535)
+#define WINDOW_ADDR 0xc8000000
+#define WINDOW_SIZE 0x00800000
+#elif defined(CONFIG_ARCH_CSB226)
+#error TODO: finish MTD map for CSB226
+#else
+#error TODO: the MTD map you need goes here...
+#endif
+
+#define NB_OF(a) (sizeof(a)/sizeof(*(a)))
+
+static void csbxxx_map_inval_cache(struct map_info *map, unsigned long from, ssize_t len)
+{
+  consistent_sync((char *)map->cached + from, len, DMA_FROM_DEVICE);
+}
+
+static struct map_info csbxxx_map = {
+    .size = WINDOW_SIZE,
+    .phys = WINDOW_ADDR,
+    .inval_cache = csbxxx_map_inval_cache,
+    .bankwidth = 2,
+    .name = MTDID,
+};
+
+/* default map definition,
+   generally overridden on the command line */
+static struct mtd_partition csbxxx_partitions[] = {
+  {
+    .name = "uMON flash",
+    .size = WINDOW_SIZE,
+    .mask_flags = MTD_WRITEABLE  /* force read-only */
+  },
+};
+
+static const char *probes[] = { "cmdlinepart", NULL };
+
+static struct mtd_info *mymtd = 0;
+static int mtd_parts_nb = 0;
+static struct mtd_partition *mtd_parts = 0;
+
+static int __init init_csbxxx(void)
+{
+  int ret = 0;
+  const char *part_type = 0;
+
+  csbxxx_map.virt = ioremap(csbxxx_map.phys, WINDOW_SIZE);
+  if (!csbxxx_map.virt) {
+    printk(KERN_WARNING "Failed to ioremap %s, MTD disabled\n", csbxxx_map.name);
+    ret = -ENOMEM;
+    goto err;
+  }
+  csbxxx_map.cached = ioremap_cached(csbxxx_map.phys, WINDOW_SIZE);
+  if (!csbxxx_map.cached)
+    printk(KERN_WARNING "Failed to ioremap cached %s\n", csbxxx_map.name);
+
+  simple_map_init(&csbxxx_map);
+  
+  printk(KERN_NOTICE "Probing %s at physical address 0x%08lx (%d-bit bankwidth)\n",
+	 csbxxx_map.name, csbxxx_map.phys, csbxxx_map.bankwidth * 8);
+  
+  mymtd = do_map_probe("cfi_probe", &csbxxx_map);
+  
+  if (!mymtd)
+    goto err;
+
+  mymtd->owner = THIS_MODULE;
+  
+  mtd_parts_nb = parse_mtd_partitions(mymtd, probes, &mtd_parts, 0);
+
+  if (mtd_parts_nb > 0)
+    part_type = "command line";
+  else if (mtd_parts_nb == 0)
+    {
+      mtd_parts = csbxxx_partitions;
+      mtd_parts_nb = NB_OF(csbxxx_partitions);
+      part_type = "static";
+    }
+  else goto err;
+
+#if 1
+#warning "TODO: is add_mtd_device needed?"
+#else
+  add_mtd_device(mymtd);
+#endif
+  if (mtd_parts_nb == 0)
+    printk(KERN_NOTICE MSG_PREFIX "no partition info available\n");
+  else
+    {
+      printk(KERN_NOTICE MSG_PREFIX
+	     "using %s partition definition\n", part_type);
+      add_mtd_partitions(mymtd, mtd_parts, mtd_parts_nb);
+    }
+  
+  return 0;
+
+err:
+  if (csbxxx_map.virt)
+    iounmap(csbxxx_map.virt);
+  if (csbxxx_map.cached)
+    iounmap(csbxxx_map.cached);
+  if (!ret)
+    ret = -EIO;
+
+  return ret;
+}
+
+static void __exit cleanup_csbxxx(void)
+{
+  if (!mymtd)
+    return;
+
+  del_mtd_partitions(mymtd);
+  
+  map_destroy(mymtd);
+  iounmap((void *)csbxxx_map.virt);
+  if (csbxxx_map.cached)
+    iounmap(csbxxx_map.cached);
+}
+
+module_init(init_csbxxx);
+module_exit(cleanup_csbxxx);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Bill Gatliff <bgat@billgatliff.com>");
+MODULE_DESCRIPTION("MTD map driver for Cogent CSBXXX");
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/drivers/net/Kconfig ipipe-2.6.14-imx21/drivers/net/Kconfig
--- linux-2.6.14/drivers/net/Kconfig	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/drivers/net/Kconfig	2008-02-21 22:09:00.000000000 +0100
@@ -2,6 +2,12 @@
 #
 # Network device configuration
 #
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
+#
 
 menu "Network device support"
 
@@ -307,6 +313,16 @@ config MAC89x0
 	  <file:Documentation/networking/net-modules.txt>.  This module will
 	  be called mac89x0.
 
+config CIRRUS
+       tristate "CS89x support (Cirrus driver)"
+       depends on (MACH_CSB625 || ARCH_CSB226 || MACH_CSB536 || MACH_CSB535)
+       ---help---
+         There are two drivers for Cirrus Logic CS89x0 devices.  This
+         driver seems to work better than the generic CS89x0 driver 
+         on ARM targets.  If you have a Cogent CSB226, CSB535,
+         CSB536, or CSB226 and you want to use the cs89x0 chip
+         present on those machines, select Y.
+
 config MACSONIC
 	tristate "Macintosh SONIC based ethernet (onboard, NuBus, LC, CS)"
 	depends on NET_ETHERNET && MAC
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/drivers/net/Makefile ipipe-2.6.14-imx21/drivers/net/Makefile
--- linux-2.6.14/drivers/net/Makefile	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/drivers/net/Makefile	2008-02-21 22:09:00.000000000 +0100
@@ -1,6 +1,12 @@
 #
 # Makefile for the Linux network (ethercard) device drivers.
 #
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
+#
 
 ifeq ($(CONFIG_ISDN_PPP),y)
   obj-$(CONFIG_ISDN) += slhc.o
@@ -178,6 +184,7 @@ obj-$(CONFIG_CS89x0) += cs89x0.o
 obj-$(CONFIG_MACSONIC) += macsonic.o
 obj-$(CONFIG_MACMACE) += macmace.o
 obj-$(CONFIG_MAC89x0) += mac89x0.o
+obj-$(CONFIG_CIRRUS) += cirrus.o
 obj-$(CONFIG_TUN) += tun.o
 obj-$(CONFIG_DL2K) += dl2k.o
 obj-$(CONFIG_R8169) += r8169.o
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/drivers/net/cirrus.c ipipe-2.6.14-imx21/drivers/net/cirrus.c
--- linux-2.6.14/drivers/net/cirrus.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/drivers/net/cirrus.c	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,702 @@
+
+/*
+ * linux/drivers/net/cirrus.c
+ *
+ * Author: Abraham van der Merwe <abraham@2d3d.co.za>
+ *
+ * A Cirrus Logic CS8900A driver for Linux
+ * based on the cs89x0 driver written by Russell Nelson,
+ * Donald Becker, and others.
+ *
+ * This source code is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+/*
+ * At the moment the driver does not support memory mode operation.
+ * It is trivial to implement this, but not worth the effort.
+ */
+
+/*
+ * TODO:
+ *
+ *   1. If !ready in send_start(), queue buffer and send it in interrupt handler
+ *      when we receive a BufEvent with Rdy4Tx, send it again. dangerous!
+ *   2. how do we prevent interrupt handler destroying integrity of get_stats()?
+ *   3. Change reset code to check status.
+ *   4. Implement set_mac_address and remove fake mac address
+ *   5. Link status detection stuff
+ *   6. Write utility to write EEPROM, do self testing, etc.
+ *   7. Implement DMA routines (I need a board w/ DMA support for that)
+ *   8. Power management
+ *   9. Add support for multiple ethernet chips
+ *  10. Add support for other cs89xx chips (need hardware for that)
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+#include "cirrus.h"
+
+/* #define DEBUG */
+/* #define FULL_DUPLEX */
+
+
+typedef struct {
+	struct net_device_stats stats;
+	u16 txlen;
+} cirrus_t;
+
+typedef struct {
+	u16 io_base;		/* I/O Base Address			*/
+	u16 irq;			/* Interrupt Number			*/
+	u16 dma;			/* DMA Channel Numbers		*/
+	u32 mem_base;		/* Memory Base Address		*/
+	u32 rom_base;		/* Boot PROM Base Address	*/
+	u32 rom_mask;		/* Boot PROM Address Mask	*/
+	u8 mac[6];			/* Individual Address		*/
+} cirrus_eeprom_t;
+
+/*
+ * I/O routines
+ */
+
+static inline u16 cirrus_read (struct net_device *dev,u16 reg)
+{
+	CIRRUS_outw (reg, dev->base_addr, PP_Address);
+	return (CIRRUS_inw (dev->base_addr, PP_Data));
+}
+
+static inline void cirrus_write (struct net_device *dev,u16 reg,u16 value)
+{
+	CIRRUS_outw (reg, dev->base_addr, PP_Address);
+	CIRRUS_outw (value, dev->base_addr, PP_Data);
+}
+
+static inline void cirrus_set (struct net_device *dev,u16 reg,u16 value)
+{
+	cirrus_write (dev,reg,cirrus_read (dev,reg) | value);
+}
+
+static inline void cirrus_clear (struct net_device *dev,u16 reg,u16 value)
+{
+	cirrus_write (dev,reg,cirrus_read (dev,reg) & ~value);
+}
+
+static inline void cirrus_frame_read (struct net_device *dev,struct sk_buff *skb,u16 length)
+{
+	CIRRUS_insw (dev->base_addr, 0, skb_put (skb,length), (length + 1) / 2);
+}
+
+static inline void cirrus_frame_write (struct net_device *dev,struct sk_buff *skb)
+{
+	CIRRUS_outsw (dev->base_addr, 0, skb->data, (skb->len + 1) / 2);
+}
+
+/*
+ * Debugging functions
+ */
+
+#ifdef DEBUG
+static inline int printable (int c)
+{
+	return ((c >= 32 && c <= 126) ||
+			(c >= 174 && c <= 223) ||
+			(c >= 242 && c <= 243) ||
+			(c >= 252 && c <= 253));
+}
+
+static void dump16 (struct net_device *dev,const u8 *s,size_t len)
+{
+	int i;
+	char str[128];
+
+	if (!len) return;
+
+	*str = '\0';
+
+	for (i = 0; i < len; i++) {
+		if (i && !(i % 4)) strcat (str," ");
+		sprintf (str,"%s%.2x ",str,s[i]);
+	}
+
+	for ( ; i < 16; i++) {
+		if (i && !(i % 4)) strcat (str," ");
+		strcat (str,"   ");
+	}
+
+	strcat (str," ");
+	for (i = 0; i < len; i++) sprintf (str,"%s%c",str,printable (s[i]) ? s[i] : '.');
+
+	printk (KERN_DEBUG "%s:     %s\n",dev->name,str);
+}
+
+static void hexdump (struct net_device *dev,const void *ptr,size_t size)
+{
+	const u8 *s = (u8 *) ptr;
+	int i;
+	for (i = 0; i < size / 16; i++, s += 16) dump16 (dev,s,16);
+	dump16 (dev,s,size % 16);
+}
+
+static void dump_packet (struct net_device *dev,struct sk_buff *skb,const char *type)
+{
+	printk (KERN_INFO "%s: %s %d byte frame %.2x:%.2x:%.2x:%.2x:%.2x:%.2x to %.2x:%.2x:%.2x:%.2x:%.2x:%.2x type %.4x\n",
+			dev->name,
+			type,
+			skb->len,
+			skb->data[0],skb->data[1],skb->data[2],skb->data[3],skb->data[4],skb->data[5],
+			skb->data[6],skb->data[7],skb->data[8],skb->data[9],skb->data[10],skb->data[11],
+			(skb->data[12] << 8) | skb->data[13]);
+	if (skb->len < 0x100) hexdump (dev,skb->data,skb->len);
+}
+#endif	/* #ifdef DEBUG */
+
+/*
+ * Driver functions
+ */
+
+static void cirrus_receive (struct net_device *dev)
+{
+	cirrus_t *priv = (cirrus_t *) dev->priv;
+	struct sk_buff *skb;
+	u16 status,length;
+
+	status = cirrus_read (dev,PP_RxStatus);
+	length = cirrus_read (dev,PP_RxLength);
+
+	if (!(status & RxOK)) {
+		priv->stats.rx_errors++;
+		if ((status & (Runt | Extradata))) priv->stats.rx_length_errors++;
+		if ((status & CRCerror)) priv->stats.rx_crc_errors++;
+		return;
+	}
+
+	if ((skb = dev_alloc_skb (length + 4)) == NULL) {
+		priv->stats.rx_dropped++;
+		return;
+	}
+
+	skb->dev = dev;
+	skb_reserve (skb,2);
+
+	cirrus_frame_read (dev,skb,length);
+
+#ifdef DEBUG
+	dump_packet (dev,skb,"recv");
+#endif	/* #ifdef DEBUG */
+
+	skb->protocol = eth_type_trans (skb,dev);
+
+	netif_rx (skb);
+	dev->last_rx = jiffies;
+
+	priv->stats.rx_packets++;
+	priv->stats.rx_bytes += length;
+}
+
+static int cirrus_send_start (struct sk_buff *skb,struct net_device *dev)
+{
+	cirrus_t *priv = (cirrus_t *) dev->priv;
+	u16 status;
+
+	netif_stop_queue (dev);
+
+	cirrus_write (dev,PP_TxCMD,TxStart (After5));
+	cirrus_write (dev,PP_TxLength,skb->len);
+
+	status = cirrus_read (dev,PP_BusST);
+
+	if ((status & TxBidErr)) {
+		printk (KERN_WARNING "%s: Invalid frame size %d!\n",dev->name,skb->len);
+		priv->stats.tx_errors++;
+		priv->stats.tx_aborted_errors++;
+		priv->txlen = 0;
+		return (1);
+	}
+
+	if (!(status & Rdy4TxNOW)) {
+#warning TODO: figure out how to eliminate this message, not just mask it.
+//		printk (KERN_WARNING "%s: Transmit buffer not free!\n",dev->name);
+		priv->stats.tx_errors++;
+		priv->txlen = 0;
+		/* FIXME: store skb and send it in interrupt handler */
+		return (1);
+	}
+
+	cirrus_frame_write (dev,skb);
+
+#ifdef DEBUG
+	dump_packet (dev,skb,"send");
+#endif	/* #ifdef DEBUG */
+
+	dev->trans_start = jiffies;
+
+	dev_kfree_skb (skb);
+
+	priv->txlen = skb->len;
+
+	return (0);
+}
+
+static irqreturn_t cirrus_interrupt (int irq,void *id,struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *) id;
+	cirrus_t *priv;
+	u16 status;
+
+	int handled = 0;
+
+	//printk("### Cirrus IRQ\n");
+	
+	if (dev->priv == NULL) {
+		printk (KERN_WARNING "%s: irq %d for unknown device.\n",dev->name,irq);
+		handled = 1;
+		return IRQ_RETVAL(handled);
+	}
+
+	priv = (cirrus_t *) dev->priv;
+
+	while ((status = cirrus_read (dev,PP_ISQ))) {
+		switch (RegNum (status)) {
+		case RxEvent:
+			cirrus_receive (dev);
+			handled = 1;
+			break;
+
+		case TxEvent:
+			priv->stats.collisions += ColCount (cirrus_read (dev,PP_TxCOL));
+			if (!(RegContent (status) & TxOK)) {
+				priv->stats.tx_errors++;
+				if ((RegContent (status) & Out_of_window)) priv->stats.tx_window_errors++;
+				if ((RegContent (status) & Jabber)) priv->stats.tx_aborted_errors++;
+				break;
+			} else if (priv->txlen) {
+				priv->stats.tx_packets++;
+				priv->stats.tx_bytes += priv->txlen;
+			}
+			priv->txlen = 0;
+			netif_wake_queue (dev);
+			handled = 1;
+			break;
+
+		case BufEvent:
+			if ((RegContent (status) & RxMiss)) {
+				u16 missed = MissCount (cirrus_read (dev,PP_RxMISS));
+				priv->stats.rx_errors += missed;
+				priv->stats.rx_missed_errors += missed;
+			}
+			if ((RegContent (status) & TxUnderrun)) {
+				priv->stats.tx_errors++;
+				priv->stats.tx_fifo_errors++;
+			}
+			/* FIXME: if Rdy4Tx, transmit last sent packet (if any) */
+			priv->txlen = 0;
+			netif_wake_queue (dev);
+			handled = 1;
+			break;
+
+		case TxCOL:
+			priv->stats.collisions += ColCount (cirrus_read (dev,PP_TxCOL));
+			handled = 1;
+			break;
+
+		case RxMISS:
+			status = MissCount (cirrus_read (dev,PP_RxMISS));
+			priv->stats.rx_errors += status;
+			priv->stats.rx_missed_errors += status;
+			handled = 1;
+			break;
+		}
+	}
+
+	return IRQ_RETVAL(handled);
+}
+
+static void cirrus_transmit_timeout (struct net_device *dev)
+{
+	cirrus_t *priv = (cirrus_t *) dev->priv;
+	priv->stats.tx_errors++;
+	priv->stats.tx_heartbeat_errors++;
+	priv->txlen = 0;
+	netif_wake_queue (dev);
+}
+
+static int cirrus_start (struct net_device *dev)
+{
+	int result;
+
+	/* valid ethernet address? */
+	if (!is_valid_ether_addr(dev->dev_addr)) {
+		printk(KERN_ERR "%s: invalid ethernet MAC address\n",dev->name);
+		return (-EINVAL);
+	}
+
+	/* install interrupt handler */
+	printk("%s: requesting interrupt %i\n", __FUNCTION__, dev->irq);
+	if ((result = request_irq (dev->irq,&cirrus_interrupt,0,dev->name,dev)) < 0) {
+		printk (KERN_ERR "%s: could not register interrupt %d\n",dev->name,dev->irq);
+		return (result);
+	}
+	
+#if defined(CONFIG_ARCH_CSB226)
+#warning TODO: move this into csb226.c.
+#if 0
+	set_irq_type(dev->irq, IRQT_RISING);
+#endif
+#endif
+
+	/* enable the ethernet controller */
+	cirrus_set (dev,PP_RxCFG,RxOKiE | BufferCRC | CRCerroriE | RuntiE | ExtradataiE);
+	cirrus_set (dev,PP_RxCTL,RxOKA | IndividualA | BroadcastA);
+	cirrus_set (dev,PP_TxCFG,TxOKiE | Out_of_windowiE | JabberiE);
+	cirrus_set (dev,PP_BufCFG,Rdy4TxiE | RxMissiE | TxUnderruniE | TxColOvfiE | MissOvfloiE);
+	cirrus_set (dev,PP_LineCTL,SerRxON | SerTxON);
+	cirrus_set (dev,PP_BusCTL,EnableRQ);
+
+#ifdef FULL_DUPLEX
+	cirrus_set (dev,PP_TestCTL,FDX);
+#endif	/* #ifdef FULL_DUPLEX */
+
+	/* start the queue */
+	netif_start_queue (dev);
+
+	return (0);
+}
+
+static int cirrus_stop (struct net_device *dev)
+{
+	/* disable ethernet controller */
+	cirrus_write (dev,PP_BusCTL,0);
+	cirrus_write (dev,PP_TestCTL,0);
+	cirrus_write (dev,PP_SelfCTL,0);
+	cirrus_write (dev,PP_LineCTL,0);
+	cirrus_write (dev,PP_BufCFG,0);
+	cirrus_write (dev,PP_TxCFG,0);
+	cirrus_write (dev,PP_RxCTL,0);
+	cirrus_write (dev,PP_RxCFG,0);
+
+	/* uninstall interrupt handler */
+	free_irq (dev->irq,dev);
+
+	/* stop the queue */
+	netif_stop_queue (dev);
+
+	return (0);
+}
+
+static int cirrus_set_mac_address (struct net_device *dev, void *p)
+{
+	struct sockaddr *addr = (struct sockaddr *)p;
+	int i;
+
+	if (netif_running(dev))
+		return -EBUSY;
+
+	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+
+	/* configure MAC address */
+	for (i = 0; i < ETH_ALEN; i += 2)
+		cirrus_write (dev,PP_IA + i,dev->dev_addr[i] | (dev->dev_addr[i + 1] << 8));
+
+	return 0;
+}
+
+static struct net_device_stats *cirrus_get_stats (struct net_device *dev)
+{
+	cirrus_t *priv = (cirrus_t *) dev->priv;
+	return (&priv->stats);
+}
+
+static void cirrus_set_receive_mode (struct net_device *dev)
+{
+	if ((dev->flags & IFF_PROMISC))
+		cirrus_set (dev,PP_RxCTL,PromiscuousA);
+	else
+		cirrus_clear (dev,PP_RxCTL,PromiscuousA);
+
+	if ((dev->flags & IFF_ALLMULTI) && dev->mc_list)
+		cirrus_set (dev,PP_RxCTL,MulticastA);
+	else
+		cirrus_clear (dev,PP_RxCTL,MulticastA);
+}
+
+static int cirrus_eeprom_wait (struct net_device *dev)
+{
+	int i;
+
+	for (i = 0; i < 200; i++) {
+		if (!(cirrus_read (dev,PP_SelfST) & SIBUSY))
+			return (0);
+		udelay (1);
+	}
+
+	return (-1);
+}
+
+static int cirrus_eeprom_read (struct net_device *dev,u16 *value,u16 offset)
+{
+	if (cirrus_eeprom_wait (dev) < 0)
+		return (-1);
+
+	cirrus_write (dev,PP_EEPROMCommand,offset | EEReadRegister);
+
+	if (cirrus_eeprom_wait (dev) < 0)
+		return (-1);
+
+	*value = cirrus_read (dev,PP_EEPROMData);
+
+	return (0);
+}
+
+static int cirrus_eeprom (struct net_device *dev,cirrus_eeprom_t *eeprom)
+{
+	u16 offset,buf[16],*word;
+	u8 checksum = 0,*byte;
+
+	if (cirrus_eeprom_read (dev,buf,0) < 0) {
+		read_timed_out:
+		printk (KERN_DEBUG "%s: EEPROM read timed out\n",dev->name);
+		return (-ETIMEDOUT);
+	}
+
+	if ((buf[0] >> 8) != 0xa1) {
+		printk (KERN_DEBUG "%s: No EEPROM present\n",dev->name);
+		return (-ENODEV);
+	}
+
+	if ((buf[0] & 0xff) < sizeof (buf)) {
+		eeprom_too_small:
+		printk (KERN_DEBUG "%s: EEPROM too small\n",dev->name);
+		return (-ENODEV);
+	}
+
+	for (offset = 1; offset < (buf[0] & 0xff); offset++) {
+		if (cirrus_eeprom_read (dev,buf + offset,offset) < 0)
+			goto read_timed_out;
+
+		if (buf[offset] == 0xffff)
+			goto eeprom_too_small;
+	}
+
+	if (buf[1] != 0x2020) {
+		printk (KERN_DEBUG "%s: Group Header #1 mismatch\n",dev->name);
+		return (-EIO);
+	}
+
+	if (buf[5] != 0x502c) {
+		printk (KERN_DEBUG "%s: Group Header #2 mismatch\n",dev->name);
+		return (-EIO);
+	}
+
+	if (buf[12] != 0x2158) {
+		printk (KERN_DEBUG "%s: Group Header #3 mismatch\n",dev->name);
+		return (-EIO);
+	}
+
+	eeprom->io_base = buf[2];
+	eeprom->irq = buf[3];
+	eeprom->dma = buf[4];
+	eeprom->mem_base = (buf[7] << 16) | buf[6];
+	eeprom->rom_base = (buf[9] << 16) | buf[8];
+	eeprom->rom_mask = (buf[11] << 16) | buf[10];
+
+	word = (u16 *) eeprom->mac;
+	for (offset = 0; offset < 3; offset++) word[offset] = buf[13 + offset];
+
+	byte = (u8 *) buf;
+	for (offset = 0; offset < sizeof (buf); offset++) checksum += byte[offset];
+
+	if (cirrus_eeprom_read (dev,&offset,0x10) < 0)
+		goto read_timed_out;
+
+	if ((offset >> 8) != (u8) (0x100 - checksum)) {
+		printk (KERN_DEBUG "%s: Checksum mismatch (expected 0x%.2x, got 0x%.2x instead\n",
+				dev->name,
+				(u8) (0x100 - checksum),
+				offset >> 8);
+		return (-EIO);
+	}
+
+	return (0);
+}
+
+/*
+ * Architecture dependant code
+ */
+
+#ifdef CONFIG_SA1100_FRODO
+static void frodo_reset (struct net_device *dev)
+{
+	int i;
+	volatile u16 value;
+
+	/* reset ethernet controller */
+	FRODO_CPLD_ETHERNET |= FRODO_ETH_RESET;
+	mdelay (50);
+	FRODO_CPLD_ETHERNET &= ~FRODO_ETH_RESET;
+	mdelay (50);
+
+	/* we tied SBHE to CHIPSEL, so each memory access ensure the chip is in 16-bit mode */
+	for (i = 0; i < 3; i++) value = cirrus_read (dev,0);
+
+	/* FIXME: poll status bit */
+}
+#endif	/* #ifdef CONFIG_SA1100_FRODO */
+
+/*
+ * Driver initialization routines
+ */
+
+static int io = 0;
+static int irq = 0;
+
+int __init cirrus_probe (struct net_device *dev)
+{
+	static cirrus_t priv;
+	int i;
+	u16 value;
+	cirrus_eeprom_t eeprom;
+	printk ("Cirrus Logic CS8900A driver for Linux (V0.02)\n");
+
+	memset (&priv,0,sizeof (cirrus_t));
+
+	ether_setup (dev);
+
+	dev->open               = cirrus_start;
+	dev->stop               = cirrus_stop;
+	dev->hard_start_xmit    = cirrus_send_start;
+	dev->get_stats          = cirrus_get_stats;
+	dev->set_multicast_list = cirrus_set_receive_mode;
+	dev->set_mac_address	= cirrus_set_mac_address;
+	dev->tx_timeout         = cirrus_transmit_timeout;
+	dev->watchdog_timeo     = HZ;
+
+#warning TODO: fix this hack
+	/* hack!! */ // 00:05:5D:DD:81:18
+	dev->dev_addr[0] = 0x00;
+	dev->dev_addr[1] = 0x00;
+	dev->dev_addr[2] = 0x02;
+	dev->dev_addr[3] = 0x50;
+	dev->dev_addr[4] = 0x10;
+	dev->dev_addr[5] = 0x08;
+
+	dev->if_port   = IF_PORT_10BASET;
+	dev->priv      = (void *) &priv;
+
+	SET_MODULE_OWNER (dev);
+
+	dev->base_addr = CIRRUS_IOADDR;
+	dev->irq = CIRRUS_IRQ;
+
+	/* module parameters override everything */
+	if (io > 0) dev->base_addr = io;
+	if (irq > 0) dev->irq = irq;
+
+	if (!dev->base_addr) {
+		printk (KERN_ERR
+				"%s: No default I/O base address defined. Use io=... or\n"
+				"%s: define CIRRUS_DEFAULT_IO for your platform\n",
+				dev->name,dev->name);
+		return (-EINVAL);
+	}
+
+	if (!dev->irq) {
+		printk (KERN_ERR
+				"%s: No default IRQ number defined. Use irq=... or\n"
+				"%s: define CIRRUS_DEFAULT_IRQ for your platform\n",
+				dev->name,dev->name);
+		return (-EINVAL);
+	}
+
+	if (!request_region (dev->base_addr,16,dev->name)) {
+		printk (KERN_ERR "%s: can't get I/O port address 0x%lx\n",dev->name,dev->base_addr);
+		return -EBUSY;
+	}
+
+#ifdef CONFIG_SA1100_FRODO
+	frodo_reset (dev);
+#endif	/* #ifdef CONFIG_SA1100_FRODO */
+
+	/* if an EEPROM is present, use it's MAC address */
+	if (!cirrus_eeprom (dev,&eeprom)) {
+		for (i = 0; i < 6; i++)
+			dev->dev_addr[i] = eeprom.mac[i];
+        }
+#if defined(CONFIG_MACH_CSB535) || defined(CONFIG_MACH_CSB536)
+        else {
+            for (i = 0; i < ETH_ALEN; i+=2) {
+                u16 val;
+                val = cirrus_read(dev, PP_IA+i);
+                dev->dev_addr[i] = val & 0xff;
+                dev->dev_addr[i+1] = (val >> 8) & 0xff;
+            }
+        }
+#endif
+	/* verify EISA registration number for Cirrus Logic */
+	if ((value = cirrus_read (dev,PP_ProductID)) != EISA_REG_CODE) {
+		printk (KERN_ERR "%s: incorrect signature 0x%.4x\n",dev->name,value);
+		return (-ENXIO);
+	}
+
+	/* verify chip version */
+	value = cirrus_read (dev,PP_ProductID + 2);
+	if (VERSION (value) != CS8900A) {
+		printk (KERN_ERR "%s: unknown chip version 0x%.8x\n",dev->name,VERSION (value));
+		return (-ENXIO);
+	}
+	printk (KERN_INFO "%s: CS8900A rev %c detected\n",dev->name,'B' + REVISION (value) - REV_B);
+
+	/* setup interrupt number */
+	cirrus_write (dev,PP_IntNum,0);
+
+	/* configure MAC address */
+	for (i = 0; i < ETH_ALEN; i += 2)
+		cirrus_write (dev,PP_IA + i,dev->dev_addr[i] | (dev->dev_addr[i + 1] << 8));
+
+	return (0);
+}
+
+static struct net_device dev;
+
+static int __init cirrus_init (void)
+{
+	memset (&dev,0,sizeof (struct net_device));
+	dev.init = cirrus_probe;
+	return (register_netdev (&dev));
+}
+
+static void __exit cirrus_cleanup (void)
+{
+	release_region (dev.base_addr,16);
+	unregister_netdev (&dev);
+}
+
+MODULE_AUTHOR ("Abraham van der Merwe <abraham@2d3d.co.za>");
+MODULE_DESCRIPTION ("Cirrus Logic CS8900A driver for Linux (V0.02)");
+MODULE_LICENSE ("GPL");
+MODULE_PARM_DESC (io,"I/O Base Address");
+MODULE_PARM (io,"i");
+MODULE_PARM_DESC (irq,"IRQ Number");
+MODULE_PARM (irq,"i");
+
+module_init (cirrus_init);
+module_exit (cirrus_cleanup);
+
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/drivers/net/cirrus.h ipipe-2.6.14-imx21/drivers/net/cirrus.h
--- linux-2.6.14/drivers/net/cirrus.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/drivers/net/cirrus.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,331 @@
+#ifndef CIRRUS_H
+#define CIRRUS_H
+
+/*
+ * linux/drivers/net/cirrus.h
+ *
+ * Author: Abraham van der Merwe <abraham@2d3d.co.za>
+ *
+ * A Cirrus Logic CS8900A driver for Linux
+ * based on the cs89x0 driver written by Russell Nelson,
+ * Donald Becker, and others.
+ *
+ * This source code is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+/*
+ * Ports
+ */
+
+#define PP_Address		0x0a	/* PacketPage Pointer Port (Section 4.10.10) */
+#define PP_Data			0x0c	/* PacketPage Data Port (Section 4.10.10) */
+
+/*
+ * Registers
+ */
+
+#define PP_ProductID		0x0000	/* Section 4.3.1   Product Identification Code */
+#define PP_MemBase			0x002c	/* Section 4.9.2   Memory Base Address Register */
+#define PP_IntNum			0x0022	/* Section 3.2.3   Interrupt Number */
+#define PP_EEPROMCommand	0x0040	/* Section 4.3.11  EEPROM Command */
+#define PP_EEPROMData		0x0042	/* Section 4.3.12  EEPROM Data */
+#define PP_RxCFG			0x0102	/* Section 4.4.6   Receiver Configuration */
+#define PP_RxCTL			0x0104	/* Section 4.4.8   Receiver Control */
+#define PP_TxCFG			0x0106	/* Section 4.4.9   Transmit Configuration */
+#define PP_BufCFG			0x010a	/* Section 4.4.12  Buffer Configuration */
+#define PP_LineCTL			0x0112	/* Section 4.4.16  Line Control */
+#define PP_SelfCTL			0x0114	/* Section 4.4.18  Self Control */
+#define PP_BusCTL			0x0116	/* Section 4.4.20  Bus Control */
+#define PP_TestCTL			0x0118	/* Section 4.4.22  Test Control */
+#define PP_ISQ				0x0120	/* Section 4.4.5   Interrupt Status Queue */
+#define PP_TxEvent			0x0128	/* Section 4.4.10  Transmitter Event */
+#define PP_BufEvent			0x012c	/* Section 4.4.13  Buffer Event */
+#define PP_RxMISS			0x0130	/* Section 4.4.14  Receiver Miss Counter */
+#define PP_TxCOL			0x0132	/* Section 4.4.15  Transmit Collision Counter */
+#define PP_SelfST			0x0136	/* Section 4.4.19  Self Status */
+#define PP_BusST			0x0138	/* Section 4.4.21  Bus Status */
+#define PP_TxCMD			0x0144	/* Section 4.4.11  Transmit Command */
+#define PP_TxLength			0x0146	/* Section 4.5.2   Transmit Length */
+#define PP_IA				0x0158	/* Section 4.6.2   Individual Address (IEEE Address) */
+#define PP_RxStatus			0x0400	/* Section 4.7.1   Receive Status */
+#define PP_RxLength			0x0402	/* Section 4.7.1   Receive Length (in bytes) */
+#define PP_RxFrame			0x0404	/* Section 4.7.2   Receive Frame Location */
+#define PP_TxFrame			0x0a00	/* Section 4.7.2   Transmit Frame Location */
+
+/*
+ * Values
+ */
+
+/* PP_IntNum */
+#define INTRQ0			0x0000
+#define INTRQ1			0x0001
+#define INTRQ2			0x0002
+#define INTRQ3			0x0003
+
+/* PP_ProductID */
+#define EISA_REG_CODE	0x630e
+#define REVISION(x)		(((x) & 0x1f00) >> 8)
+#define VERSION(x)		((x) & ~0x1f00)
+
+#define CS8900A			0x0000
+#define REV_B			7
+#define REV_C			8
+#define REV_D			9
+
+/* PP_RxCFG */
+#define Skip_1			0x0040
+#define StreamE			0x0080
+#define RxOKiE			0x0100
+#define RxDMAonly		0x0200
+#define AutoRxDMAE		0x0400
+#define BufferCRC		0x0800
+#define CRCerroriE		0x1000
+#define RuntiE			0x2000
+#define ExtradataiE		0x4000
+
+/* PP_RxCTL */
+#define IAHashA			0x0040
+#define PromiscuousA	0x0080
+#define RxOKA			0x0100
+#define MulticastA		0x0200
+#define IndividualA		0x0400
+#define BroadcastA		0x0800
+#define CRCerrorA		0x1000
+#define RuntA			0x2000
+#define ExtradataA		0x4000
+
+/* PP_TxCFG */
+#define Loss_of_CRSiE	0x0040
+#define SQErroriE		0x0080
+#define TxOKiE			0x0100
+#define Out_of_windowiE	0x0200
+#define JabberiE		0x0400
+#define AnycolliE		0x0800
+#define T16colliE		0x8000
+
+/* PP_BufCFG */
+#define SWint_X			0x0040
+#define RxDMAiE			0x0080
+#define Rdy4TxiE		0x0100
+#define TxUnderruniE	0x0200
+#define RxMissiE		0x0400
+#define Rx128iE			0x0800
+#define TxColOvfiE		0x1000
+#define MissOvfloiE		0x2000
+#define RxDestiE		0x8000
+
+/* PP_LineCTL */
+#define SerRxON			0x0040
+#define SerTxON			0x0080
+#define AUIonly			0x0100
+#define AutoAUI_10BT	0x0200
+#define ModBackoffE		0x0800
+#define PolarityDis		0x1000
+#define L2_partDefDis	0x2000
+#define LoRxSquelch		0x4000
+
+/* PP_SelfCTL */
+#define RESET			0x0040
+#define SWSuspend		0x0100
+#define HWSleepE		0x0200
+#define HWStandbyE		0x0400
+#define HC0E			0x1000
+#define HC1E			0x2000
+#define HCB0			0x4000
+#define HCB1			0x8000
+
+/* PP_BusCTL */
+#define ResetRxDMA		0x0040
+#define DMAextend		0x0100
+#define UseSA			0x0200
+#define MemoryE			0x0400
+#define DMABurst		0x0800
+#define IOCHRDYE		0x1000
+#define RxDMAsize		0x2000
+#define EnableRQ		0x8000
+
+/* PP_TestCTL */
+#define DisableLT		0x0080
+#define ENDECloop		0x0200
+#define AUIloop			0x0400
+#define DisableBackoff	0x0800
+#define FDX				0x4000
+
+/* PP_ISQ */
+#define RegNum(x) ((x) & 0x3f)
+#define RegContent(x) ((x) & ~0x3d)
+
+#define RxEvent			0x0004
+#define TxEvent			0x0008
+#define BufEvent		0x000c
+#define RxMISS			0x0010
+#define TxCOL			0x0012
+
+/* PP_RxStatus */
+#define IAHash			0x0040
+#define Dribblebits		0x0080
+#define RxOK			0x0100
+#define Hashed			0x0200
+#define IndividualAdr	0x0400
+#define Broadcast		0x0800
+#define CRCerror		0x1000
+#define Runt			0x2000
+#define Extradata		0x4000
+
+#define HashTableIndex(x) ((x) >> 0xa)
+
+/* PP_TxCMD */
+#define After5			0
+#define After381		1
+#define After1021		2
+#define AfterAll		3
+#define TxStart(x) ((x) << 6)
+
+#define Force			0x0100
+#define Onecoll			0x0200
+#define InhibitCRC		0x1000
+#define TxPadDis		0x2000
+
+/* PP_BusST */
+#define TxBidErr		0x0080
+#define Rdy4TxNOW		0x0100
+
+/* PP_TxEvent */
+#define Loss_of_CRS		0x0040
+#define SQEerror		0x0080
+#define TxOK			0x0100
+#define Out_of_window	0x0200
+#define Jabber			0x0400
+#define T16coll			0x8000
+
+#define TX_collisions(x) (((x) >> 0xb) & ~0x8000)
+
+/* PP_BufEvent */
+#define SWint			0x0040
+#define RxDMAFrame		0x0080
+#define Rdy4Tx			0x0100
+#define TxUnderrun		0x0200
+#define RxMiss			0x0400
+#define Rx128			0x0800
+#define RxDest			0x8000
+
+/* PP_RxMISS */
+#define MissCount(x) ((x) >> 6)
+
+/* PP_TxCOL */
+#define ColCount(x) ((x) >> 6)
+
+/* PP_SelfST */
+#define T3VActive		0x0040
+#define INITD			0x0080
+#define SIBUSY			0x0100
+#define EEPROMpresent	0x0200
+#define EEPROMOK		0x0400
+#define ELpresent		0x0800
+#define EEsize			0x1000
+
+/* PP_EEPROMCommand */
+#define EEWriteRegister	0x0100
+#define EEReadRegister	0x0200
+#define EEEraseRegister	0x0300
+#define ELSEL			0x0400
+
+
+/* --------------- Set Hardware Capabilities for CSB226 and CSB625 -------- */
+
+#if defined(CONFIG_ARCH_CSB226) || defined(CONFIG_MACH_CSB625) || defined(CONFIG_MACH_CSB535) || defined(CONFIG_MACH_CSB536) 
+
+#if defined(CONFIG_ARCH_CSB226)
+#  include <asm/arch/csb226.h>
+#elif defined(CONFIG_MACH_CSB625)
+#  include <asm/arch/csb625.h>
+#elif defined(CONFIG_MACH_CSB535)
+#  include <asm/arch/csb535.h>
+#elif defined(CONFIG_MACH_CSB536)
+#  include <asm/arch/csb536.h>
+#endif
+
+
+#define CIRRUS_inw(a, r)		readw((a) + (r*0x02))
+#define CIRRUS_outw(v, a, r)		writew(v, (a) + (r*0x02))
+#define CIRRUS_insw(a, r, p, l)		insw((a) + (r*0x02), p, l)
+#define CIRRUS_outsw(a, r, p, l)	outsw((a) + (r*0x02), p, l)
+
+#if defined(CONFIG_ARCH_CSB226)
+#  define CIRRUS_IOADDR			(CSB226_ETH_VIRT + 0x300)
+#  define CIRRUS_IRQ			CSB226_ETH_IRQ
+#elif defined(CONFIG_MACH_CSB625)
+#  define CIRRUS_IOADDR			(CSB625_ETH_VIRT + 0x300)
+#  define CIRRUS_IRQ			CSB625_ETH_IRQ
+#elif defined(CONFIG_MACH_CSB535)
+#  define CIRRUS_IOADDR			(CSB535_ETH_VIRT + 0x300)
+#  define CIRRUS_IRQ			CSB535_ETH_IRQ
+#elif defined(CONFIG_MACH_CSB536)
+#  define CIRRUS_IOADDR			(CSB536_ETH_VIRT + 0x300)
+#  define CIRRUS_IRQ			CSB536_ETH_IRQ
+#endif
+
+/* -------------------- Set Hardware Capabilities for frodo --------------- */
+
+#elif defined(CONFIG_SA1100_FRODO)
+
+#define CIRRUS_inb(a, r)		inb((a) + (r))
+#define CIRRUS_inw(a, r)		inw((a) + (r))
+#define CIRRUS_outb(v, a, r)		outb(v, (a) + (r))
+#define CIRRUS_outw(v, a, r)            outw(v, (a) + (r))
+#define CIRRUS_insw(a, r, p, l)		insw((a) + (r), p, l)
+#define CIRRUS_outsw(a, r, p, l)	outsw((a) + (r), p, l)
+
+#define CIRRUS_IOADDR			(FRODO_ETH_IO + 0x300)
+#define CIRRUS_IRQ			FRODO_ETH_IRQ
+
+/* -------------------- Set Hardware Capabilities for cerf ---------------- */
+
+#elif defined(CONFIG_SA1100_CERF)
+
+#define CIRRUS_inb(a, r)		inb((a) + (r))
+#define CIRRUS_inw(a, r)		inw((a) + (r))
+#define CIRRUS_outb(v, a, r)		outb(v, (a) + (r))
+#define CIRRUS_outw(v, a, r)            outw(v, (a) + (r))
+#define CIRRUS_insw(a, r, p, l)		insw((a) + (r), p, l)
+#define CIRRUS_outsw(a, r, p, l)	outsw((a) + (r), p, l)
+
+#define CIRRUS_IOADDR			(CERF_ETH_IO + 0x300)
+#define CIRRUS_IRQ			CERF_ETH_IRQ
+
+/* -------------------- Set Hardware Capabilities for CDB89712 ------------ */
+
+#elif defined(CONFIG_ARCH_CDB89712)
+
+#define CIRRUS_inb(a, r)		inb((a) + (r))
+#define CIRRUS_inw(a, r)		inw((a) + (r))
+#define CIRRUS_outb(v, a, r)		outb(v, (a) + (r))
+#define CIRRUS_outw(v, a, r)            outw(v, (a) + (r))
+#define CIRRUS_insw(a, r, p, l)		insw((a) + (r), p, l)
+#define CIRRUS_outsw(a, r, p, l)	outsw((a) + (r), p, l)
+
+#define CIRRUS_IOADDR			(ETHER_BASE + 0x300)
+#define CIRRUS_IRQ			IRQ_EINT3
+
+/* -------------------- ISA ----------------------------------------------- */
+
+#elif defined(CONFIG_ISA)
+
+#define CIRRUS_inb(a, r)		inb((a) + (r))
+#define CIRRUS_inw(a, r)		inw((a) + (r))
+#define CIRRUS_outb(v, a, r)		outb(v, (a) + (r))
+#define CIRRUS_outw(v, a, r)            outw(v, (a) + (r))
+#define CIRRUS_insw(a, r, p, l)		insw((a) + (r), p, l)
+#define CIRRUS_outsw(a, r, p, l)	outsw((a) + (r), p, l)
+
+#define CIRRUS_IOADDR			0
+#define CIRRUS_IRQ			0
+
+#else
+#error "FIXME..."
+#endif
+
+#endif	/* #ifndef CIRRUS_H */
+
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/drivers/pci/msi.c ipipe-2.6.14-imx21/drivers/pci/msi.c
--- linux-2.6.14/drivers/pci/msi.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/drivers/pci/msi.c	2008-02-21 22:09:00.000000000 +0100
@@ -146,6 +146,21 @@ static void unmask_MSI_irq(unsigned int 
 	msi_set_mask_bit(vector, 0);
 }
 
+#ifdef CONFIG_IPIPE
+static void ack_MSI_irq_w_maskbit(unsigned int vector)
+{
+    mask_MSI_irq(vector);
+    __ack_APIC_irq();
+}
+static void ack_MSI_irq_wo_maskbit(unsigned int vector)
+{
+    __ack_APIC_irq();
+}
+#else /* !CONFIG_IPIPE */
+#define ack_MSI_irq_wo_maskbit  do_nothing
+#define ack_MSI_irq_w_maskbit   mask_MSI_irq
+#endif /* CONFIG_IPIPE */
+
 static unsigned int startup_msi_irq_wo_maskbit(unsigned int vector)
 {
 	struct msi_desc *entry;
@@ -209,7 +224,7 @@ static struct hw_interrupt_type msix_irq
 	.shutdown	= shutdown_msi_irq,
 	.enable		= unmask_MSI_irq,
 	.disable	= mask_MSI_irq,
-	.ack		= mask_MSI_irq,
+	.ack		= ack_MSI_irq_w_maskbit,
 	.end		= end_msi_irq_w_maskbit,
 	.set_affinity	= set_msi_irq_affinity
 };
@@ -225,7 +240,7 @@ static struct hw_interrupt_type msi_irq_
 	.shutdown	= shutdown_msi_irq,
 	.enable		= unmask_MSI_irq,
 	.disable	= mask_MSI_irq,
-	.ack		= mask_MSI_irq,
+	.ack		= ack_MSI_irq_w_maskbit,
 	.end		= end_msi_irq_w_maskbit,
 	.set_affinity	= set_msi_irq_affinity
 };
@@ -241,7 +256,7 @@ static struct hw_interrupt_type msi_irq_
 	.shutdown	= shutdown_msi_irq,
 	.enable		= do_nothing,
 	.disable	= do_nothing,
-	.ack		= do_nothing,
+	.ack		= ack_MSI_irq_wo_maskbit,
 	.end		= end_msi_irq_wo_maskbit,
 	.set_affinity	= set_msi_irq_affinity
 };
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/drivers/serial/Kconfig ipipe-2.6.14-imx21/drivers/serial/Kconfig
--- linux-2.6.14/drivers/serial/Kconfig	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/drivers/serial/Kconfig	2008-02-21 22:09:00.000000000 +0100
@@ -3,6 +3,12 @@
 #
 # $Id: Kconfig,v 1.11 2004/03/11 18:08:04 lethal Exp $
 #
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
+#
 
 menu "Serial drivers"
 
@@ -444,12 +450,20 @@ config SERIAL_IMX
 	  If you have a machine based on a Motorola IMX CPU you
 	  can enable its onboard serial port by enabling this option.
 
+config SERIAL_IMX21
+	bool "IMX21 serial port support"
+	depends on ARM && ARCH_IMX21
+	select SERIAL_CORE
+	help
+	  If you have a machine based on a Motorola IMX21 CPU you
+	  can enable its onboard serial port by enabling this option.
+
 config SERIAL_IMX_CONSOLE
 	bool "Console on IMX serial port"
-	depends on SERIAL_IMX
+	depends on SERIAL_IMX || SERIAL_IMX21
 	select SERIAL_CORE_CONSOLE
 	help
-	  If you have enabled the serial port on the Motorola IMX
+	  If you have enabled the serial port on the Motorola IMX or IMX21
 	  CPU you can make it the console by answering Y to this option.
 
 	  Even if you say Y here, the currently visible virtual console
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/drivers/serial/Makefile ipipe-2.6.14-imx21/drivers/serial/Makefile
--- linux-2.6.14/drivers/serial/Makefile	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/drivers/serial/Makefile	2008-02-21 22:09:00.000000000 +0100
@@ -3,6 +3,12 @@
 #
 #  $Id: Makefile,v 1.8 2002/07/21 21:32:30 rmk Exp $
 #
+# March 2006 :
+# Adapted to ARM9 i.MX21/CSB535FS board by S.Gerber, G.Boutillier and D.Rossier
+# University of Applied Sciences Western Switzerland
+# Reconfigurable & Embedded Digital Systems, REDS Institute
+#
+#
 
 serial-8250-y :=
 serial-8250-$(CONFIG_SERIAL_8250_ACPI) += 8250_acpi.o
@@ -47,6 +53,7 @@ obj-$(CONFIG_SERIAL_SH_SCI) += sh-sci.o
 obj-$(CONFIG_SERIAL_SGI_L1_CONSOLE) += sn_console.o
 obj-$(CONFIG_SERIAL_CPM) += cpm_uart/
 obj-$(CONFIG_SERIAL_IMX) += imx.o
+obj-$(CONFIG_SERIAL_IMX21) += imx21.o
 obj-$(CONFIG_SERIAL_MPC52xx) += mpc52xx_uart.o
 obj-$(CONFIG_SERIAL_ICOM) += icom.o
 obj-$(CONFIG_SERIAL_M32R_SIO) += m32r_sio.o
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/drivers/serial/imx21.c ipipe-2.6.14-imx21/drivers/serial/imx21.c
--- linux-2.6.14/drivers/serial/imx21.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/drivers/serial/imx21.c	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,1002 @@
+/*
+ *  linux/drivers/serial/imx21.c
+ *
+ *  Driver for Motorola IMX serial ports
+ *
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ *  Author: Sascha Hauer <sascha@saschahauer.de>
+ *  Copyright (C) 2004 Pengutronix
+ *
+ *  Modified by: Stephen Donecker (sdonecker@sbcglobal.net)
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/config.h>
+
+#if defined(CONFIG_SERIAL_IMX_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+
+/* We've been assigned a range on the "Low-density serial ports" major */
+#define SERIAL_IMX_MAJOR	204
+#define MINOR_START		41
+
+#define NR_PORTS		2
+
+#define IMX_ISR_PASS_LIMIT	256
+
+/*
+ * This is the size of our serial port register set.
+ */
+#define UART_PORT_SIZE	0x100
+
+/*
+ * This determines how often we check the modem status signals
+ * for any change.  They generally aren't connected to an IRQ
+ * so we have to poll them.  We also check immediately before
+ * filling the TX fifo incase CTS has been dropped.
+ */
+#define MCTRL_TIMEOUT	(250*HZ/1000)
+
+#define DRIVER_NAME "IMX-uart"
+
+struct imx_port {
+	struct uart_port	port;
+#warning "Removed by JTM"
+//	struct timer_list	timer;
+	unsigned int		old_status;
+	int			irq;
+};
+
+/*
+ * Handle any change of modem status signal since we were last called.
+ */
+static void imx_mctrl_check(struct imx_port *sport)
+{
+	unsigned int status, changed;
+
+	status = sport->port.ops->get_mctrl(&sport->port);
+	changed = status ^ sport->old_status;
+
+	if (changed == 0)
+		return;
+
+	sport->old_status = status;
+
+	if (changed & TIOCM_RI)
+		sport->port.icount.rng++;
+	if (changed & TIOCM_DSR)
+		sport->port.icount.dsr++;
+	if (changed & TIOCM_CAR)
+		uart_handle_dcd_change(&sport->port, status & TIOCM_CAR);
+	if (changed & TIOCM_CTS)
+		uart_handle_cts_change(&sport->port, status & TIOCM_CTS);
+
+	wake_up_interruptible(&sport->port.info->delta_msr_wait);
+}
+
+/*
+ * This is our per-port timeout handler, for checking the
+ * modem status signals.
+ */
+static void imx_timeout(unsigned long data)
+{
+	struct imx_port *sport = (struct imx_port *)data;
+	unsigned long flags;
+
+	if (sport->port.info) {
+		spin_lock_irqsave(&sport->port.lock, flags);
+		imx_mctrl_check(sport);
+		spin_unlock_irqrestore(&sport->port.lock, flags);
+
+#warning "Removed by JTM"
+//		mod_timer(&sport->timer, jiffies + MCTRL_TIMEOUT);
+	}
+}
+
+/*
+ * interrupts disabled on entry
+ */
+static void imx_stop_tx(struct uart_port *port, unsigned int tty_stop)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+	UCR1((u32)sport->port.membase) &= ~UCR1_TXMPTYEN;
+}
+
+/*
+ * interrupts disabled on entry
+ */
+static void imx_stop_rx(struct uart_port *port)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+	UCR2((u32)sport->port.membase) &= ~UCR2_RXEN;
+}
+
+/*
+ * Set the modem control timer to fire immediately.
+ */
+static void imx_enable_ms(struct uart_port *port)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+
+#warning "Removed by JTM"
+//	mod_timer(&sport->timer, jiffies);
+}
+
+static inline void imx_transmit_buffer(struct imx_port *sport)
+{
+	struct circ_buf *xmit = &sport->port.info->xmit;
+
+	do {
+		/* send xmit->buf[xmit->tail]
+		 * out the port here */
+		URTX0((u32)sport->port.membase) = xmit->buf[xmit->tail];
+		xmit->tail = (xmit->tail + 1) &
+		         (UART_XMIT_SIZE - 1);
+		sport->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (!(UTS((u32)sport->port.membase) & UTS_TXFULL));
+
+	if (uart_circ_empty(xmit))
+		imx_stop_tx(&sport->port, 0);
+}
+
+/*
+ * interrupts disabled on entry
+ */
+static void imx_start_tx(struct uart_port *port, unsigned int tty_start)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+
+	UCR1((u32)sport->port.membase) |= UCR1_TXMPTYEN;
+
+	if(UTS((u32)sport->port.membase) & UTS_TXEMPTY)
+		imx_transmit_buffer(sport);
+}
+
+static irqreturn_t imx_txint(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct imx_port *sport = (struct imx_port *)dev_id;
+	struct circ_buf *xmit = &sport->port.info->xmit;
+	unsigned long flags;
+	
+	spin_lock_irqsave(&sport->port.lock,flags);
+	if (sport->port.x_char)
+	{
+		/* Send next char */
+		URTX0((u32)sport->port.membase) = sport->port.x_char;
+		goto out;
+	}
+
+	if (uart_circ_empty(xmit) || uart_tx_stopped(&sport->port)) {
+		imx_stop_tx(&sport->port, 0);
+		goto out;
+	}
+
+	imx_transmit_buffer(sport);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&sport->port);
+
+out:
+	spin_unlock_irqrestore(&sport->port.lock,flags);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t imx_rxint(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct imx_port *sport = dev_id;
+	unsigned int rx,flg,ignored = 0;
+	struct tty_struct *tty = sport->port.info->tty;
+	unsigned long flags;
+
+	rx = URXD0((u32)sport->port.membase);
+	spin_lock_irqsave(&sport->port.lock,flags);
+
+	do {
+		flg = TTY_NORMAL;
+		sport->port.icount.rx++;
+
+		if( USR2((u32)sport->port.membase) & USR2_BRCD ) {
+			USR2((u32)sport->port.membase) |= USR2_BRCD;
+			if(uart_handle_break(&sport->port))
+				goto ignore_char;
+		}
+
+		if (uart_handle_sysrq_char
+		            (&sport->port, (unsigned char)rx, regs))
+			goto ignore_char;
+
+		if( rx & (URXD_PRERR | URXD_OVRRUN | URXD_FRMERR) )
+			goto handle_error;
+
+	error_return:
+		tty_insert_flip_char(tty, rx, flg);
+
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+			goto out;
+
+	ignore_char:
+		rx = URXD0((u32)sport->port.membase);
+	} while(rx & URXD_CHARRDY);
+
+out:
+	spin_unlock_irqrestore(&sport->port.lock,flags);
+	tty_flip_buffer_push(tty);
+	return IRQ_HANDLED;
+
+handle_error:
+	if (rx & URXD_PRERR)
+		sport->port.icount.parity++;
+	else if (rx & URXD_FRMERR)
+		sport->port.icount.frame++;
+	if (rx & URXD_OVRRUN)
+		sport->port.icount.overrun++;
+
+	if (rx & sport->port.ignore_status_mask) {
+		if (++ignored > 100)
+			goto out;
+		goto ignore_char;
+	}
+
+	rx &= sport->port.read_status_mask;
+
+	if (rx & URXD_PRERR)
+		flg = TTY_PARITY;
+	else if (rx & URXD_FRMERR)
+		flg = TTY_FRAME;
+	if (rx & URXD_OVRRUN)
+		flg = TTY_OVERRUN;
+
+#ifdef SUPPORT_SYSRQ
+	sport->port.sysrq = 0;
+#endif
+	goto error_return;
+}
+
+/*
+ * Determine if this is a TX or RX int, call appropriate handler
+ */
+static irqreturn_t imx21_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+    	struct imx_port *sport = dev_id;
+
+	if ( USR1((u32)sport->port.membase) & USR1_TRDY )
+	    imx_txint(irq, dev_id, regs);
+	if ( USR1((u32)sport->port.membase) & USR1_RRDY )
+	    imx_rxint(irq, dev_id, regs);
+	return IRQ_HANDLED;
+}
+
+/*
+ * Return TIOCSER_TEMT when transmitter is not busy.
+ */
+static unsigned int imx_tx_empty(struct uart_port *port)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+
+	return USR2((u32)sport->port.membase) & USR2_TXDC ?  TIOCSER_TEMT : 0;
+}
+
+static unsigned int imx_get_mctrl(struct uart_port *port)
+{
+	return TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;
+}
+
+static void imx_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+}
+
+/*
+ * Interrupts always disabled.
+ */
+static void imx_break_ctl(struct uart_port *port, int break_state)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sport->port.lock, flags);
+
+	if ( break_state != 0 )
+		UCR1((u32)sport->port.membase) |= UCR1_SNDBRK;
+	else
+		UCR1((u32)sport->port.membase) &= ~UCR1_SNDBRK;
+
+	spin_unlock_irqrestore(&sport->port.lock, flags);
+}
+
+#define TXTL 2 /* reset default */
+#define RXTL 1 /* reset default */
+
+static int imx_startup(struct uart_port *port)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+	int retval;
+	unsigned int val;
+	unsigned long flags;
+	
+	/* set receiver / transmitter trigger level. We assume
+	 * that RFDIV has been set by the arch setup or by the bootloader.
+	 */
+	val = (UFCR((u32)sport->port.membase) & UFCR_RFDIV)  | TXTL<<10 | RXTL;
+	UFCR((u32)sport->port.membase) = val;
+;
+	/* disable the DREN bit (Data Ready interrupt enable) before
+	 * requesting IRQs
+	 */
+	UCR4((u32)sport->port.membase) &= ~UCR4_DREN;
+
+	/*
+	 * Allocate the IRQ
+	 */
+	retval = request_irq(sport->irq, imx21_int, 0,
+			     DRIVER_NAME, sport);
+	if (retval) {
+	        free_irq(sport->irq, sport);
+	        return retval;
+	}
+	
+
+	/*
+	 * Finally, clear and enable interrupts
+	 */
+
+	UCR1((u32)sport->port.membase) |=
+	                 (UCR1_TXMPTYEN | UCR1_RRDYEN | UCR1_UARTEN);
+
+	UCR2((u32)sport->port.membase) |= (UCR2_RXEN | UCR2_TXEN);
+	/*
+	 * Enable modem status interrupts
+	 */
+	spin_lock_irqsave(&sport->port.lock,flags);
+	imx_enable_ms(&sport->port);
+	spin_unlock_irqrestore(&sport->port.lock,flags);
+
+	return 0;
+
+}
+
+static void imx_shutdown(struct uart_port *port)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+
+	/*
+	 * Stop our timer.
+	 */
+#warning "Removed by JTM"
+//	del_timer_sync(&sport->timer);
+
+	/*
+	 * Free the interrupts
+	 */
+	free_irq(sport->irq, sport);
+
+	/*
+	 * Disable all interrupts, port and break condition.
+	 */
+
+	UCR1((u32)sport->port.membase) &=
+	                 ~(UCR1_TXMPTYEN | UCR1_RRDYEN | UCR1_UARTEN);
+}
+
+static void
+imx_set_termios(struct uart_port *port, struct termios *termios,
+		   struct termios *old)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+	unsigned long flags;
+	unsigned int ucr2, old_ucr1, old_txrxen, baud, quot;
+	unsigned int old_csize = old ? old->c_cflag & CSIZE : CS8;
+
+	/*
+	 * If we don't support modem control lines, don't allow
+	 * these to be set.
+	 */
+	if (0) {
+		termios->c_cflag &= ~(HUPCL | CRTSCTS | CMSPAR);
+		termios->c_cflag |= CLOCAL;
+	}
+
+	/*
+	 * We only support CS7 and CS8.
+	 */
+	while ((termios->c_cflag & CSIZE) != CS7 &&
+	       (termios->c_cflag & CSIZE) != CS8) {
+		termios->c_cflag &= ~CSIZE;
+		termios->c_cflag |= old_csize;
+		old_csize = CS8;
+	}
+
+	if ((termios->c_cflag & CSIZE) == CS8)
+		ucr2 = UCR2_WS | UCR2_SRST | UCR2_IRTS;
+	else
+		ucr2 = UCR2_SRST | UCR2_IRTS;
+
+	if (termios->c_cflag & CSTOPB)
+		ucr2 |= UCR2_STPB;
+	if (termios->c_cflag & PARENB) {
+		ucr2 |= UCR2_PREN;
+		if (!(termios->c_cflag & PARODD))
+			ucr2 |= UCR2_PROE;
+	}
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
+	quot = uart_get_divisor(port, baud);
+
+	spin_lock_irqsave(&sport->port.lock, flags);
+
+	sport->port.read_status_mask = 0;
+	if (termios->c_iflag & INPCK)
+		sport->port.read_status_mask |= (URXD_FRMERR | URXD_PRERR);
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		sport->port.read_status_mask |= URXD_BRK;
+
+	/*
+	 * Characters to ignore
+	 */
+	sport->port.ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		sport->port.ignore_status_mask |= URXD_PRERR;
+	if (termios->c_iflag & IGNBRK) {
+		sport->port.ignore_status_mask |= URXD_BRK;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			sport->port.ignore_status_mask |= URXD_OVRRUN;
+	}
+
+#warning "Removed by JTM"
+//	del_timer_sync(&sport->timer);
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	/*
+	 * disable interrupts and drain transmitter
+	 */
+	old_ucr1 = UCR1((u32)sport->port.membase);
+	UCR1((u32)sport->port.membase) &= ~(UCR1_TXMPTYEN | UCR1_RRDYEN);
+
+	while ( !(USR2((u32)sport->port.membase) & USR2_TXDC))
+		barrier();
+
+	/* then, disable everything */
+	old_txrxen = UCR2((u32)sport->port.membase) & ( UCR2_TXEN | UCR2_RXEN );
+	UCR2((u32)sport->port.membase) &= ~( UCR2_TXEN | UCR2_RXEN);
+
+	/* set the parity, stop bits and data size */
+	UCR2((u32)sport->port.membase) = ucr2;
+
+#if 0
+	{
+	    int rfdiv;
+	    int perclk1 = imx_get_perclk1();
+	    int uartclk;
+	    printk("baud was set to %d\n", baud);
+	    
+	    rfdiv =  (((UFCR((u32)sport->port.membase)) & UFCR_RFDIV)
+		      >> UFCR_RFDIV_SHF) ;
+	    
+	
+	    printk("sysclk=%d HZ\n", imx_get_system_clk());
+	    printk("clk1=%d HZ\n", perclk1);
+	
+	    printk("RFDIV=%d\n", rfdiv);
+	    uartclk = perclk1/rfdiv;
+	    printk("ref freq = %d\n", uartclk);
+	    printk("PCDR:5:0 = %d\n", PCDR1 & 0x3f);
+	    
+	}
+	
+
+#endif	
+	/* set the baud rate. We assume uartclk = 16 MHz
+	 *
+	 * baud * 16   UBIR - 1
+	 * --------- = --------
+	 *  uartclk    UBMR - 1
+	 */
+	// UBIR((u32)sport->port.membase) = (baud / 100) - 1;
+	// UBMR((u32)sport->port.membase) = 10000 - 1;
+#if 0
+#define BIR_115200	837
+#define BIR_DIV		9999
+	/*  I cant figure out why these numbers work, so using this formula
+	 *  and above numbers, I solved for uartclk and got
+	 *  22,995,227. Looks like it should be 11,998,549 (pclk1/4)???
+	 */
+#else
+#define BIR_DIV		999
+#define UCLK		22995227
+#define BIR(br)	(((16 * (br) * (BIR_DIV+1))/UCLK) + 1)
+#endif
+
+#warning "Changed by JTM"
+//	UBIR((u32)sport->port.membase) = BIR(baud);
+//	UBMR((u32)sport->port.membase) = BIR_DIV;
+	//	    UBIR((u32)sport->port.membase) = BIR_115200;
+	//	    UBMR((u32)sport->port.membase) = BIR_DIV;
+
+	UCR1((u32)sport->port.membase) = old_ucr1;
+	UCR2((u32)sport->port.membase) |= old_txrxen;
+
+	if (UART_ENABLE_MS(&sport->port, termios->c_cflag))
+		imx_enable_ms(&sport->port);
+
+	spin_unlock_irqrestore(&sport->port.lock, flags);
+}
+
+static const char *imx_type(struct uart_port *port)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+
+	return sport->port.type == PORT_IMX ? "IMX" : NULL;
+}
+
+/*
+ * Release the memory region(s) being used by 'port'.
+ */
+static void imx_release_port(struct uart_port *port)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+
+	release_mem_region(sport->port.mapbase, UART_PORT_SIZE);
+}
+
+/*
+ * Request the memory region(s) being used by 'port'.
+ */
+static int imx_request_port(struct uart_port *port)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+
+	return request_mem_region(sport->port.mapbase, UART_PORT_SIZE,
+			"imx-uart") != NULL ? 0 : -EBUSY;
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void imx_config_port(struct uart_port *port, int flags)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+
+	if (flags & UART_CONFIG_TYPE &&
+	    imx_request_port(&sport->port) == 0)
+		sport->port.type = PORT_IMX;
+}
+
+/*
+ * Verify the new serial_struct (for TIOCSSERIAL).
+ * The only change we allow are to the flags and type, and
+ * even then only between PORT_IMX and PORT_UNKNOWN
+ */
+static int
+imx_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	struct imx_port *sport = (struct imx_port *)port;
+	int ret = 0;
+	
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_IMX)
+		ret = -EINVAL;
+	if (sport->port.irq != ser->irq)
+		ret = -EINVAL;
+	if (ser->io_type != UPIO_MEM)
+		ret = -EINVAL;
+	if (sport->port.uartclk / 16 != ser->baud_base)
+		ret = -EINVAL;
+	if ((void *)sport->port.mapbase != ser->iomem_base)
+		ret = -EINVAL;
+	if (sport->port.iobase != ser->port)
+		ret = -EINVAL;
+	if (ser->hub6 != 0)
+		ret = -EINVAL;
+	return ret;
+}
+
+static struct uart_ops imx_pops = {
+	.tx_empty	= imx_tx_empty,
+	.set_mctrl	= imx_set_mctrl,
+	.get_mctrl	= imx_get_mctrl,
+	.stop_tx	= imx_stop_tx,
+	.start_tx	= imx_start_tx,
+	.stop_rx	= imx_stop_rx,
+	.enable_ms	= imx_enable_ms,
+	.break_ctl	= imx_break_ctl,
+	.startup	= imx_startup,
+	.shutdown	= imx_shutdown,
+	.set_termios	= imx_set_termios,
+	.type		= imx_type,
+	.release_port	= imx_release_port,
+	.request_port	= imx_request_port,
+	.config_port	= imx_config_port,
+	.verify_port	= imx_verify_port,
+};
+
+static struct imx_port imx_ports[] = {
+	{
+	.irq  = INT_UART1,
+	.port	= {
+		.type		= PORT_IMX,
+		.iotype		= SERIAL_IO_MEM,
+		.membase	= (void *)MX2ADS_UART1_BASE,
+		.mapbase	= MX2ADS_UART1_BASE, /* FIXME */
+		.irq		= INT_UART1,
+		.uartclk	= 16000000,
+		.fifosize	= 8,
+		.flags		= ASYNC_BOOT_AUTOCONF,
+		.ops		= &imx_pops,
+		.line		= 0,
+	},
+	}, {
+	.irq  = INT_UART2,
+	.port	= {
+		.type		= PORT_IMX,
+		.iotype		= SERIAL_IO_MEM,
+		.membase	= (void *)MX2ADS_UART2_BASE,
+		.mapbase	= MX2ADS_UART2_BASE, /* FIXME */
+		.irq		= INT_UART2,
+		.uartclk	= 16000000,
+		.fifosize	= 8,
+		.flags		= ASYNC_BOOT_AUTOCONF,
+		.ops		= &imx_pops,
+		.line		= 1,
+	},
+	}
+};
+
+/*
+ * Setup the IMX serial ports.
+ * Note also that we support "console=ttySMXx" where "x" is either 0 or 1.
+ * Which serial port this ends up being depends on the machine you're
+ * running this kernel on.  I'm not convinced that this is a good idea,
+ * but that's the way it traditionally works.
+ *
+ */
+static void __init imx_init_ports(void)
+{
+	static int	first = 1;
+	int		i;
+	struct imx_port *sport;
+	
+	if (!first)
+		return;
+	first = 0;
+
+#if 0
+	
+#if 1 
+
+	/* Enable HCLK input to the UART1 module */
+	CRM_PCCR0 |= PCCR0_UART1_EN;
+
+	// software reset
+	for (i = 0; i < ARRAY_SIZE(imx_ports); i++) {
+	        sport = &imx_ports[i];
+		UCR2((u32)sport->port.membase) = 0x0;
+	
+		//write 1 to RXDMUXSEL = 1
+		UCR3((u32)sport->port.membase) |= 0x4;
+	}
+#endif
+
+	for (i = 0; i < ARRAY_SIZE(imx_ports); i++) {
+#warning "Removed by JTM"
+//	        init_timer(&imx_ports[i].timer);
+#warning "Removed by JTM"
+//		imx_ports[i].timer.function = imx_timeout;
+#warning "Removed by JTM"
+//		imx_ports[i].timer.data     = (unsigned long)&imx_ports[i];
+	}
+
+	/* See section 37.2 in I.MX21 RM */
+	imx21_gpio_mode(PE14_PF_UART1_CTS);
+	imx21_gpio_mode(PE15_PF_UART1_RTS);
+	imx21_gpio_mode(PE12_PF_UART1_TXD);
+	imx21_gpio_mode(PE13_PF_UART1_RXD);
+
+#if 0
+	imx21_gpio_mode(PB28_PF_UART2_CTS);
+	imx21_gpio_mode(PB29_PF_UART2_RTS);
+	imx21_gpio_mode(PB30_PF_UART2_TXD);
+	imx21_gpio_mode(PB31_PF_UART2_RXD);
+#endif
+
+#if 1
+	sport = &imx_ports[UART_1];
+	
+	//software reset
+	UCR2((u32)sport->port.membase) = 0x61E6;
+	UCR1 ((u32)sport->port.membase)= 0x0;
+	UCR3((u32)sport->port.membase) = 0x4;
+	UCR4 ((u32)sport->port.membase)= 0x8000;
+
+	// configure appropriate pins for UART_1_RX, UART_1_TX,
+	// UART2_RX and UART2_TX		
+	
+    UCR1 ((u32)sport->port.membase)= 0x0005; // UARTEN = 1,enable the clock
+    //UUCR2 = CTSC,TXEN,RXEN=1,reset, ignore IRTS bit, WS = 1 , 
+    //8 bit tx and rx,1 stop bit, disable parity
+    UCR2((u32)sport->port.membase) = 0x6026;		
+    UCR3((u32)sport->port.membase) = 0x0004;		
+    UCR4((u32)sport->port.membase) = 0x8000;		
+
+    //=================================================================
+    // Set up reference freq divide for UART module 
+    // MX2 only support 16MHz output
+    // PerCLK1(31.99998691MHz)/UFCR[RFDIV] (2)= 15.99999673MHz
+    UFCR((u32)sport->port.membase) = 0x0a01; 	// CKIH = PerCLK1 set to div by 1 (UART 1)
+
+    //=================================================================
+
+    //clear loopback bit
+    UTS((u32)sport->port.membase) = 0x0000;
+#endif
+#endif
+}
+
+#ifdef CONFIG_SERIAL_IMX_CONSOLE
+
+/*
+ * Interrupts are disabled on entering
+ */
+static void
+imx_console_write(struct console *co, const char *s, unsigned int count)
+{
+	struct imx_port *sport = &imx_ports[co->index];
+	unsigned int old_ucr1, old_ucr2, i;
+
+	/*
+	 *	First, save UCR1/2 and then disable interrupts
+	 */
+	old_ucr1 = UCR1((u32)sport->port.membase);
+	old_ucr2 = UCR2((u32)sport->port.membase);
+
+	UCR1((u32)sport->port.membase) =
+	                   (old_ucr1 | UCR1_UARTEN)
+	                   & ~(UCR1_TXMPTYEN | UCR1_RRDYEN);
+	UCR2((u32)sport->port.membase) = old_ucr2 | UCR2_TXEN;
+
+	/*
+	 *	Now, do each character
+	 */
+	for (i = 0; i < count; i++) {
+
+		while ((UTS((u32)sport->port.membase) & UTS_TXFULL))
+			barrier();
+
+		URTX0((u32)sport->port.membase) = s[i];
+
+		if (s[i] == '\n') {
+			while ((UTS((u32)sport->port.membase) & UTS_TXFULL))
+				barrier();
+			URTX0((u32)sport->port.membase) = '\r';
+		}
+	}
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore UCR1/2
+	 */
+	while (!(USR2((u32)sport->port.membase) & USR2_TXDC));
+
+	UCR1((u32)sport->port.membase) = old_ucr1;
+	UCR2((u32)sport->port.membase) = old_ucr2;
+}
+
+/*
+ * If the port was already initialised (eg, by a boot loader),
+ * try to determine the current setup.
+ */
+static void __init
+imx_console_get_options(struct imx_port *sport, int *baud,
+			   int *parity, int *bits)
+{
+    
+	if ( UCR1((u32)sport->port.membase) | UCR1_UARTEN ) {
+		/* ok, the port was enabled */
+		unsigned int ucr2, ubir,ubmr, uartclk;
+
+		ucr2 = UCR2((u32)sport->port.membase);
+
+		*parity = 'n';
+		if (ucr2 & UCR2_PREN) {
+			if (ucr2 & UCR2_PROE)
+				*parity = 'o';
+			else
+				*parity = 'e';
+		}
+
+		if (ucr2 & UCR2_WS)
+			*bits = 8;
+		else
+			*bits = 7;
+
+		ubir = UBIR((u32)sport->port.membase) & 0xffff;
+		ubmr = UBMR((u32)sport->port.membase) & 0xffff;
+		uartclk = sport->port.uartclk;
+
+		*baud = ((uartclk/16) * (ubir + 1)) / (ubmr + 1);
+	}
+}
+
+static int __init
+imx_console_setup(struct console *co, char *options)
+{
+	struct imx_port *sport;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+	
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (co->index == -1 || co->index >= ARRAY_SIZE(imx_ports))
+		co->index = 0;
+	sport = &imx_ports[co->index];
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		imx_console_get_options(sport, &baud, &parity, &bits);
+
+	return uart_set_options(&sport->port, co, baud, parity, bits, flow);
+}
+
+extern struct uart_driver imx_reg;
+static struct console imx_console = {
+	.name		= "ttySMX",
+	.write		= imx_console_write,
+	.device		= uart_console_device,
+	.setup		= imx_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &imx_reg,
+};
+
+static int __init imx_rs_console_init(void)
+{
+	imx_init_ports();
+	register_console(&imx_console);
+	return 0;
+}
+console_initcall(imx_rs_console_init);
+
+#define IMX_CONSOLE	&imx_console
+#else
+#define IMX_CONSOLE	NULL
+#endif
+
+static struct uart_driver imx_reg = {
+	.owner          = THIS_MODULE,
+	.driver_name    = DRIVER_NAME,
+	.dev_name       = "ttySMX",
+	.devfs_name	= "ttsmx/",
+	.major          = SERIAL_IMX_MAJOR,
+	.minor          = MINOR_START,
+	.nr             = ARRAY_SIZE(imx_ports),
+	.cons           = IMX_CONSOLE,
+};
+
+static int serial_imx_suspend(struct device *_dev, u32 state, u32 level)
+{
+        struct imx_port *sport = dev_get_drvdata(_dev);
+
+        if (sport && level == SUSPEND_DISABLE)
+                uart_suspend_port(&imx_reg, &sport->port);
+
+        return 0;
+}
+
+static int serial_imx_resume(struct device *_dev, u32 level)
+{
+        struct imx_port *sport = dev_get_drvdata(_dev);
+
+        if (sport && level == RESUME_ENABLE)
+                uart_resume_port(&imx_reg, &sport->port);
+
+        return 0;
+}
+
+static int serial_imx_probe(struct device *_dev)
+{
+	struct platform_device *dev = to_platform_device(_dev);
+
+	imx_ports[dev->id].port.dev = _dev;
+	uart_add_one_port(&imx_reg, &imx_ports[dev->id].port);
+	dev_set_drvdata(_dev, &imx_ports[dev->id]);
+	return 0;
+}
+
+static int serial_imx_remove(struct device *_dev)
+{
+	struct imx_port *sport = dev_get_drvdata(_dev);
+
+	dev_set_drvdata(_dev, NULL);
+
+	if (sport)
+		uart_remove_one_port(&imx_reg, &sport->port);
+
+	return 0;
+}
+
+static struct device_driver serial_imx_driver = {
+        .name           = "imx21-uart",
+        .bus            = &platform_bus_type,
+        .probe          = serial_imx_probe,
+        .remove         = serial_imx_remove,
+
+	.suspend	= serial_imx_suspend,
+	.resume		= serial_imx_resume,
+};
+
+static int __init imx_serial_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "Serial: IMX driver\n");
+
+	imx_init_ports();
+
+	ret = uart_register_driver(&imx_reg);
+	if (ret)
+		return ret;
+
+	ret = driver_register(&serial_imx_driver);
+	if (ret != 0)
+		uart_unregister_driver(&imx_reg);
+
+	return 0;
+}
+
+static void __exit imx_serial_exit(void)
+{
+	uart_unregister_driver(&imx_reg);
+}
+
+module_init(imx_serial_init);
+module_exit(imx_serial_exit);
+
+MODULE_AUTHOR("Sascha Hauer");
+MODULE_DESCRIPTION("IMX generic serial port driver");
+MODULE_LICENSE("GPL");
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx/imx-regs.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx/imx-regs.h
--- linux-2.6.14/include/asm-arm/arch-imx/imx-regs.h	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx/imx-regs.h	2008-02-21 22:09:00.000000000 +0100
@@ -1,481 +1,618 @@
-#ifndef _IMX_REGS_H
-#define _IMX_REGS_H
+#ifndef _MX2ADS_REGS_H
+#define _MX2ADS_REGS_H
 /* ------------------------------------------------------------------------
- *  Motorola IMX system registers
+ *  Freescale i.iMX21 system registers
  * ------------------------------------------------------------------------
  *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * Modified by: Stephen Donecker (sdonecker@sbcglobal.net)
+ *
+ * April 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board with Xenomai by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ * 
+*/
+
+/*
+ * Memory mapped I/O for the M9328MX21ADS    
+ *
+ * TODO: move these defines to an appropiate board specific file
  */
 
+#define MX2ADS_MMIO_PHYS	(0xCC800000)
+#define MX2ADS_MMIO_OFFSET	MX2ADS_MMIO_PHYS-IMX21_CS1_PHYS
+#define MMIO_REG		(*((volatile u16 *)(IMX21_CS1_VIRT+MX2ADS_MMIO_OFFSET)))
+
+#define MMIO_SD_WP		(1<<0)
+#define MMIO_SW_SEL		(1<<1)
+#define MMIO_RESET_E_UART	(1<<2)
+#define MMIO_RESET_BASE		(1<<3)
+#define MMIO_CSI_CTL2		(1<<4)
+#define MMIO_CSI_CTL1		(1<<5)
+#define MMIO_CSI_CTL0		(1<<6)
+#define MMIO_UART1_EN		(1<<7)
+#define MMIO_UART4_EN		(1<<8)
+#define	MMIO_LCDON		(1<<9)
+#define MMIO_IRDA_EN		(1<<10)
+#define MMIO_IRDA_FIR_SEL	(1<<11)
+#define MMIO_IRDA_MD0_B		(1<<12)
+#define MMIO_IRDA_MD1		(1<<13)
+#define MMIO_LED4_ON		(1<<14)
+#define MMIO_LED3_ON		(1<<15)
+
 /*
  *  Register BASEs, based on OFFSETs
  *
  */
-#define IMX_AIPI1_BASE             (0x00000 + IMX_IO_BASE)
-#define IMX_WDT_BASE               (0x01000 + IMX_IO_BASE)
-#define IMX_TIM1_BASE              (0x02000 + IMX_IO_BASE)
-#define IMX_TIM2_BASE              (0x03000 + IMX_IO_BASE)
-#define IMX_RTC_BASE               (0x04000 + IMX_IO_BASE)
-#define IMX_LCDC_BASE              (0x05000 + IMX_IO_BASE)
-#define IMX_UART1_BASE             (0x06000 + IMX_IO_BASE)
-#define IMX_UART2_BASE             (0x07000 + IMX_IO_BASE)
-#define IMX_PWM_BASE               (0x08000 + IMX_IO_BASE)
-#define IMX_DMAC_BASE              (0x09000 + IMX_IO_BASE)
-#define IMX_AIPI2_BASE             (0x10000 + IMX_IO_BASE)
-#define IMX_SIM_BASE               (0x11000 + IMX_IO_BASE)
-#define IMX_USBD_BASE              (0x12000 + IMX_IO_BASE)
-#define IMX_SPI1_BASE              (0x13000 + IMX_IO_BASE)
-#define IMX_MMC_BASE               (0x14000 + IMX_IO_BASE)
-#define IMX_ASP_BASE               (0x15000 + IMX_IO_BASE)
-#define IMX_BTA_BASE               (0x16000 + IMX_IO_BASE)
-#define IMX_I2C_BASE               (0x17000 + IMX_IO_BASE)
-#define IMX_SSI_BASE               (0x18000 + IMX_IO_BASE)
-#define IMX_SPI2_BASE              (0x19000 + IMX_IO_BASE)
-#define IMX_MSHC_BASE              (0x1A000 + IMX_IO_BASE)
-#define IMX_PLL_BASE               (0x1B000 + IMX_IO_BASE)
-#define IMX_GPIO_BASE              (0x1C000 + IMX_IO_BASE)
-#define IMX_EIM_BASE               (0x20000 + IMX_IO_BASE)
-#define IMX_SDRAMC_BASE            (0x21000 + IMX_IO_BASE)
-#define IMX_MMA_BASE               (0x22000 + IMX_IO_BASE)
-#define IMX_AITC_BASE              (0x23000 + IMX_IO_BASE)
-#define IMX_CSI_BASE               (0x24000 + IMX_IO_BASE)
 
-/* PLL registers */
-#define CSCR   __REG(IMX_PLL_BASE)        /* Clock Source Control Register */
-#define CSCR_SYSTEM_SEL (1<<16)
+/* TODO: Rename MX2ADS to processor specific name, not a board name */
 
-#define MPCTL0 __REG(IMX_PLL_BASE + 0x4)  /* MCU PLL Control Register 0 */
-#define MPCTL1 __REG(IMX_PLL_BASE + 0x8)  /* MCU PLL and System Clock Register 1 */
-#define SPCTL0 __REG(IMX_PLL_BASE + 0xc)  /* System PLL Control Register 0 */
-#define SPCTL1 __REG(IMX_PLL_BASE + 0x10) /* System PLL Control Register 1 */
-#define PCDR   __REG(IMX_PLL_BASE + 0x20) /* Peripheral Clock Divider Register */
+#define MX2ADS_AIPI1_BASE             (0x00000 + IMX21_IO_BASE)
+#define MX2ADS_AIPI2_BASE             (0x20000 + IMX21_IO_BASE)
 
-#define CSCR_MPLL_RESTART (1<<21)
+#define MX2ADS_DMA_BASE               (0x01000 + IMX21_IO_BASE)
+#define MX2ADS_WDT_BASE               (0x02000 + IMX21_IO_BASE)
+#define MX2ADS_GPT1_BASE              (0x03000 + IMX21_IO_BASE)
+#define MX2ADS_GPT2_BASE              (0x04000 + IMX21_IO_BASE)
+#define MX2ADS_GPT3_BASE              (0x05000 + IMX21_IO_BASE)
+#define MX2ADS_PWM_BASE               (0x06000 + IMX21_IO_BASE)
+#define MX2ADS_RTC_BASE               (0x07000 + IMX21_IO_BASE)
+#define MX2ADS_KPP_BASE               (0x08000 + IMX21_IO_BASE)
+#define MX2ADS_OWIRE_BASE             (0x09000 + IMX21_IO_BASE)
+#define MX2ADS_UART1_BASE             (0x0A000 + IMX21_IO_BASE)
+#define MX2ADS_UART2_BASE             (0x0B000 + IMX21_IO_BASE)
+#define MX2ADS_UART3_BASE             (0x0C000 + IMX21_IO_BASE)
+#define MX2ADS_UART4_BASE             (0x0D000 + IMX21_IO_BASE)
+#define MX2ADS_CSPI1_BASE             (0x0E000 + IMX21_IO_BASE)
+#define MX2ADS_CSPI2_BASE             (0x0F000 + IMX21_IO_BASE)
+#define MX2ADS_SSI1_BASE              (0x10000 + IMX21_IO_BASE)
+#define MX2ADS_SSI2_BASE              (0x11000 + IMX21_IO_BASE)
+#define MX2ADS_I2C_BASE               (0x12000 + IMX21_IO_BASE)
+#define MX2ADS_SDHC1_BASE             (0x13000 + IMX21_IO_BASE)
+#define MX2ADS_SDHC2_BASE             (0x14000 + IMX21_IO_BASE)
+#define MX2ADS_GPIO_BASE              (0x15000 + IMX21_IO_BASE)
+#define MX2ADS_AUDMUX_BASE            (0x16000 + IMX21_IO_BASE)
+#define MX2ADS_CSPI3_BASE	      (IMX21_IO_BASE + 0x17000)
+#define MX2ADS_LCDC_BASE              (0x21000 + IMX21_IO_BASE)
+#define MX2ADS_SLCDC_BASE             (0x22000 + IMX21_IO_BASE)
+#define MX2ADS_SAHARA_BASE            (0x23000 + IMX21_IO_BASE)
+#define MX2ADS_USBOTG_BASE            (0x24000 + IMX21_IO_BASE)
+#define MX2ADS_EMMA_BASE              (0x26000 + IMX21_IO_BASE)
+#define MX2ADS_CRM_BASE               (0x27000 + IMX21_IO_BASE)
+#define MX2ADS_FIRI_BASE              (0x28000 + IMX21_IO_BASE)
+#define MX2ADS_RNGA_BASE	      (IMX21_IO_BASE + 0x29000)
+#define MX2ADS_RTIC_BASE	      (IMX21_IO_BASE + 0x2A000)
+#define MX2ADS_JAM_BASE               (0x3E000 + IMX21_IO_BASE)
+#define MX2ADS_MAX_BASE               (0x3F000 + IMX21_IO_BASE)
+#define MX2ADS_AITC_BASE              (0x40000 + IMX21_IO_BASE)
+
+/*
+ * Interrupt controller
+ */
+#define AITC_NIVECSR		__REG(MX2ADS_AITC_BASE + 0x40)
+#define AITC_NIPRIORITY7	__REG(MX2ADS_AITC_BASE + 0x20)
+#define AITC_NIPRIORITY6	__REG(MX2ADS_AITC_BASE + 0x24)
+#define AITC_NIPRIORITY5	__REG(MX2ADS_AITC_BASE + 0x28)
+#define AITC_NIPRIORITY4	__REG(MX2ADS_AITC_BASE + 0x2C)
+#define AITC_NIPRIORITY3	__REG(MX2ADS_AITC_BASE + 0x30)
+#define AITC_NIPRIORITY2	__REG(MX2ADS_AITC_BASE + 0x34)
+#define AITC_NIPRIORITY1	__REG(MX2ADS_AITC_BASE + 0x38)
+#define AITC_NIPRIORITY0	__REG(MX2ADS_AITC_BASE + 0x3C)
+
+/*
+ * GPIOs
+ */
+#define GPIO_A	0
+#define GPIO_B	1
+#define GPIO_C	2
+#define GPIO_D	3
+#define GPIO_E	4
+#define GPIO_F	5
 
 /*
  *  GPIO Module and I/O Multiplexer
- *  x = 0..3 for reg_A, reg_B, reg_C, reg_D
+ *  x = 0..5 for reg_A, reg_B, reg_C, reg_D, reg_E, reg_F
  */
-#define DDIR(x)    __REG2(IMX_GPIO_BASE + 0x00, ((x) & 3) << 8)
-#define OCR1(x)    __REG2(IMX_GPIO_BASE + 0x04, ((x) & 3) << 8)
-#define OCR2(x)    __REG2(IMX_GPIO_BASE + 0x08, ((x) & 3) << 8)
-#define ICONFA1(x) __REG2(IMX_GPIO_BASE + 0x0c, ((x) & 3) << 8)
-#define ICONFA2(x) __REG2(IMX_GPIO_BASE + 0x10, ((x) & 3) << 8)
-#define ICONFB1(x) __REG2(IMX_GPIO_BASE + 0x14, ((x) & 3) << 8)
-#define ICONFB2(x) __REG2(IMX_GPIO_BASE + 0x18, ((x) & 3) << 8)
-#define DR(x)      __REG2(IMX_GPIO_BASE + 0x1c, ((x) & 3) << 8)
-#define GIUS(x)    __REG2(IMX_GPIO_BASE + 0x20, ((x) & 3) << 8)
-#define SSR(x)     __REG2(IMX_GPIO_BASE + 0x24, ((x) & 3) << 8)
-#define ICR1(x)    __REG2(IMX_GPIO_BASE + 0x28, ((x) & 3) << 8)
-#define ICR2(x)    __REG2(IMX_GPIO_BASE + 0x2c, ((x) & 3) << 8)
-#define IMR(x)     __REG2(IMX_GPIO_BASE + 0x30, ((x) & 3) << 8)
-#define ISR(x)     __REG2(IMX_GPIO_BASE + 0x34, ((x) & 3) << 8)
-#define GPR(x)     __REG2(IMX_GPIO_BASE + 0x38, ((x) & 3) << 8)
-#define SWR(x)     __REG2(IMX_GPIO_BASE + 0x3c, ((x) & 3) << 8)
-#define PUEN(x)    __REG2(IMX_GPIO_BASE + 0x40, ((x) & 3) << 8)
+#define DDIR(x)    __REG2(MX2ADS_GPIO_BASE + 0x00, ((x) & 7) << 8)
+#define OCR1(x)    __REG2(MX2ADS_GPIO_BASE + 0x04, ((x) & 7) << 8)
+#define OCR2(x)    __REG2(MX2ADS_GPIO_BASE + 0x08, ((x) & 7) << 8)
+#define ICONFA1(x) __REG2(MX2ADS_GPIO_BASE + 0x0c, ((x) & 7) << 8)
+#define ICONFA2(x) __REG2(MX2ADS_GPIO_BASE + 0x10, ((x) & 7) << 8)
+#define ICONFB1(x) __REG2(MX2ADS_GPIO_BASE + 0x14, ((x) & 7) << 8)
+#define ICONFB2(x) __REG2(MX2ADS_GPIO_BASE + 0x18, ((x) & 7) << 8)
+#define DR(x)      __REG2(MX2ADS_GPIO_BASE + 0x1c, ((x) & 7) << 8)
+#define GIUS(x)    __REG2(MX2ADS_GPIO_BASE + 0x20, ((x) & 7) << 8)
+#define SSR(x)     __REG2(MX2ADS_GPIO_BASE + 0x24, ((x) & 7) << 8)
+#define ICR1(x)    __REG2(MX2ADS_GPIO_BASE + 0x28, ((x) & 7) << 8)
+#define ICR2(x)    __REG2(MX2ADS_GPIO_BASE + 0x2c, ((x) & 7) << 8)
+#define IMR(x)     __REG2(MX2ADS_GPIO_BASE + 0x30, ((x) & 7) << 8)
+#define ISR(x)     __REG2(MX2ADS_GPIO_BASE + 0x34, ((x) & 7) << 8)
+#define GPR(x)     __REG2(MX2ADS_GPIO_BASE + 0x38, ((x) & 7) << 8)
+#define SWR(x)     __REG2(MX2ADS_GPIO_BASE + 0x3c, ((x) & 7) << 8)
+#define PUEN(x)    __REG2(MX2ADS_GPIO_BASE + 0x40, ((x) & 7) << 8)
+#define PMASK      __REG(MX2ADS_GPIO_BASE + 0x600)
 
-#define GPIO_PIN_MASK 0x1f
-#define GPIO_PORT_MASK (0x3 << 5)
+/*  ethernet controller IRQ is tied to UART3_RTS */ 
+#define NET_IRQ_BIT		(1 << 11)
 
-#define GPIO_PORT_SHIFT 5
-#define GPIO_PORTA (0<<5)
-#define GPIO_PORTB (1<<5)
-#define GPIO_PORTC (2<<5)
-#define GPIO_PORTD (3<<5)
+/*
+ *  GPIO Mode
+ *
+ *  The pin, port, data direction, pull-up enable, primary/alternate
+ *  function, output configuration, and input configuration are encoded in a 
+ *  single word as follows.
+ *
+ *  4:0 Pin (31-0)
+ *  7:5 Port (F-A)
+ *  8 Direction
+ *  9 PUEN
+ *  10:11 Primary Function,Alternate Function,GPIO
+ *  13:12 OCR
+ *  15:14 ICONF
+ * 
+ *  [ 15 14 | 13 12 | 11 10 | 9  |  8  | 7 6 5 | 4 3 2 1 0 ]
+ *  [ ICONF |  OCR  | P/A/G | PU | Dir | Port  |    Pin    ]
+ */
 
-#define GPIO_OUT   (1<<7)
-#define GPIO_IN    (0<<7)
-#define GPIO_PUEN  (1<<8)
+#define GPIO_PIN_MASK		(0x1f<<0)
 
-#define GPIO_PF    (0<<9)
-#define GPIO_AF    (1<<9)
+#define GPIO_PORT_POS		5
+#define GPIO_PORT_MASK		(0x3 << GPIO_PORT_POS)
+#define GPIO_PORTA 		(0 << GPIO_PORT_POS)
+#define GPIO_PORTB		(1 << GPIO_PORT_POS)
+#define GPIO_PORTC		(2 << GPIO_PORT_POS)
+#define GPIO_PORTD		(3 << GPIO_PORT_POS)
+#define GPIO_PORTE		(4 << GPIO_PORT_POS)
+#define GPIO_PORTF		(5 << GPIO_PORT_POS)
 
-#define GPIO_OCR_SHIFT 10
-#define GPIO_OCR_MASK (3<<10)
-#define GPIO_AIN   (0<<10)
-#define GPIO_BIN   (1<<10)
-#define GPIO_CIN   (2<<10)
-#define GPIO_DR    (3<<10)
+#define GPIO_DIR_MASK		(1<<8)
+#define GPIO_IN			(0<<8)
+#define GPIO_OUT		(1<<8)
 
-#define GPIO_AOUT_SHIFT 12
-#define GPIO_AOUT_MASK (3<<12)
-#define GPIO_AOUT     (0<<12)
-#define GPIO_AOUT_ISR (1<<12)
-#define GPIO_AOUT_0   (2<<12)
-#define GPIO_AOUT_1   (3<<12)
+#define GPIO_PU_MASK		(1<<9)
+#define GPIO_PUDIS		(0<<9)
+#define GPIO_PUEN		(1<<9)
 
-#define GPIO_BOUT_SHIFT 14
-#define GPIO_BOUT_MASK (3<<14)
-#define GPIO_BOUT      (0<<14)
-#define GPIO_BOUT_ISR  (1<<14)
-#define GPIO_BOUT_0    (2<<14)
-#define GPIO_BOUT_1    (3<<14)
+#define GPIO_FUNC_MASK		(0x3<<10)
+#define GPIO_PF			(0<<10)
+#define GPIO_AF			(1<<10)
+#define GPIO_GP			(2<<10)
 
-#define GPIO_GIUS      (1<<16)
+#define GPIO_OCR_POS		12
+#define GPIO_OCR_MASK		(0x3 << GPIO_OCR_POS)
+#define GPIO_AIN		(0 << GPIO_OCR_POS)
+#define GPIO_BIN		(1 << GPIO_OCR_POS)
+#define GPIO_CIN		(2 << GPIO_OCR_POS)
+#define GPIO_DR			(3 << GPIO_OCR_POS)
 
-/* assignements for GPIO alternate/primary functions */
+#define GPIO_ICONF_MASK		(0x3<<14)
+#define GPIO_AOUT		(1<<14)
+#define GPIO_BOUT		(2<<14)
 
-/* FIXME: This list is not completed. The correct directions are
- * missing on some (many) pins
+/*
+ *  Freescale i.MX21 GPIO signal multiplexing mode defines
  */
-#define PA0_AIN_SPI2_CLK     ( GPIO_GIUS | GPIO_PORTA | GPIO_OUT | 0 )
-#define PA0_AF_ETMTRACESYNC  ( GPIO_PORTA | GPIO_AF | 0 )
-#define PA1_AOUT_SPI2_RXD    ( GPIO_GIUS | GPIO_PORTA | GPIO_IN | 1 )
-#define PA1_PF_TIN           ( GPIO_PORTA | GPIO_PF | 1 )
-#define PA2_PF_PWM0          ( GPIO_PORTA | GPIO_OUT | GPIO_PF | 2 )
-#define PA3_PF_CSI_MCLK      ( GPIO_PORTA | GPIO_PF | 3 )
-#define PA4_PF_CSI_D0        ( GPIO_PORTA | GPIO_PF | 4 )
-#define PA5_PF_CSI_D1        ( GPIO_PORTA | GPIO_PF | 5 )
-#define PA6_PF_CSI_D2        ( GPIO_PORTA | GPIO_PF | 6 )
-#define PA7_PF_CSI_D3        ( GPIO_PORTA | GPIO_PF | 7 )
-#define PA8_PF_CSI_D4        ( GPIO_PORTA | GPIO_PF | 8 )
-#define PA9_PF_CSI_D5        ( GPIO_PORTA | GPIO_PF | 9 )
-#define PA10_PF_CSI_D6       ( GPIO_PORTA | GPIO_PF | 10 )
-#define PA11_PF_CSI_D7       ( GPIO_PORTA | GPIO_PF | 11 )
-#define PA12_PF_CSI_VSYNC    ( GPIO_PORTA | GPIO_PF | 12 )
-#define PA13_PF_CSI_HSYNC    ( GPIO_PORTA | GPIO_PF | 13 )
-#define PA14_PF_CSI_PIXCLK   ( GPIO_PORTA | GPIO_PF | 14 )
-#define PA15_PF_I2C_SDA      ( GPIO_PORTA | GPIO_OUT | GPIO_PF | 15 )
-#define PA16_PF_I2C_SCL      ( GPIO_PORTA | GPIO_OUT | GPIO_PF | 16 )
-#define PA17_AF_ETMTRACEPKT4 ( GPIO_PORTA | GPIO_AF | 17 )
-#define PA17_AIN_SPI2_SS     ( GPIO_GIUS | GPIO_PORTA | GPIO_OUT | 17 )
-#define PA18_AF_ETMTRACEPKT5 ( GPIO_PORTA | GPIO_AF | 18 )
-#define PA19_AF_ETMTRACEPKT6 ( GPIO_PORTA | GPIO_AF | 19 )
-#define PA20_AF_ETMTRACEPKT7 ( GPIO_PORTA | GPIO_AF | 20 )
-#define PA21_PF_A0           ( GPIO_PORTA | GPIO_PF | 21 )
-#define PA22_PF_CS4          ( GPIO_PORTA | GPIO_PF | 22 )
-#define PA23_PF_CS5          ( GPIO_PORTA | GPIO_PF | 23 )
-#define PA24_PF_A16          ( GPIO_PORTA | GPIO_PF | 24 )
-#define PA24_AF_ETMTRACEPKT0 ( GPIO_PORTA | GPIO_AF | 24 )
-#define PA25_PF_A17          ( GPIO_PORTA | GPIO_PF | 25 )
-#define PA25_AF_ETMTRACEPKT1 ( GPIO_PORTA | GPIO_AF | 25 )
-#define PA26_PF_A18          ( GPIO_PORTA | GPIO_PF | 26 )
-#define PA26_AF_ETMTRACEPKT2 ( GPIO_PORTA | GPIO_AF | 26 )
-#define PA27_PF_A19          ( GPIO_PORTA | GPIO_PF | 27 )
-#define PA27_AF_ETMTRACEPKT3 ( GPIO_PORTA | GPIO_AF | 27 )
-#define PA28_PF_A20          ( GPIO_PORTA | GPIO_PF | 28 )
-#define PA28_AF_ETMPIPESTAT0 ( GPIO_PORTA | GPIO_AF | 28 )
-#define PA29_PF_A21          ( GPIO_PORTA | GPIO_PF | 29 )
-#define PA29_AF_ETMPIPESTAT1 ( GPIO_PORTA | GPIO_AF | 29 )
-#define PA30_PF_A22          ( GPIO_PORTA | GPIO_PF | 30 )
-#define PA30_AF_ETMPIPESTAT2 ( GPIO_PORTA | GPIO_AF | 30 )
-#define PA31_PF_A23          ( GPIO_PORTA | GPIO_PF | 31 )
-#define PA31_AF_ETMTRACECLK  ( GPIO_PORTA | GPIO_AF | 31 )
-#define PB8_PF_SD_DAT0       ( GPIO_PORTB | GPIO_PF | GPIO_PUEN | 8 )
-#define PB8_AF_MS_PIO        ( GPIO_PORTB | GPIO_AF | 8 )
-#define PB9_PF_SD_DAT1       ( GPIO_PORTB | GPIO_PF | GPIO_PUEN  | 9 )
-#define PB9_AF_MS_PI1        ( GPIO_PORTB | GPIO_AF | 9 )
-#define PB10_PF_SD_DAT2      ( GPIO_PORTB | GPIO_PF | GPIO_PUEN  | 10 )
-#define PB10_AF_MS_SCLKI     ( GPIO_PORTB | GPIO_AF | 10 )
-#define PB11_PF_SD_DAT3      ( GPIO_PORTB | GPIO_PF | 11 )
-#define PB11_AF_MS_SDIO      ( GPIO_PORTB | GPIO_AF | 11 )
-#define PB12_PF_SD_CLK       ( GPIO_PORTB | GPIO_PF | 12 )
-#define PB12_AF_MS_SCLK0     ( GPIO_PORTB | GPIO_AF | 12 )
-#define PB13_PF_SD_CMD       ( GPIO_PORTB | GPIO_PF | GPIO_PUEN | 13 )
-#define PB13_AF_MS_BS        ( GPIO_PORTB | GPIO_AF | 13 )
-#define PB14_AF_SSI_RXFS     ( GPIO_PORTB | GPIO_AF | 14 )
-#define PB15_AF_SSI_RXCLK    ( GPIO_PORTB | GPIO_AF | 15 )
-#define PB16_AF_SSI_RXDAT    ( GPIO_PORTB | GPIO_IN | GPIO_AF | 16 )
-#define PB17_AF_SSI_TXDAT    ( GPIO_PORTB | GPIO_OUT | GPIO_AF | 17 )
-#define PB18_AF_SSI_TXFS     ( GPIO_PORTB | GPIO_AF | 18 )
-#define PB19_AF_SSI_TXCLK    ( GPIO_PORTB | GPIO_AF | 19 )
-#define PB20_PF_USBD_AFE     ( GPIO_PORTB | GPIO_PF | 20 )
-#define PB21_PF_USBD_OE      ( GPIO_PORTB | GPIO_PF | 21 )
-#define PB22_PFUSBD_RCV      ( GPIO_PORTB | GPIO_PF | 22 )
-#define PB23_PF_USBD_SUSPND  ( GPIO_PORTB | GPIO_PF | 23 )
-#define PB24_PF_USBD_VP      ( GPIO_PORTB | GPIO_PF | 24 )
-#define PB25_PF_USBD_VM      ( GPIO_PORTB | GPIO_PF | 25 )
-#define PB26_PF_USBD_VPO     ( GPIO_PORTB | GPIO_PF | 26 )
-#define PB27_PF_USBD_VMO     ( GPIO_PORTB | GPIO_PF | 27 )
-#define PB28_PF_UART2_CTS    ( GPIO_PORTB | GPIO_OUT | GPIO_PF | 28 )
-#define PB29_PF_UART2_RTS    ( GPIO_PORTB | GPIO_IN | GPIO_PF | 29 )
-#define PB30_PF_UART2_TXD    ( GPIO_PORTB | GPIO_OUT | GPIO_PF | 30 )
-#define PB31_PF_UART2_RXD    ( GPIO_PORTB | GPIO_IN | GPIO_PF | 31 )
-#define PC3_PF_SSI_RXFS      ( GPIO_PORTC | GPIO_PF | 3 )
-#define PC4_PF_SSI_RXCLK     ( GPIO_PORTC | GPIO_PF | 4 )
-#define PC5_PF_SSI_RXDAT     ( GPIO_PORTC | GPIO_IN | GPIO_PF | 5 )
-#define PC6_PF_SSI_TXDAT     ( GPIO_PORTC | GPIO_OUT | GPIO_PF | 6 )
-#define PC7_PF_SSI_TXFS      ( GPIO_PORTC | GPIO_PF | 7 )
-#define PC8_PF_SSI_TXCLK     ( GPIO_PORTC | GPIO_PF | 8 )
-#define PC9_PF_UART1_CTS     ( GPIO_PORTC | GPIO_OUT | GPIO_PF | 9 )
-#define PC10_PF_UART1_RTS    ( GPIO_PORTC | GPIO_IN | GPIO_PF | 10 )
-#define PC11_PF_UART1_TXD    ( GPIO_PORTC | GPIO_OUT | GPIO_PF | 11 )
-#define PC12_PF_UART1_RXD    ( GPIO_PORTC | GPIO_IN | GPIO_PF | 12 )
-#define PC13_PF_SPI1_SPI_RDY ( GPIO_PORTC | GPIO_PF | 13 )
-#define PC14_PF_SPI1_SCLK    ( GPIO_PORTC | GPIO_PF | 14 )
-#define PC15_PF_SPI1_SS      ( GPIO_PORTC | GPIO_PF | 15 )
-#define PC16_PF_SPI1_MISO    ( GPIO_PORTC | GPIO_PF | 16 )
-#define PC17_PF_SPI1_MOSI    ( GPIO_PORTC | GPIO_PF | 17 )
-#define PC24_BIN_UART3_RI    ( GPIO_GIUS | GPIO_PORTC | GPIO_OUT | GPIO_BIN | 24 )
-#define PC25_BIN_UART3_DSR   ( GPIO_GIUS | GPIO_PORTC | GPIO_OUT | GPIO_BIN | 25 )
-#define PC26_AOUT_UART3_DTR  ( GPIO_GIUS | GPIO_PORTC | GPIO_IN | 26 )
-#define PC27_BIN_UART3_DCD   ( GPIO_GIUS | GPIO_PORTC | GPIO_OUT | GPIO_BIN | 27 )
-#define PC28_BIN_UART3_CTS   ( GPIO_GIUS | GPIO_PORTC | GPIO_OUT | GPIO_BIN | 28 )
-#define PC29_AOUT_UART3_RTS  ( GPIO_GIUS | GPIO_PORTC | GPIO_IN | 29 )
-#define PC30_BIN_UART3_TX    ( GPIO_GIUS | GPIO_PORTC | GPIO_BIN | 30 )
-#define PC31_AOUT_UART3_RX   ( GPIO_GIUS | GPIO_PORTC | GPIO_IN | 31)
-#define PD6_PF_LSCLK         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 6 )
-#define PD7_PF_REV           ( GPIO_PORTD | GPIO_PF | 7 )
-#define PD7_AF_UART2_DTR     ( GPIO_GIUS | GPIO_PORTD | GPIO_IN | GPIO_AF | 7 )
-#define PD7_AIN_SPI2_SCLK    ( GPIO_GIUS | GPIO_PORTD | GPIO_AIN | 7 )
-#define PD8_PF_CLS           ( GPIO_PORTD | GPIO_PF | 8 )
-#define PD8_AF_UART2_DCD     ( GPIO_PORTD | GPIO_OUT | GPIO_AF | 8 )
-#define PD8_AIN_SPI2_SS      ( GPIO_GIUS | GPIO_PORTD | GPIO_AIN | 8 )
-#define PD9_PF_PS            ( GPIO_PORTD | GPIO_PF | 9 )
-#define PD9_AF_UART2_RI      ( GPIO_PORTD | GPIO_OUT | GPIO_AF | 9 )
-#define PD9_AOUT_SPI2_RXD    ( GPIO_GIUS | GPIO_PORTD | GPIO_IN | 9 )
-#define PD10_PF_SPL_SPR      ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 10 )
-#define PD10_AF_UART2_DSR    ( GPIO_PORTD | GPIO_OUT | GPIO_AF | 10 )
-#define PD10_AIN_SPI2_TXD    ( GPIO_GIUS | GPIO_PORTD | GPIO_OUT | 10 )
-#define PD11_PF_CONTRAST     ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 11 )
-#define PD12_PF_ACD_OE       ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 12 )
-#define PD13_PF_LP_HSYNC     ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 13 )
-#define PD14_PF_FLM_VSYNC    ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 14 )
-#define PD15_PF_LD0          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 15 )
-#define PD16_PF_LD1          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 16 )
-#define PD17_PF_LD2          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 17 )
-#define PD18_PF_LD3          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 18 )
-#define PD19_PF_LD4          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 19 )
-#define PD20_PF_LD5          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 20 )
-#define PD21_PF_LD6          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 21 )
-#define PD22_PF_LD7          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 22 )
-#define PD23_PF_LD8          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 23 )
-#define PD24_PF_LD9          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 24 )
-#define PD25_PF_LD10         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 25 )
-#define PD26_PF_LD11         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 26 )
-#define PD27_PF_LD12         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 27 )
-#define PD28_PF_LD13         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 28 )
-#define PD29_PF_LD14         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 29 )
-#define PD30_PF_LD15         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 30 )
-#define PD31_PF_TMR2OUT      ( GPIO_PORTD | GPIO_PF | 31 )
-#define PD31_BIN_SPI2_TXD    ( GPIO_GIUS | GPIO_PORTD | GPIO_BIN | 31 )
 
 /*
- * PWM controller
+ *  The GPIO pin naming convention was developed by the original unknown author. 
+ *  Although using defines for variables is always a good idea for portability, 
+ *  in this case the names are as specific as the values, and thus loose their 
+ *  portability. Ultimately the pin names should be changed to reflect the signal
+ *  name only.  
+ *
+ *  The current naming convention is as follows.
+ *
+ *  P(port)(pin)_(function)_(signal)
+ *
+ *  port = (A-F)
+ *  pin = (0-31)
+ *  function = (PF|AF|AIN|BIN|CIN|DR|AOUT|BOUT)
+ *  signal = signal name from datasheet
+ *
+ *  Remember that when in GPIO mode, AIN, BIN, CIN, and DR are inputs to the GPIO
+ *  peripheral module and represent outputs to the pin. Similarly AOUT, and BOUT
+ *  are outputs from the GPIO peripheral module and represent inputs to the physical 
+ *  pin in question. Refer to the multiplexing table in the section titled "Signal 
+ *  Descriptions and Pin Assignments" in the reference manual.
  */
-#define PWMC	__REG(IMX_PWM_BASE + 0x00)	/* PWM Control Register		*/
-#define PWMS	__REG(IMX_PWM_BASE + 0x04)	/* PWM Sample Register		*/
-#define PWMP	__REG(IMX_PWM_BASE + 0x08)	/* PWM Period Register		*/
-#define PWMCNT	__REG(IMX_PWM_BASE + 0x0C)	/* PWM Counter Register		*/
+   
+#define PE14_PF_UART1_CTS	( GPIO_PORTE | 14 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PE15_PF_UART1_RTS	( GPIO_PORTE | 15 | GPIO_PF | GPIO_IN | GPIO_PUDIS )
+#define PE12_PF_UART1_TXD	( GPIO_PORTE | 12 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PE13_PF_UART1_RXD	( GPIO_PORTE | 13 | GPIO_PF | GPIO_IN | GPIO_PUDIS )
 
-#define PWMC_HCTR		(0x01<<18)		/* Halfword FIFO Data Swapping	*/
-#define PWMC_BCTR		(0x01<<17)		/* Byte FIFO Data Swapping	*/
-#define PWMC_SWR		(0x01<<16)		/* Software Reset		*/
-#define PWMC_CLKSRC		(0x01<<15)		/* Clock Source			*/
-#define PWMC_PRESCALER(x)	(((x-1) & 0x7F) << 8)	/* PRESCALER			*/
-#define PWMC_IRQ		(0x01<< 7)		/* Interrupt Request		*/
-#define PWMC_IRQEN		(0x01<< 6)		/* Interrupt Request Enable	*/
-#define PWMC_FIFOAV		(0x01<< 5)		/* FIFO Available		*/
-#define PWMC_EN			(0x01<< 4)		/* Enables/Disables the PWM	*/
-#define PWMC_REPEAT(x)		(((x) & 0x03) << 2)	/* Sample Repeats		*/
-#define PWMC_CLKSEL(x)		(((x) & 0x03) << 0)	/* Clock Selection		*/
+#define PA5_PF_LSCLK		( GPIO_PORTA | 5 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA6_PF_LD0		( GPIO_PORTA | 6 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA7_PF_LD1		( GPIO_PORTA | 7 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA8_PF_LD2		( GPIO_PORTA | 8 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA9_PF_LD3		( GPIO_PORTA | 9 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA10_PF_LD4		( GPIO_PORTA | 10 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA11_PF_LD5		( GPIO_PORTA | 11 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA12_PF_LD6		( GPIO_PORTA | 12 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA13_PF_LD7		( GPIO_PORTA | 13 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA14_PF_LD8		( GPIO_PORTA | 14 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA15_PF_LD9		( GPIO_PORTA | 15 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA16_PF_LD10		( GPIO_PORTA | 16 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA17_PF_LD11		( GPIO_PORTA | 17 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA18_PF_LD12		( GPIO_PORTA | 18 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA19_PF_LD13		( GPIO_PORTA | 19 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA20_PF_LD14		( GPIO_PORTA | 20 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA21_PF_LD15		( GPIO_PORTA | 21 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA22_PF_LD16		( GPIO_PORTA | 22 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA23_PF_LD17		( GPIO_PORTA | 23 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA24_PF_REV		( GPIO_PORTA | 24 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA25_PF_CLS		( GPIO_PORTA | 25 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA26_PF_PS		( GPIO_PORTA | 26 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA27_PF_SPL_SPR		( GPIO_PORTA | 27 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA28_PF_HSYNC		( GPIO_PORTA | 28 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA29_PF_VSYNC		( GPIO_PORTA | 29 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA30_PF_CONTRAST	( GPIO_PORTA | 30 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA31_PF_OE_ACD		( GPIO_PORTA | 31 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
 
-#define PWMS_SAMPLE(x)		((x) & 0xFFFF)		/* Contains a two-sample word	*/
-#define PWMP_PERIOD(x)		((x) & 0xFFFF)		/* Represents the PWM's period	*/
-#define PWMC_COUNTER(x)		((x) & 0xFFFF)		/* Represents the current count value	*/
+/*
+ *  Freescale i.MX21 register defines
+ *
+ *  All register and field defines should conform to the following naming
+ *  convention, and preferably use the exact names from the corresponding
+ *  datasheets. 
+ *
+ *  #define <module>_<register>		<value>
+ *  #define <register>_<field><type>	<value>
+ *
+ *  Where <type> can be one of the following.
+ *
+ *  _POS = defines the field LSB bit position	
+ *  _MASK = defines the field mask
+ *  (x) = writes x to the field location
+ *
+ *  The POS and MASK entries will be defined on an as needed basis. 
+ */
 
 /*
- *  DMA Controller
+ *  Freescale i.MX21 clock controller registers
  */
-#define DCR     __REG(IMX_DMAC_BASE +0x00)	/* DMA Control Register */
-#define DISR    __REG(IMX_DMAC_BASE +0x04)	/* DMA Interrupt status Register */
-#define DIMR    __REG(IMX_DMAC_BASE +0x08)	/* DMA Interrupt mask Register */
-#define DBTOSR  __REG(IMX_DMAC_BASE +0x0c)	/* DMA Burst timeout status Register */
-#define DRTOSR  __REG(IMX_DMAC_BASE +0x10)	/* DMA Request timeout Register */
-#define DSESR   __REG(IMX_DMAC_BASE +0x14)	/* DMA Transfer Error Status Register */
-#define DBOSR   __REG(IMX_DMAC_BASE +0x18)	/* DMA Buffer overflow status Register */
-#define DBTOCR  __REG(IMX_DMAC_BASE +0x1c)	/* DMA Burst timeout control Register */
-#define WSRA    __REG(IMX_DMAC_BASE +0x40)	/* W-Size Register A */
-#define XSRA    __REG(IMX_DMAC_BASE +0x44)	/* X-Size Register A */
-#define YSRA    __REG(IMX_DMAC_BASE +0x48)	/* Y-Size Register A */
-#define WSRB    __REG(IMX_DMAC_BASE +0x4c)	/* W-Size Register B */
-#define XSRB    __REG(IMX_DMAC_BASE +0x50)	/* X-Size Register B */
-#define YSRB    __REG(IMX_DMAC_BASE +0x54)	/* Y-Size Register B */
-#define SAR(x)  __REG2( IMX_DMAC_BASE + 0x80, (x) << 6)	/* Source Address Registers */
-#define DAR(x)  __REG2( IMX_DMAC_BASE + 0x84, (x) << 6)	/* Destination Address Registers */
-#define CNTR(x) __REG2( IMX_DMAC_BASE + 0x88, (x) << 6)	/* Count Registers */
-#define CCR(x)  __REG2( IMX_DMAC_BASE + 0x8c, (x) << 6)	/*Control Registers */
-#define RSSR(x) __REG2( IMX_DMAC_BASE + 0x90, (x) << 6)	/* Request source select Registers */
-#define BLR(x)  __REG2( IMX_DMAC_BASE + 0x94, (x) << 6)	/* Burst length Registers */
-#define RTOR(x) __REG2( IMX_DMAC_BASE + 0x98, (x) << 6)	/* Request timeout Registers */
-#define BUCR(x) __REG2( IMX_DMAC_BASE + 0x98, (x) << 6)	/* Bus Utilization Registers */
 
-#define DCR_DRST           (1<<1)
-#define DCR_DEN            (1<<0)
-#define DBTOCR_EN          (1<<15)
-#define DBTOCR_CNT(x)      ((x) & 0x7fff )
-#define CNTR_CNT(x)        ((x) & 0xffffff )
-#define CCR_DMOD_LINEAR    ( 0x0 << 12 )
-#define CCR_DMOD_2D        ( 0x1 << 12 )
-#define CCR_DMOD_FIFO      ( 0x2 << 12 )
-#define CCR_DMOD_EOBFIFO   ( 0x3 << 12 )
-#define CCR_SMOD_LINEAR    ( 0x0 << 10 )
-#define CCR_SMOD_2D        ( 0x1 << 10 )
-#define CCR_SMOD_FIFO      ( 0x2 << 10 )
-#define CCR_SMOD_EOBFIFO   ( 0x3 << 10 )
-#define CCR_MDIR_DEC       (1<<9)
-#define CCR_MSEL_B         (1<<8)
-#define CCR_DSIZ_32        ( 0x0 << 6 )
-#define CCR_DSIZ_8         ( 0x1 << 6 )
-#define CCR_DSIZ_16        ( 0x2 << 6 )
-#define CCR_SSIZ_32        ( 0x0 << 4 )
-#define CCR_SSIZ_8         ( 0x1 << 4 )
-#define CCR_SSIZ_16        ( 0x2 << 4 )
-#define CCR_REN            (1<<3)
-#define CCR_RPT            (1<<2)
-#define CCR_FRC            (1<<1)
-#define CCR_CEN            (1<<0)
-#define RTOR_EN            (1<<15)
-#define RTOR_CLK           (1<<14)
-#define RTOR_PSC           (1<<13)
+#define CRM_CSCR	__REG(MX2ADS_CRM_BASE + 0x0)
+#define CSCR_PRESC_MASK		(0x7<<29)
+#define CSCR_PRESC(x)		(((x) & 0x7) << 29)
+#define CSCR_USB_DIV_MASK	(0x7<<26)
+#define CSCR_USB_DIV(x)		(((x) & 0x7) << 26)
+#define CSCR_SD_CNT_MASK	(0x3<<24)
+#define CSCR_SD_CNT(x)		(((x) & 0x3) << 24)
+#define CSCR_SPLL_RESTART	(1<<22)
+#define CSCR_MPLL_RESTART	(1<<21)
+#define CSCR_SSI2_SEL		(1<<20)
+#define CSCR_SSI1_SEL		(1<<19)
+#define CSCR_FIR_SEL		(1<<18)
+#define CSCR_SP_SEL		(1<<17)
+#define CSCR_MCU_SEL		(1<<16)
+#define CSCR_BCLKDIV_MASK	(0xf<<10)
+#define CSCR_BCLKDIV(x)		(((x) & 0xf) << 10)
+#define CSCR_IPDIV		(1<<9)
+#define CSCR_OSC26M_DIV1P5	(1<<4)
+#define CSCR_OSC28M_DIS		(1<<3)
+#define CSCR_FPM_EN		(1<<2)
+#define CSCR_SPEN		(1<<1)
+#define CSCR_MPEN		(1<<0)
+
+#define CRM_MPCTL0	__REG(MX2ADS_CRM_BASE + 0x4)
+#define MPCTL0_CPLM		(1<<31)
+#define MPCTL0_PD(x)		(((x) & 0xf) << 26)
+#define MPCTL0_MFD(x)		(((x) & 0x3ff) << 16)
+#define MPCTL0_MFI(x)		(((x) & 0xf) << 10)
+#define MPCTL0_MFN(x)		(((x) & 0x3ff) << 0)
+
+#define CRM_MPCTL1	__REG(MX2ADS_CRM_BASE + 0x8)
+#define MPCTL1_LF		(1<<15)
+#define MPCTL1_BRMO		(1<<6)
+
+#define CRM_SPCTL0	__REG(MX2ADS_CRM_BASE + 0xc)
+#define SPCTL0_CPLM		(1<<31)
+#define SPCTL0_PD(x)		(((x) & 0xf) << 26)
+#define SPCTL0_MFD(x)		(((x) & 0x3ff) << 16)
+#define SPCTL0_MFI(x)		(((x) & 0xf) << 10)
+#define SPCTL0_MFN(x)		(((x) & 0x3ff) << 0)
+
+#define CRM_SPCTL1	__REG(MX2ADS_CRM_BASE + 0x10)
+#define SPCTL1_LF		(1<<15)
+#define SPCTL1_BRMO		(1<<6)
+
+#define CRM_OSC26MCTL	__REG(MX2ADS_CRM_BASE + 0x14)
+#define OSC26MCTL_OSC26M_PEAK	(0x2<<16)
+#define OSC25MCTL_AGC(x)	(((x) & 0x3f) << 8)
+
+#define CRM_PCDR0	__REG(MX2ADS_CRM_BASE + 0x18)
+#define PCDR0_SSI2DIV(x)	(((x) & 0x3f) << 26)
+#define PCDR0_SSI1DIV(x)	(((x) & 0x3f) << 16)
+#define PCDR0_NFCDIV(x)		(((x) & 0xf) << 12)
+#define PCDR0_CLKO_48MDIV(x)	(((x) & 0x7) << 5)
+#define PCDR0_FIRI_DIV(x)	(((x) & 0x1f) << 0)
+		
+#define CRM_PCDR1	__REG(MX2ADS_CRM_BASE + 0x1c)
+#define PCDR1_PERDIV4_POS	24
+#define PCDR1_PERDIV4_MASK	(0x3f << PCDR1_PERDIV4_POS)
+#define PCDR1_PERDIV4(x)	(((x) & 0x3f) << 24)
+#define PCDR1_PERDIV3_POS	16
+#define PCDR1_PERDIV3_MASK	(0x3f << PCDR1_PERDIV3_POS)
+#define PCDR1_PERDIV3(x) 	(((x) & 0x3f) << 16)
+#define PCDR1_PERDIV2_POS	8
+#define PCDR1_PERDIV2_MASK	(0x3f << PCDR1_PERDIV2_POS)
+#define PCDR1_PERDIV2(x) 	(((x) & 0x3f) << 8)
+#define PCDR1_PERDIV1_POS	0
+#define PCDR1_PERDIV1_MASK	(0x3f << PCDR1_PERDIV1_POS)
+#define PCDR1_PERDIV1(x) 	(((x) & 0x3f) << 0)
+
+#define CRM_PCCR0	__REG(MX2ADS_CRM_BASE + 0x20) 
+#define PCCR0_HCLK_CSI_EN 	(1<<31)
+#define PCCR0_HCLK_DMA_EN 	(1<<30)
+#define PCCR0_HCLK_BROM_EN 	(1<<28)
+#define PCCR0_HCLK_EMMA_EN 	(1<<27)
+#define PCCR0_HCLK_LCDC_EN 	(1<<26)
+#define PCCR0_HCLK_SLCDC_EN 	(1<<25)
+#define PCCR0_HCLK_USBOTG_EN 	(1<<24)
+#define PCCR0_HCLK_BMI_EN 	(1<<23)
+#define PCCR0_PERCLK4_EN 	(1<<22)
+#define PCCR0_SLCDC_EN	 	(1<<21)
+#define PCCR0_FIRI_BAUD_EN 	(1<<20)
+#define PCCR0_NFC_EN		(1<<19)
+#define PCCR0_PERCLK3_EN 	(1<<18)
+#define PCCR0_SSI1_BAUD_EN 	(1<<17)
+#define PCCR0_SSI2_BAUD_EN 	(1<<16)
+#define PCCR0_EMMA_EN 		(1<<15)
+#define PCCR0_USBOTG_EN	 	(1<<14)
+#define PCCR0_DMA_EN 		(1<<13)
+#define PCCR0_I2C_EN 		(1<<12)
+#define PCCR0_GPIO_EN	 	(1<<11)
+#define PCCR0_SDHC2_EN	 	(1<<10)
+#define PCCR0_SDHC1_EN	 	(1<<9)
+#define PCCR0_FIRI_EN	 	(1<<8)
+#define PCCR0_SSI2_EN	 	(1<<7)
+#define PCCR0_SSI1_EN		(1<<6)
+#define PCCR0_CSPI2_EN	 	(1<<5)
+#define PCCR0_CSPI1_EN	 	(1<<4)
+#define PCCR0_UART4_EN	 	(1<<3)
+#define PCCR0_UART3_EN	 	(1<<2)
+#define PCCR0_UART2_EN 		(1<<1)
+#define PCCR0_UART1_EN	 	(1<<0)
+
+#define CRM_PCCR1	__REG(MX2ADS_CRM_BASE + 0x24)
+#define PCCR1_OWIRE_EN		(1<<31)
+#define PCCR1_KPP_EN		(1<<30)
+#define PCCR1_RTC_EN		(1<<29)
+#define PCCR1_PWM_EN		(1<<28)
+#define PCCR1_GPT3_EN		(1<<27)
+#define PCCR1_GPT2_EN		(1<<26)
+#define PCCR1_GPT1_EN		(1<<25)
+#define PCCR1_WDT_EN		(1<<24)
+#define PCCR1_CSPI3_EN		(1<<23)
+#define PCCR1_RTIC_EN		(1<<22)
+#define PCCR1_RNGA_EN		(1<<21)
+
+#define CRM_CCSR	__REG(MX2ADS_CRM_BASE + 0x28)
+#define CCSR_32K_SR		(1<<15)
+#define CCSR_CLK0_SEL(x)	(((x) & 0x1f) << 0)
+	
+#define CRM_WKGDCTL	__REG(MX2ADS_CRM_BASE + 0x34)
+#define WKGDCTL_WKDG_EN		(1<<0)
 
 /*
- *  Interrupt controller
+ * LCD controller (LCDC) registers
  */
 
-#define IMX_INTCNTL        __REG(IMX_AITC_BASE+0x00)
-#define INTCNTL_FIAD       (1<<19)
-#define INTCNTL_NIAD       (1<<20)
+#define LCDC_LSSAR	__REG(MX2ADS_LCDC_BASE + 0x0)
+#define LSSAR_SSA(x)		(((x) & 0x3fffffff) << 2)
 
-#define IMX_NIMASK         __REG(IMX_AITC_BASE+0x04)
-#define IMX_INTENNUM       __REG(IMX_AITC_BASE+0x08)
-#define IMX_INTDISNUM      __REG(IMX_AITC_BASE+0x0c)
-#define IMX_INTENABLEH     __REG(IMX_AITC_BASE+0x10)
-#define IMX_INTENABLEL     __REG(IMX_AITC_BASE+0x14)
+#define LCDC_LSR 	__REG(MX2ADS_LCDC_BASE + 0x4)
+#define LSR_XMAX(x)		(((x) & 0x3f) << 20)
+#define LSR_YMAX(x)		(((x) & 0x3ff) << 0)
+
+#define LCDC_LVPWR 	__REG(MX2ADS_LCDC_BASE + 0x8)
+#define LVPWR_VPW(x)		(((x) & 0x3ff) << 0)
+
+#define LCDC_LCPR 	__REG(MX2ADS_LCDC_BASE + 0xc)
+#define LCPR_CC(x)		(((x) & 0x3) << 30)
+#define LCPR_OP			(1<<28)
+#define LCPR_CXP(x)		(((x) & 0x3ff) << 16)
+#define LCPR_CYP(x)		(((x) & 0x3ff) << 0)
+
+#define LCPR_CC_DISABLED	0
+#define LCPR_CC_OR		1
+#define LCPR_CC_XOR		2
+#define LCPR_CC_AND		3
+
+#define LCDC_LCWHBR 	__REG(MX2ADS_LCDC_BASE + 0x10)
+#define LCWHBR_BK_EN		(1<<31)
+#define LCWHBR_CW(x)		(((x) & 0x1f) << 24)
+#define LCWHBR_CH(x)		(((x) & 0x1f) << 16)
+#define LCWHBR_BD(x)		(((x) & 0xff) << 0)
+
+#define LCDC_LCCMR 	__REG(MX2ADS_LCDC_BASE + 0x14)
+#define LCCMR_CUR_COL_R(x)	(((x) & 0x3f) << 12)
+#define LCCMR_CUR_COL_G(x)	(((x) & 0x3f) << 6)
+#define LCCMR_CUR_COL_B(x)	(((x) & 0x3f) << 0)
+
+#define LCDC_LPCR 	__REG(MX2ADS_LCDC_BASE + 0x18)
+#define LPCR_TFT		(1<<31)
+#define LPCR_COLOR		(1<<30)
+#define LPCR_PBSIZ_POS		28
+#define LPCR_PBSIZ_MASK		(0x3 << LPCR_PBSIZ_POS)
+#define LPCR_PBSIZ(x)		(((x) << LPCR_PBSIZ_POS) & LPCR_PBSIZ_MASK)
+#define LPCR_BPIX_POS		25
+#define LPCR_BPIX_MASK		(0x7 << LPCR_BPIX_POS)
+#define LPCR_BPIX(x)		(((x) << LPCR_BPIX_POS) & LPCR_BPIX_MASK)
+#define LPCR_PIXPOL		(1<<24)
+#define LPCR_FLMPOL		(1<<23)
+#define LPCR_LPPOL		(1<<22)
+#define LPCR_CLKPOL		(1<<21)
+#define LPCR_OEPOL		(1<<20)
+#define LPCR_SCLKIDLE		(1<<19)
+#define LPCR_END_SEL		(1<<18)
+#define LPCR_SWAP_SEL		(1<<17)
+#define LPCR_REV_VS		(1<<16)
+#define LPCR_ACDSEL		(1<<15)
+#define LPCR_ACD(x)		(((x) & 0x7f) << 8)
+#define LPCR_SCLKSEL		(1<<7)
+#define LPCR_SHARP		(1<<6)
+#define LPCR_PCD(x)		(((x) & 0x3f) << 0)
+
+#define LPCR_PBSIZ_PANEL_BUS_WIDTH_1	0
+#define LPCR_PBSIZ_PANEL_BUS_WIDTH_4	2
+#define LPCR_PBSIZ_PANEL_BUS_WIDTH_8	3
+
+#define LPCR_BPIX_BITS_PER_PIXEL_1	0
+#define LPCR_BPIX_BITS_PER_PIXEL_2	1
+#define LPCR_BPIX_BITS_PER_PIXEL_4	2
+#define LPCR_BPIX_BITS_PER_PIXEL_8	3
+#define LPCR_BPIX_BITS_PER_PIXEL_12	4
+#define LPCR_BPIX_BITS_PER_PIXEL_16	5
+#define LPCR_BPIX_BITS_PER_PIXEL_18	6
+
+#define LCDC_LHCR 	__REG(MX2ADS_LCDC_BASE + 0x1c)
+#define LHCR_H_WIDTH(x)		(((x) & 0x3f) << 26)
+#define LHCR_H_WAIT_1(x)	(((x) & 0x1ff) << 8)
+#define LHCR_H_WAIT_2(x)	(((x) & 0x1ff) << 0)
+
+#define LCDC_LVCR 	__REG(MX2ADS_LCDC_BASE + 0x20)
+#define LVCR_V_WIDTH(x)		(((x) & 0x3f) << 26)
+#define LVCR_V_WAIT_1(x)	(((x) & 0x1ff) << 8)
+#define LVCR_V_WAIT_2(x)	(((x) & 0x1ff) << 0)
+
+#define LCDC_LPOR 	__REG(MX2ADS_LCDC_BASE + 0x24)
+#define LPOR_POS(x)		(((x) & 0x1f) << 0)
+
+#define LCDC_LSCR 	__REG(MX2ADS_LCDC_BASE + 0x28)
+#define LSCR_PS_RISE_DELAY(x)		(((x) & 0x3f) << 26)
+#define LSCR_CLS_RISE_DELAY(x)		(((x) & 0xff) << 16)
+#define LSCR_REV_TOGGLE_DELAY(x)	(((x) & 0xf) << 8)
+#define LSCR_GRAY2(x)			(((x) & 0xf) << 4)
+#define LSCR_GRAY1(x)			(((x) & 0xf) << 0)
+
+#define LCDC_LPCCR 	__REG(MX2ADS_LCDC_BASE + 0x2c)
+#define LPCCR_CLS_HI_WIDTH(x)	(((x) & 0x1ff) << 16)
+#define LPCCR_LDMSK		(1<<15)
+#define LPCCR_SCR(x)		(((x) & 0x3) << 9)
+#define LPCCR_CC_EN		(1<<8)
+#define LPCCR_PW(x)		(((x) & 0xff) << 0)
+
+#define LPCCR_SCR_LINE_PULSE	0
+#define LPCCR_SCR_PIXEL_CLOCK	1
+#define LPCCR_SCR_LCD_CLOCK	2
+
+#define LCDC_LDCR 	__REG(MX2ADS_LCDC_BASE + 0x30)
+#define LDCR_BURST		(1<<31)
+#define LDCR_HM(x)		(((x) & 0x1f) << 16)
+#define LDCR_TM(x)		(((x) & 0x1f) << 0)
+
+#define LCDC_LRMCR 	__REG(MX2ADS_LCDC_BASE + 0x34)
+#define LRMCR_LCDC_EN	        (1<<1)
+#define LRMCR_SELF_REF		(1<<0)
+
+
+#define LCDC_LICR 	__REG(MX2ADS_LCDC_BASE + 0x38)
+#define LICR_GW_INIT_CON	(1<<4)
+#define LICR_INTSYN		(1<<2)
+#define LICR_INTCON		(1<<0)
+
+#define LCDC_LIER 	__REG(MX2ADS_LCDC_BASE + 0x3c)
+#define LIER_GW_UDR_ERR_EN	(1<<7)
+#define LIER_GW_ERR_RES_EN	(1<<6)
+#define LIER_GW_EOF_EN		(1<<5)
+#define LIER_GW_BOF_EN		(1<<4)
+#define LIER_UDR_ERR_EN		(1<<3)
+#define LIER_ERR_RES_EN		(1<<2)
+#define LIER_EOF_EN		(1<<1)
+#define LIER_BOF_EN		(1<<0)
+
+#define LCDC_LISR 	__REG(MX2ADS_LCDC_BASE + 0x40)
+#define LISR_GW_UDR_ERR_MASK	(1<<7)
+#define LISR_GW_ERR_RES_MASK	(1<<6)
+#define LISR_GW_EOF_MASK	(1<<5)
+#define LISR_GW_BOF_MASK	(1<<4)
+#define LISR_UDR_ERR_MASK	(1<<3)
+#define LISR_ERR_RES_MASK	(1<<2)
+#define LISR_EOF_MASK		(1<<1)
+#define LISR_BOF_MASK		(1<<0)
+
+#define LCDC_LGWSAR 	__REG(MX2ADS_LCDC_BASE + 0x50)
+#define LGWSAR_GWSA(x)		(((x) & 0x3fffffff) << 2)
+
+#define LCDC_LGWSR 	__REG(MX2ADS_LCDC_BASE + 0x54)
+#define LGWSR_GWW(x)		(((x) & 0x3f) << 20)
+#define LGWSR_GWH(x)		(((x) & 0x3fff) << 0)
+
+#define LCDC_LGWVPWR 	__REG(MX2ADS_LCDC_BASE + 0x58)
+#define LGWVPWR_GWVPW(x)	(((x) & 0x3ff) << 0)
+
+#define LCDC_LGWPOR 	__REG(MX2ADS_LCDC_BASE + 0x5c)
+#define LGWPOR(x)		(((x) & 0x1f) << 0)
+
+#define LCDC_LGWPR 	__REG(MX2ADS_LCDC_BASE + 0x60)
+#define LGWPR_GWXP(x)		(((x) & 0x3ff) << 16)
+#define LGWPR_GWYP(x)		(((x) & 0x3ff) << 0)
+
+#define LCDC_LGWCR 	__REG(MX2ADS_LCDC_BASE + 0x64)
+#define LGWCR_GWAV(x)		(((x) & 0xff) << 24)
+#define LGWCR_GWCKE		(1<<23)
+#define LGWCR_GWE		(1<<22)
+#define LGWCR_GW_RVS		(1<<21)
+#define LGWCR_GWCKR(x)		(((x) & 0x3f) << 12)
+#define LGWCR_GWCKG(x)		(((x) & 0x3f) << 6)
+#define LGWCR_GWCKB(x)		(((x) & 0x3f) << 0)
+
+#define LCDC_LGWDCR 	__REG(MX2ADS_LCDC_BASE + 0x68)
+#define LGWDCR_GWBT		(1<<31)
+#define LGWDCR_GWHM(x)		(((x) & 0x1f) << 16)
+#define LGWDCR_GWTM(x)		(((x) & 0x1f) << 0)
 
 /*
  *  General purpose timers
  */
-#define IMX_TCTL(x)        __REG( 0x00 + (x))
+#define WHICH_TIMER(x)     ((x)*0x1000)
+#define IMX21_TCTL(x)        __REG( 0x00 + MX2ADS_GPT1_BASE + WHICH_TIMER(x) )
 #define TCTL_SWR           (1<<15)
 #define TCTL_FRR           (1<<8)
 #define TCTL_CAP_RIS       (1<<6)
 #define TCTL_CAP_FAL       (2<<6)
 #define TCTL_CAP_RIS_FAL   (3<<6)
-#define TCTL_OM            (1<<5)
-#define TCTL_IRQEN         (1<<4)
 #define TCTL_CLK_PCLK1     (1<<1)
 #define TCTL_CLK_PCLK1_16  (2<<1)
 #define TCTL_CLK_TIN       (3<<1)
 #define TCTL_CLK_32        (4<<1)
 #define TCTL_TEN           (1<<0)
 
-#define IMX_TPRER(x)       __REG( 0x04 + (x))
-#define IMX_TCMP(x)        __REG( 0x08 + (x))
-#define IMX_TCR(x)         __REG( 0x0C + (x))
-#define IMX_TCN(x)         __REG( 0x10 + (x))
-#define IMX_TSTAT(x)       __REG( 0x14 + (x))
-#define TSTAT_CAPT         (1<<1)
-#define TSTAT_COMP         (1<<0)
-
 /*
- * LCD Controller
+ * Update with Xenomai patch for iMx21 plateform
  */
+#define TCTL_OM		   (1<<9)
+#define TCTL_CC            (1<<10)
+#define TCTL_IRQ_COMP	   (1<<4)
+#define TCTL_IRQ_CAPT	   (1<<5)
 
-#define LCDC_SSA	__REG(IMX_LCDC_BASE+0x00)
-
-#define LCDC_SIZE	__REG(IMX_LCDC_BASE+0x04)
-#define SIZE_XMAX(x)	((((x) >> 4) & 0x3f) << 20)
-#define SIZE_YMAX(y)    ( (y) & 0x1ff )
-
-#define LCDC_VPW	__REG(IMX_LCDC_BASE+0x08)
-#define VPW_VPW(x)	( (x) & 0x3ff )
-
-#define LCDC_CPOS	__REG(IMX_LCDC_BASE+0x0C)
-#define CPOS_CC1        (1<<31)
-#define CPOS_CC0        (1<<30)
-#define CPOS_OP         (1<<28)
-#define CPOS_CXP(x)     (((x) & 3ff) << 16)
-#define CPOS_CYP(y)     ((y) & 0x1ff)
-
-#define LCDC_LCWHB	__REG(IMX_LCDC_BASE+0x10)
-#define LCWHB_BK_EN     (1<<31)
-#define LCWHB_CW(w)     (((w) & 0x1f) << 24)
-#define LCWHB_CH(h)     (((h) & 0x1f) << 16)
-#define LCWHB_BD(x)     ((x) & 0xff)
-
-#define LCDC_LCHCC	__REG(IMX_LCDC_BASE+0x14)
-#define LCHCC_CUR_COL_R(r) (((r) & 0x1f) << 11)
-#define LCHCC_CUR_COL_G(g) (((g) & 0x3f) << 5)
-#define LCHCC_CUR_COL_B(b) ((b) & 0x1f)
-
-#define LCDC_PCR	__REG(IMX_LCDC_BASE+0x18)
-#define PCR_TFT         (1<<31)
-#define PCR_COLOR       (1<<30)
-#define PCR_PBSIZ_1     (0<<28)
-#define PCR_PBSIZ_2     (1<<28)
-#define PCR_PBSIZ_4     (2<<28)
-#define PCR_PBSIZ_8     (3<<28)
-#define PCR_BPIX_1      (0<<25)
-#define PCR_BPIX_2      (1<<25)
-#define PCR_BPIX_4      (2<<25)
-#define PCR_BPIX_8      (3<<25)
-#define PCR_BPIX_12     (4<<25)
-#define PCR_BPIX_16     (4<<25)
-#define PCR_PIXPOL      (1<<24)
-#define PCR_FLMPOL      (1<<23)
-#define PCR_LPPOL       (1<<22)
-#define PCR_CLKPOL      (1<<21)
-#define PCR_OEPOL       (1<<20)
-#define PCR_SCLKIDLE    (1<<19)
-#define PCR_END_SEL     (1<<18)
-#define PCR_END_BYTE_SWAP (1<<17)
-#define PCR_REV_VS      (1<<16)
-#define PCR_ACD_SEL     (1<<15)
-#define PCR_ACD(x)      (((x) & 0x7f) << 8)
-#define PCR_SCLK_SEL    (1<<7)
-#define PCR_SHARP       (1<<6)
-#define PCR_PCD(x)      ((x) & 0x3f)
-
-#define LCDC_HCR	__REG(IMX_LCDC_BASE+0x1C)
-#define HCR_H_WIDTH(x)  (((x) & 0x3f) << 26)
-#define HCR_H_WAIT_1(x) (((x) & 0xff) << 8)
-#define HCR_H_WAIT_2(x) ((x) & 0xff)
-
-#define LCDC_VCR	__REG(IMX_LCDC_BASE+0x20)
-#define VCR_V_WIDTH(x)  (((x) & 0x3f) << 26)
-#define VCR_V_WAIT_1(x) (((x) & 0xff) << 8)
-#define VCR_V_WAIT_2(x) ((x) & 0xff)
-
-#define LCDC_POS	__REG(IMX_LCDC_BASE+0x24)
-#define POS_POS(x)      ((x) & 1f)
-
-#define LCDC_LSCR1	__REG(IMX_LCDC_BASE+0x28)
-#define LSCR1_PS_RISE_DELAY(x)    (((x) & 0x7f) << 26)
-#define LSCR1_CLS_RISE_DELAY(x)   (((x) & 0x3f) << 16)
-#define LSCR1_REV_TOGGLE_DELAY(x) (((x) & 0xf) << 8)
-#define LSCR1_GRAY2(x)            (((x) & 0xf) << 4)
-#define LSCR1_GRAY1(x)            (((x) & 0xf))
-
-#define LCDC_PWMR	__REG(IMX_LCDC_BASE+0x2C)
-#define PWMR_CLS(x)     (((x) & 0x1ff) << 16)
-#define PWMR_LDMSK      (1<<15)
-#define PWMR_SCR1       (1<<10)
-#define PWMR_SCR0       (1<<9)
-#define PWMR_CC_EN      (1<<8)
-#define PWMR_PW(x)      ((x) & 0xff)
+#define IMX21_TPRER(x)       __REG( 0x04 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define IMX21_TCMP(x)        __REG( 0x08 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define IMX21_TCR(x)         __REG( 0x0C + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define IMX21_TCN(x)         __REG( 0x10 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define IMX21_TSTAT(x)       __REG( 0x14 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define TSTAT_CAPT         (1<<1)
+#define TSTAT_COMP         (1<<0)
 
-#define LCDC_DMACR	__REG(IMX_LCDC_BASE+0x30)
-#define DMACR_BURST     (1<<31)
-#define DMACR_HM(x)     (((x) & 0xf) << 16)
-#define DMACR_TM(x)     ((x) &0xf)
+#define GPT1		0
+#define GPT2		1
+#define GPT3		2
 
-#define LCDC_RMCR	__REG(IMX_LCDC_BASE+0x34)
-#define RMCR_LCDC_EN		(1<<1)
-#define RMCR_SELF_REF		(1<<0)
+/*
+ *  Uart controller registers 
+ */
 
-#define LCDC_LCDICR	__REG(IMX_LCDC_BASE+0x38)
-#define LCDICR_INT_SYN  (1<<2)
-#define LCDICR_INT_CON  (1)
+#define UART_1  0
+#define UART_2  1
+#define UART_3  2
+#define UART_4  3
 
-#define LCDC_LCDISR	__REG(IMX_LCDC_BASE+0x40)
-#define LCDISR_UDR_ERR (1<<3)
-#define LCDISR_ERR_RES (1<<2)
-#define LCDISR_EOF     (1<<1)
-#define LCDISR_BOF     (1<<0)
 
-/*
- *  UART Module. Takes the UART base address as argument
- */
 #define URXD0(x) __REG( 0x0 + (x)) /* Receiver Register */
 #define URTX0(x) __REG( 0x40 + (x)) /* Transmitter Register */
 #define UCR1(x)  __REG( 0x80 + (x)) /* Control Register 1 */
@@ -490,15 +627,10 @@
 #define UBIR(x)  __REG( 0xa4 + (x)) /* BRM Incremental Register */
 #define UBMR(x)  __REG( 0xa8 + (x)) /* BRM Modulator Register */
 #define UBRC(x)  __REG( 0xac + (x)) /* Baud Rate Count Register */
-#define BIPR1(x) __REG( 0xb0 + (x)) /* Incremental Preset Register 1 */
-#define BIPR2(x) __REG( 0xb4 + (x)) /* Incremental Preset Register 2 */
-#define BIPR3(x) __REG( 0xb8 + (x)) /* Incremental Preset Register 3 */
-#define BIPR4(x) __REG( 0xbc + (x)) /* Incremental Preset Register 4 */
-#define BMPR1(x) __REG( 0xc0 + (x)) /* BRM Modulator Register 1 */
-#define BMPR2(x) __REG( 0xc4 + (x)) /* BRM Modulator Register 2 */
-#define BMPR3(x) __REG( 0xc8 + (x)) /* BRM Modulator Register 3 */
-#define BMPR4(x) __REG( 0xcc + (x)) /* BRM Modulator Register 4 */
-#define UTS(x)   __REG( 0xd0 + (x)) /* UART Test Register */
+#define ONMES(x) __REG( 0xb0 + (x)) /* One Millisecond Register */
+#define UTS(x)   __REG( 0xb4 + (x)) /* UART Test Register */
+
+
 
 /* UART Control Register Bit Fields.*/
 #define  URXD_CHARRDY    (1<<15)
@@ -507,6 +639,7 @@
 #define  URXD_FRMERR     (1<<12)
 #define  URXD_BRK        (1<<11)
 #define  URXD_PRERR      (1<<10)
+
 #define  UCR1_ADEN       (1<<15) /* Auto dectect interrupt */
 #define  UCR1_ADBR       (1<<14) /* Auto detect baud rate */
 #define  UCR1_TRDYEN     (1<<13) /* Transmitter ready interrupt enable */
@@ -518,9 +651,10 @@
 #define  UCR1_RTSDEN     (1<<5)	 /* RTS delta interrupt enable */
 #define  UCR1_SNDBRK     (1<<4)	 /* Send break */
 #define  UCR1_TDMAEN     (1<<3)	 /* Transmitter ready DMA enable */
-#define  UCR1_UARTCLKEN  (1<<2)	 /* UART clock enabled */
+// not on mx21 #define  UCR1_UARTCLKEN  (1<<2)	 /* UART clock enabled */
 #define  UCR1_DOZE       (1<<1)	 /* Doze */
 #define  UCR1_UARTEN     (1<<0)	 /* UART enabled */
+
 #define  UCR2_ESCI     	 (1<<15) /* Escape seq interrupt enable */
 #define  UCR2_IRTS  	 (1<<14) /* Ignore RTS pin */
 #define  UCR2_CTSC  	 (1<<13) /* CTS pin control */
@@ -531,36 +665,44 @@
 #define  UCR2_STPB       (1<<6)	 /* Stop */
 #define  UCR2_WS         (1<<5)	 /* Word size */
 #define  UCR2_RTSEN      (1<<4)	 /* Request to send interrupt enable */
+#define  UCR2_ATEN	 (1<<3)  /* Aging Timer Enable */
 #define  UCR2_TXEN       (1<<2)	 /* Transmitter enabled */
 #define  UCR2_RXEN       (1<<1)	 /* Receiver enabled */
 #define  UCR2_SRST 	 (1<<0)	 /* SW reset */
+
 #define  UCR3_DTREN 	 (1<<13) /* DTR interrupt enable */
 #define  UCR3_PARERREN   (1<<12) /* Parity enable */
 #define  UCR3_FRAERREN   (1<<11) /* Frame error interrupt enable */
 #define  UCR3_DSR        (1<<10) /* Data set ready */
 #define  UCR3_DCD        (1<<9)  /* Data carrier detect */
 #define  UCR3_RI         (1<<8)  /* Ring indicator */
-#define  UCR3_TIMEOUTEN  (1<<7)  /* Timeout interrupt enable */
+#define  UCR3_ADNIMP     (1<<7)  /* Timeout interrupt enable */
 #define  UCR3_RXDSEN	 (1<<6)  /* Receive status interrupt enable */
 #define  UCR3_AIRINTEN   (1<<5)  /* Async IR wake interrupt enable */
 #define  UCR3_AWAKEN	 (1<<4)  /* Async wake interrupt enable */
-#define  UCR3_REF25 	 (1<<3)  /* Ref freq 25 MHz */
-#define  UCR3_REF30 	 (1<<2)  /* Ref Freq 30 MHz */
+// not on mx21 #define  UCR3_REF25 	 (1<<3)  /* Ref freq 25 MHz */
+#define  UCR3_RXDMUXSEL  (1<<2)  /* RXD Mux Input Select */
 #define  UCR3_INVT  	 (1<<1)  /* Inverted Infrared transmission */
-#define  UCR3_BPEN  	 (1<<0)  /* Preset registers enable */
-#define  UCR4_CTSTL_32   (32<<10) /* CTS trigger level (32 chars) */
+#define  UCR3_ACIEN  	 (1<<0)  /* Autobaud Counter  Interrupt Enable */
+
+
 #define  UCR4_INVR  	 (1<<9)  /* Inverted infrared reception */
 #define  UCR4_ENIRI 	 (1<<8)  /* Serial infrared interrupt enable */
 #define  UCR4_WKEN  	 (1<<7)  /* Wake interrupt enable */
-#define  UCR4_REF16 	 (1<<6)  /* Ref freq 16 MHz */
+// not on mx21 #define  UCR4_REF16 	 (1<<6)  /* Ref freq 16 MHz */
 #define  UCR4_IRSC  	 (1<<5)  /* IR special case */
+#define  UCR4_LPBYP  	 (1<<5)  /* Low Power Bypass */
 #define  UCR4_TCEN  	 (1<<3)  /* Transmit complete interrupt enable */
 #define  UCR4_BKEN  	 (1<<2)  /* Break condition interrupt enable */
 #define  UCR4_OREN  	 (1<<1)  /* Receiver overrun interrupt enable */
 #define  UCR4_DREN  	 (1<<0)  /* Recv data ready interrupt enable */
+
 #define  UFCR_RXTL_SHF   0       /* Receiver trigger level shift */
 #define  UFCR_RFDIV      (7<<7)  /* Reference freq divider mask */
+#define  UFCR_RFDIV_SHF  7	 /* Reference freq divider shift */
 #define  UFCR_TXTL_SHF   10      /* Transmitter trigger level shift */
+#define  UFCR_DCEDTE	 (1<<6)  /* DCE/DTE Mode */
+
 #define  USR1_PARITYERR  (1<<15) /* Parity error interrupt flag */
 #define  USR1_RTSS  	 (1<<14) /* RTS pin status */
 #define  USR1_TRDY  	 (1<<13) /* Transmitter ready interrupt/dma flag */
@@ -568,27 +710,38 @@
 #define  USR1_ESCF  	 (1<<11) /* Escape seq interrupt flag */
 #define  USR1_FRAMERR    (1<<10) /* Frame error interrupt flag */
 #define  USR1_RRDY       (1<<9)	 /* Receiver ready interrupt/dma flag */
-#define  USR1_TIMEOUT    (1<<7)	 /* Receive timeout interrupt status */
+#define  USR1_AGTIM      (1<<8)	 /* Aging Timer Interrupt Flag */
+// not on mx21 #define  USR1_TIMEOUT    (1<<7)	 /* Receive timeout interrupt status */
 #define  USR1_RXDS  	 (1<<6)	 /* Receiver idle interrupt flag */
 #define  USR1_AIRINT	 (1<<5)	 /* Async IR wake interrupt flag */
 #define  USR1_AWAKE 	 (1<<4)	 /* Aysnc wake interrupt flag */
+
 #define  USR2_ADET  	 (1<<15) /* Auto baud rate detect complete */
 #define  USR2_TXFE  	 (1<<14) /* Transmit buffer FIFO empty */
 #define  USR2_DTRF  	 (1<<13) /* DTR edge interrupt flag */
 #define  USR2_IDLE  	 (1<<12) /* Idle condition */
+#define  USR2_ACST  	 (1<<11) /* Autobaud Controller Stopped*/
+#define  USR2_RIDELT  	 (1<<10) /* Ring Indicator Delta */
+#define  USR2_RIIN  	 (1<<9)  /* Ring Indicator Input*/
 #define  USR2_IRINT 	 (1<<8)	 /* Serial infrared interrupt flag */
 #define  USR2_WAKE  	 (1<<7)	 /* Wake */
+#define  USR2_DCDDELT  	 (1<<6)	 /* Data Carrier Delta Detect */
+#define  USR2_DCDIN  	 (1<<5)	 /* Data Carrier Detect Input */
 #define  USR2_RTSF  	 (1<<4)	 /* RTS edge interrupt flag */
 #define  USR2_TXDC  	 (1<<3)	 /* Transmitter complete */
 #define  USR2_BRCD  	 (1<<2)	 /* Break condition */
 #define  USR2_ORE        (1<<1)	 /* Overrun error */
 #define  USR2_RDR        (1<<0)	 /* Recv data ready */
+
 #define  UTS_FRCPERR	 (1<<13) /* Force parity error */
 #define  UTS_LOOP        (1<<12) /* Loop tx and rx */
+#define  UTS_DBGEN       (1<<11) /* /Debug Enable */
+#define  UTS_LOOPIR      (1<<10) /* Loop tx and rx for IR */
+#define  UTS_RXFIFO	 (1<<9)	 /* RXFifo Debug */
 #define  UTS_TXEMPTY	 (1<<6)	 /* TxFIFO empty */
 #define  UTS_RXEMPTY	 (1<<5)	 /* RxFIFO empty */
 #define  UTS_TXFULL 	 (1<<4)	 /* TxFIFO full */
 #define  UTS_RXFULL 	 (1<<3)	 /* RxFIFO full */
 #define  UTS_SOFTRST	 (1<<0)	 /* Software reset */
 
-#endif				// _IMX_REGS_H
+#endif				// _MX2ADS_REGS_H
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx21/csb535.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/csb535.h
--- linux-2.6.14/include/asm-arm/arch-imx21/csb535.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/csb535.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,59 @@
+/*
+ * linux/include/asm-arm/arch-imx21/csb535.h
+ *
+ * Copyright (C) 2004 Robert Schwebel, Pengutronix
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * April 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board with Xenomai by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ *
+ * 24.04.06 : define the value : TICKS_PER_uSEC
+ *             adapted by Sbastien Gerber
+ * 25.04.06 : add a constant for the timer clock (CLKPERCLK1)
+ *             adapted by Sbastien Gerber
+ * 
+ */
+
+#ifndef __ASM_ARCH_CSB535_H
+#define __ASM_ARCH_CSB535_H
+
+/* ------------------------------------------------------------------------ */
+/* Memory Map for the M9328CSB535 (CSB535) Board                            */
+/* ------------------------------------------------------------------------ */
+
+#define CSB535_FLASH_PHYS		0x10000000
+#define CSB535_FLASH_SIZE		(16*1024*1024)
+
+#define IMX_FB_PHYS			(0x0C000000 - 0x40000)
+
+#define CLK32                            32768
+#define CLKPERCLK1                       16515072
+
+#define TICKS_PER_uSEC                    CLKPERCLK1 / 1000000
+
+
+#define CSB535_ETH_VIRT IMX21_CS1_VIRT
+#define CSB535_ETH_PHYS IMX21_CS1_PHYS
+#define CSB535_ETH_SIZE IMX21_CS1_SIZE
+#define CSB535_ETH_IRQ  IRQ_GPIOE(2)
+
+
+#endif /* __ASM_ARCH_CSB535_H */
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx21/debug-macro.S ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/debug-macro.S
--- linux-2.6.14/include/asm-arm/arch-imx21/debug-macro.S	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/debug-macro.S	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,36 @@
+/* linux/include/asm-arm/arch-imx21/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+		.macro	addruart,rx
+	        mrc     p15, 0, \rx, c1, c0
+                tst     \rx, #1                 @ MMU enabled?
+                moveq   \rx, #0x10000000        @ Physical
+                movne   \rx, #0xe4000000        @ Virtual
+                orr     \rx, \rx, #0xa000
+                orr     \rx, \rx, #0x40
+		.endm
+
+		.macro	senduart,rd,rx
+		str	\rd, [\rx]	@ TXDATA
+		.endm
+
+		.macro	waituart,rd,rx
+		.endm
+
+		.macro	busyuart,rd,rx
+1002:		ldrb    \rd, [\rx, #0x54]
+		@ Check TRDY in USR1_1 (phys=0x1000a094)
+                and     \rd, \rd, #0x2000  
+                cmp     \rd, #0x2000
+                bne     1002b
+		.endm
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx21/dma.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/dma.h
--- linux-2.6.14/include/asm-arm/arch-imx21/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/dma.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,71 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/dma.h
+ *
+ *  Copyright (C) 1997,1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#define MAX_DMA_ADDRESS		0xffffffff
+
+#define MAX_DMA_CHANNELS	0
+
+/*
+ * DMA registration
+ */
+
+typedef enum {
+	DMA_PRIO_HIGH = 0,
+	DMA_PRIO_MEDIUM = 3,
+	DMA_PRIO_LOW = 6
+} imx_dma_prio;
+
+int imx_request_dma(char *name, imx_dma_prio prio,
+		    void (*irq_handler) (int, void *, struct pt_regs *),
+		    void (*err_handler) (int, void *, struct pt_regs *),
+		    void *data);
+
+void imx_free_dma(int dma_ch);
+
+
+#define DMA_REQ_UART3_T        2
+#define DMA_REQ_UART3_R        3
+#define DMA_REQ_SSI2_T         4
+#define DMA_REQ_SSI2_R         5
+#define DMA_REQ_CSI_STAT       6
+#define DMA_REQ_CSI_R          7
+#define DMA_REQ_MSHC           8
+#define DMA_REQ_DSPA_DCT_DOUT  9
+#define DMA_REQ_DSPA_DCT_DIN  10
+#define DMA_REQ_DSPA_MAC      11
+#define DMA_REQ_EXT           12
+#define DMA_REQ_SDHC          13
+#define DMA_REQ_SPI1_R        14
+#define DMA_REQ_SPI1_T        15
+#define DMA_REQ_SSI_T         16
+#define DMA_REQ_SSI_R         17
+#define DMA_REQ_ASP_DAC       18
+#define DMA_REQ_ASP_ADC       19
+#define DMA_REQ_USP_EP(x)    (20+(x))
+#define DMA_REQ_SPI2_R        26
+#define DMA_REQ_SPI2_T        27
+#define DMA_REQ_UART2_T       28
+#define DMA_REQ_UART2_R       29
+#define DMA_REQ_UART1_T       30
+#define DMA_REQ_UART1_R       31
+
+#endif				/* _ASM_ARCH_DMA_H */
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx21/entry-macro.S ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/entry-macro.S
--- linux-2.6.14/include/asm-arm/arch-imx21/entry-macro.S	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/entry-macro.S	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,29 @@
+/*
+ * include/asm-arm/arch-imx21/entry-macro.S
+ *
+ * Low-level IRQ helper macros for iMX-based platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+		.macro	disable_fiq
+		.endm
+#define AITC_NIVECSR   0x40
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\irqstat, =IO_ADDRESS(MX2ADS_AITC_BASE)
+		@ Load offset & priority of the highest priority
+		@ interrupt pending.
+		ldr	\irqnr, [\irqstat, #AITC_NIVECSR]
+		@ Shift off the priority leaving the offset or
+		@ "interrupt number"
+		mov	\irqnr, \irqnr, lsr #16
+ 		ldr	\irqstat, =1	@ dummy compare
+		ldr	\base, =0xFFFF		// invalid interrupt
+		cmp	\irqnr, \base
+		bne	1001f
+		ldr	\irqstat, =0
+1001:
+		tst	\irqstat, #1	@ to make the condition code = TRUE
+		.endm
+
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx21/hardware.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/hardware.h
--- linux-2.6.14/include/asm-arm/arch-imx21/hardware.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/hardware.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,116 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/hardware.h
+ *
+ *  Copyright (C) 1999 ARM Limited.
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+#include "imx-regs.h"
+
+#ifndef __ASSEMBLY__
+# define __REG(x)	(*((volatile u32 *)IO_ADDRESS(x)))
+
+# define __REG2(x,y)	\
+	( __builtin_constant_p(y) ? (__REG((x) + (y))) \
+			  : (*(volatile u32 *)((u32)&__REG(x) + (y))) )
+extern int x4;
+#endif
+
+/*
+ * Memory map
+ */
+
+#define IMX21_IO_PHYS		0x10000000
+#define IMX21_IO_SIZE		0x00100000
+#define IMX21_IO_BASE		0xe0000000
+
+#define IMX21_CS0_PHYS		0xc8000000
+#define IMX21_CS0_SIZE		0x02000000
+#define IMX21_CS0_VIRT		0xe8000000
+
+#define IMX21_CS1_PHYS		0xcc000000
+#define IMX21_CS1_SIZE		0x01000000
+#define IMX21_CS1_VIRT		0xea000000
+
+#define IMX21_EMI_PHYS		0xdf000000
+#define IMX21_EMI_SIZE		0x00004000
+#define IMX21_EMI_VIRT		0xeb000000
+
+#if 0	// TODO remove??
+#define IMX21_CS2_PHYS		0x13000000
+#define IMX21_CS2_SIZE		0x01000000
+#define IMX21_CS2_VIRT		0xeb000000
+
+#define IMX21_CS3_PHYS		0x14000000
+#define IMX21_CS3_SIZE		0x01000000
+#define IMX21_CS3_VIRT		0xec000000
+
+#define IMX21_CS4_PHYS		0x15000000
+#define IMX21_CS4_SIZE		0x01000000
+#define IMX21_CS4_VIRT		0xed000000
+
+#define IMX21_CS5_PHYS		0x16000000
+#define IMX21_CS5_SIZE		0x01000000
+#define IMX21_CS5_VIRT		0xee000000
+#endif // NOT USED
+
+#define IMX21_FB_VIRT		0xF1000000
+#define IMX21_FB_SIZE		(256*1024)
+
+/* macro to get at IO space when running virtually */
+#define IO_ADDRESS(x) ((x) | IMX21_IO_BASE)
+
+#ifndef __ASSEMBLY__
+/*
+ * Handy routine to set GPIO functions
+ */
+extern void imx21_gpio_mode( int gpio_mode );
+
+/* get frequencies in Hz */
+extern unsigned int imx21_get_system_clk(void);
+extern unsigned int imx21_get_mcu_clk(void);
+extern unsigned int imx21_get_perclk1(void); /* UART[12], Timer[12], PWM */
+extern unsigned int imx21_get_perclk2(void); /* LCD, SD, SPI[12]         */
+extern unsigned int imx21_get_perclk3(void); /* SSI                      */
+extern unsigned int imx21_get_hclk(void);    /* SDRAM, CSI, Memory Stick,*/
+                                           /* I2C, DMA                 */
+#endif
+
+#define MAXIRQNUM                       62
+#define MAXFIQNUM                       62
+#define MAXSWINUM                       62
+
+/*
+ * Use SDRAM for memory
+ */
+#define MEM_SIZE		0x01000000
+
+#ifdef CONFIG_ARCH_MX2ADS
+#include "mx2ads.h"
+#endif
+
+#ifdef CONFIG_MACH_CSB535
+#include "csb535.h"
+#endif
+
+#endif
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx21/imx-regs.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/imx-regs.h
--- linux-2.6.14/include/asm-arm/arch-imx21/imx-regs.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/imx-regs.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,747 @@
+#ifndef _MX2ADS_REGS_H
+#define _MX2ADS_REGS_H
+/* ------------------------------------------------------------------------
+ *  Freescale i.iMX21 system registers
+ * ------------------------------------------------------------------------
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * Modified by: Stephen Donecker (sdonecker@sbcglobal.net)
+ *
+ * April 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board with Xenomai by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ * 
+*/
+
+/*
+ * Memory mapped I/O for the M9328MX21ADS    
+ *
+ * TODO: move these defines to an appropiate board specific file
+ */
+
+#define MX2ADS_MMIO_PHYS	(0xCC800000)
+#define MX2ADS_MMIO_OFFSET	MX2ADS_MMIO_PHYS-IMX21_CS1_PHYS
+#define MMIO_REG		(*((volatile u16 *)(IMX21_CS1_VIRT+MX2ADS_MMIO_OFFSET)))
+
+#define MMIO_SD_WP		(1<<0)
+#define MMIO_SW_SEL		(1<<1)
+#define MMIO_RESET_E_UART	(1<<2)
+#define MMIO_RESET_BASE		(1<<3)
+#define MMIO_CSI_CTL2		(1<<4)
+#define MMIO_CSI_CTL1		(1<<5)
+#define MMIO_CSI_CTL0		(1<<6)
+#define MMIO_UART1_EN		(1<<7)
+#define MMIO_UART4_EN		(1<<8)
+#define	MMIO_LCDON		(1<<9)
+#define MMIO_IRDA_EN		(1<<10)
+#define MMIO_IRDA_FIR_SEL	(1<<11)
+#define MMIO_IRDA_MD0_B		(1<<12)
+#define MMIO_IRDA_MD1		(1<<13)
+#define MMIO_LED4_ON		(1<<14)
+#define MMIO_LED3_ON		(1<<15)
+
+/*
+ *  Register BASEs, based on OFFSETs
+ *
+ */
+
+/* TODO: Rename MX2ADS to processor specific name, not a board name */
+
+#define MX2ADS_AIPI1_BASE             (0x00000 + IMX21_IO_BASE)
+#define MX2ADS_AIPI2_BASE             (0x20000 + IMX21_IO_BASE)
+
+#define MX2ADS_DMA_BASE               (0x01000 + IMX21_IO_BASE)
+#define MX2ADS_WDT_BASE               (0x02000 + IMX21_IO_BASE)
+#define MX2ADS_GPT1_BASE              (0x03000 + IMX21_IO_BASE)
+#define MX2ADS_GPT2_BASE              (0x04000 + IMX21_IO_BASE)
+#define MX2ADS_GPT3_BASE              (0x05000 + IMX21_IO_BASE)
+#define MX2ADS_PWM_BASE               (0x06000 + IMX21_IO_BASE)
+#define MX2ADS_RTC_BASE               (0x07000 + IMX21_IO_BASE)
+#define MX2ADS_KPP_BASE               (0x08000 + IMX21_IO_BASE)
+#define MX2ADS_OWIRE_BASE             (0x09000 + IMX21_IO_BASE)
+#define MX2ADS_UART1_BASE             (0x0A000 + IMX21_IO_BASE)
+#define MX2ADS_UART2_BASE             (0x0B000 + IMX21_IO_BASE)
+#define MX2ADS_UART3_BASE             (0x0C000 + IMX21_IO_BASE)
+#define MX2ADS_UART4_BASE             (0x0D000 + IMX21_IO_BASE)
+#define MX2ADS_CSPI1_BASE             (0x0E000 + IMX21_IO_BASE)
+#define MX2ADS_CSPI2_BASE             (0x0F000 + IMX21_IO_BASE)
+#define MX2ADS_SSI1_BASE              (0x10000 + IMX21_IO_BASE)
+#define MX2ADS_SSI2_BASE              (0x11000 + IMX21_IO_BASE)
+#define MX2ADS_I2C_BASE               (0x12000 + IMX21_IO_BASE)
+#define MX2ADS_SDHC1_BASE             (0x13000 + IMX21_IO_BASE)
+#define MX2ADS_SDHC2_BASE             (0x14000 + IMX21_IO_BASE)
+#define MX2ADS_GPIO_BASE              (0x15000 + IMX21_IO_BASE)
+#define MX2ADS_AUDMUX_BASE            (0x16000 + IMX21_IO_BASE)
+#define MX2ADS_CSPI3_BASE	      (IMX21_IO_BASE + 0x17000)
+#define MX2ADS_LCDC_BASE              (0x21000 + IMX21_IO_BASE)
+#define MX2ADS_SLCDC_BASE             (0x22000 + IMX21_IO_BASE)
+#define MX2ADS_SAHARA_BASE            (0x23000 + IMX21_IO_BASE)
+#define MX2ADS_USBOTG_BASE            (0x24000 + IMX21_IO_BASE)
+#define MX2ADS_EMMA_BASE              (0x26000 + IMX21_IO_BASE)
+#define MX2ADS_CRM_BASE               (0x27000 + IMX21_IO_BASE)
+#define MX2ADS_FIRI_BASE              (0x28000 + IMX21_IO_BASE)
+#define MX2ADS_RNGA_BASE	      (IMX21_IO_BASE + 0x29000)
+#define MX2ADS_RTIC_BASE	      (IMX21_IO_BASE + 0x2A000)
+#define MX2ADS_JAM_BASE               (0x3E000 + IMX21_IO_BASE)
+#define MX2ADS_MAX_BASE               (0x3F000 + IMX21_IO_BASE)
+#define MX2ADS_AITC_BASE              (0x40000 + IMX21_IO_BASE)
+
+/*
+ * Interrupt controller
+ */
+#define AITC_NIVECSR		__REG(MX2ADS_AITC_BASE + 0x40)
+#define AITC_NIPRIORITY7	__REG(MX2ADS_AITC_BASE + 0x20)
+#define AITC_NIPRIORITY6	__REG(MX2ADS_AITC_BASE + 0x24)
+#define AITC_NIPRIORITY5	__REG(MX2ADS_AITC_BASE + 0x28)
+#define AITC_NIPRIORITY4	__REG(MX2ADS_AITC_BASE + 0x2C)
+#define AITC_NIPRIORITY3	__REG(MX2ADS_AITC_BASE + 0x30)
+#define AITC_NIPRIORITY2	__REG(MX2ADS_AITC_BASE + 0x34)
+#define AITC_NIPRIORITY1	__REG(MX2ADS_AITC_BASE + 0x38)
+#define AITC_NIPRIORITY0	__REG(MX2ADS_AITC_BASE + 0x3C)
+
+/*
+ * GPIOs
+ */
+#define GPIO_A	0
+#define GPIO_B	1
+#define GPIO_C	2
+#define GPIO_D	3
+#define GPIO_E	4
+#define GPIO_F	5
+
+/*
+ *  GPIO Module and I/O Multiplexer
+ *  x = 0..5 for reg_A, reg_B, reg_C, reg_D, reg_E, reg_F
+ */
+#define DDIR(x)    __REG2(MX2ADS_GPIO_BASE + 0x00, ((x) & 7) << 8)
+#define OCR1(x)    __REG2(MX2ADS_GPIO_BASE + 0x04, ((x) & 7) << 8)
+#define OCR2(x)    __REG2(MX2ADS_GPIO_BASE + 0x08, ((x) & 7) << 8)
+#define ICONFA1(x) __REG2(MX2ADS_GPIO_BASE + 0x0c, ((x) & 7) << 8)
+#define ICONFA2(x) __REG2(MX2ADS_GPIO_BASE + 0x10, ((x) & 7) << 8)
+#define ICONFB1(x) __REG2(MX2ADS_GPIO_BASE + 0x14, ((x) & 7) << 8)
+#define ICONFB2(x) __REG2(MX2ADS_GPIO_BASE + 0x18, ((x) & 7) << 8)
+#define DR(x)      __REG2(MX2ADS_GPIO_BASE + 0x1c, ((x) & 7) << 8)
+#define GIUS(x)    __REG2(MX2ADS_GPIO_BASE + 0x20, ((x) & 7) << 8)
+#define SSR(x)     __REG2(MX2ADS_GPIO_BASE + 0x24, ((x) & 7) << 8)
+#define ICR1(x)    __REG2(MX2ADS_GPIO_BASE + 0x28, ((x) & 7) << 8)
+#define ICR2(x)    __REG2(MX2ADS_GPIO_BASE + 0x2c, ((x) & 7) << 8)
+#define IMR(x)     __REG2(MX2ADS_GPIO_BASE + 0x30, ((x) & 7) << 8)
+#define ISR(x)     __REG2(MX2ADS_GPIO_BASE + 0x34, ((x) & 7) << 8)
+#define GPR(x)     __REG2(MX2ADS_GPIO_BASE + 0x38, ((x) & 7) << 8)
+#define SWR(x)     __REG2(MX2ADS_GPIO_BASE + 0x3c, ((x) & 7) << 8)
+#define PUEN(x)    __REG2(MX2ADS_GPIO_BASE + 0x40, ((x) & 7) << 8)
+#define PMASK      __REG(MX2ADS_GPIO_BASE + 0x600)
+
+/*  ethernet controller IRQ is tied to UART3_RTS */ 
+#define NET_IRQ_BIT		(1 << 11)
+
+/*
+ *  GPIO Mode
+ *
+ *  The pin, port, data direction, pull-up enable, primary/alternate
+ *  function, output configuration, and input configuration are encoded in a 
+ *  single word as follows.
+ *
+ *  4:0 Pin (31-0)
+ *  7:5 Port (F-A)
+ *  8 Direction
+ *  9 PUEN
+ *  10:11 Primary Function,Alternate Function,GPIO
+ *  13:12 OCR
+ *  15:14 ICONF
+ * 
+ *  [ 15 14 | 13 12 | 11 10 | 9  |  8  | 7 6 5 | 4 3 2 1 0 ]
+ *  [ ICONF |  OCR  | P/A/G | PU | Dir | Port  |    Pin    ]
+ */
+
+#define GPIO_PIN_MASK		(0x1f<<0)
+
+#define GPIO_PORT_POS		5
+#define GPIO_PORT_MASK		(0x3 << GPIO_PORT_POS)
+#define GPIO_PORTA 		(0 << GPIO_PORT_POS)
+#define GPIO_PORTB		(1 << GPIO_PORT_POS)
+#define GPIO_PORTC		(2 << GPIO_PORT_POS)
+#define GPIO_PORTD		(3 << GPIO_PORT_POS)
+#define GPIO_PORTE		(4 << GPIO_PORT_POS)
+#define GPIO_PORTF		(5 << GPIO_PORT_POS)
+
+#define GPIO_DIR_MASK		(1<<8)
+#define GPIO_IN			(0<<8)
+#define GPIO_OUT		(1<<8)
+
+#define GPIO_PU_MASK		(1<<9)
+#define GPIO_PUDIS		(0<<9)
+#define GPIO_PUEN		(1<<9)
+
+#define GPIO_FUNC_MASK		(0x3<<10)
+#define GPIO_PF			(0<<10)
+#define GPIO_AF			(1<<10)
+#define GPIO_GP			(2<<10)
+
+#define GPIO_OCR_POS		12
+#define GPIO_OCR_MASK		(0x3 << GPIO_OCR_POS)
+#define GPIO_AIN		(0 << GPIO_OCR_POS)
+#define GPIO_BIN		(1 << GPIO_OCR_POS)
+#define GPIO_CIN		(2 << GPIO_OCR_POS)
+#define GPIO_DR			(3 << GPIO_OCR_POS)
+
+#define GPIO_ICONF_MASK		(0x3<<14)
+#define GPIO_AOUT		(1<<14)
+#define GPIO_BOUT		(2<<14)
+
+/*
+ *  Freescale i.MX21 GPIO signal multiplexing mode defines
+ */
+
+/*
+ *  The GPIO pin naming convention was developed by the original unknown author. 
+ *  Although using defines for variables is always a good idea for portability, 
+ *  in this case the names are as specific as the values, and thus loose their 
+ *  portability. Ultimately the pin names should be changed to reflect the signal
+ *  name only.  
+ *
+ *  The current naming convention is as follows.
+ *
+ *  P(port)(pin)_(function)_(signal)
+ *
+ *  port = (A-F)
+ *  pin = (0-31)
+ *  function = (PF|AF|AIN|BIN|CIN|DR|AOUT|BOUT)
+ *  signal = signal name from datasheet
+ *
+ *  Remember that when in GPIO mode, AIN, BIN, CIN, and DR are inputs to the GPIO
+ *  peripheral module and represent outputs to the pin. Similarly AOUT, and BOUT
+ *  are outputs from the GPIO peripheral module and represent inputs to the physical 
+ *  pin in question. Refer to the multiplexing table in the section titled "Signal 
+ *  Descriptions and Pin Assignments" in the reference manual.
+ */
+   
+#define PE14_PF_UART1_CTS	( GPIO_PORTE | 14 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PE15_PF_UART1_RTS	( GPIO_PORTE | 15 | GPIO_PF | GPIO_IN | GPIO_PUDIS )
+#define PE12_PF_UART1_TXD	( GPIO_PORTE | 12 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PE13_PF_UART1_RXD	( GPIO_PORTE | 13 | GPIO_PF | GPIO_IN | GPIO_PUDIS )
+
+#define PA5_PF_LSCLK		( GPIO_PORTA | 5 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA6_PF_LD0		( GPIO_PORTA | 6 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA7_PF_LD1		( GPIO_PORTA | 7 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA8_PF_LD2		( GPIO_PORTA | 8 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA9_PF_LD3		( GPIO_PORTA | 9 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA10_PF_LD4		( GPIO_PORTA | 10 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA11_PF_LD5		( GPIO_PORTA | 11 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA12_PF_LD6		( GPIO_PORTA | 12 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA13_PF_LD7		( GPIO_PORTA | 13 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA14_PF_LD8		( GPIO_PORTA | 14 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA15_PF_LD9		( GPIO_PORTA | 15 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA16_PF_LD10		( GPIO_PORTA | 16 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA17_PF_LD11		( GPIO_PORTA | 17 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA18_PF_LD12		( GPIO_PORTA | 18 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA19_PF_LD13		( GPIO_PORTA | 19 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA20_PF_LD14		( GPIO_PORTA | 20 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA21_PF_LD15		( GPIO_PORTA | 21 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA22_PF_LD16		( GPIO_PORTA | 22 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA23_PF_LD17		( GPIO_PORTA | 23 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA24_PF_REV		( GPIO_PORTA | 24 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA25_PF_CLS		( GPIO_PORTA | 25 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA26_PF_PS		( GPIO_PORTA | 26 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA27_PF_SPL_SPR		( GPIO_PORTA | 27 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA28_PF_HSYNC		( GPIO_PORTA | 28 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA29_PF_VSYNC		( GPIO_PORTA | 29 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA30_PF_CONTRAST	( GPIO_PORTA | 30 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA31_PF_OE_ACD		( GPIO_PORTA | 31 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+
+/*
+ *  Freescale i.MX21 register defines
+ *
+ *  All register and field defines should conform to the following naming
+ *  convention, and preferably use the exact names from the corresponding
+ *  datasheets. 
+ *
+ *  #define <module>_<register>		<value>
+ *  #define <register>_<field><type>	<value>
+ *
+ *  Where <type> can be one of the following.
+ *
+ *  _POS = defines the field LSB bit position	
+ *  _MASK = defines the field mask
+ *  (x) = writes x to the field location
+ *
+ *  The POS and MASK entries will be defined on an as needed basis. 
+ */
+
+/*
+ *  Freescale i.MX21 clock controller registers
+ */
+
+#define CRM_CSCR	__REG(MX2ADS_CRM_BASE + 0x0)
+#define CSCR_PRESC_MASK		(0x7<<29)
+#define CSCR_PRESC(x)		(((x) & 0x7) << 29)
+#define CSCR_USB_DIV_MASK	(0x7<<26)
+#define CSCR_USB_DIV(x)		(((x) & 0x7) << 26)
+#define CSCR_SD_CNT_MASK	(0x3<<24)
+#define CSCR_SD_CNT(x)		(((x) & 0x3) << 24)
+#define CSCR_SPLL_RESTART	(1<<22)
+#define CSCR_MPLL_RESTART	(1<<21)
+#define CSCR_SSI2_SEL		(1<<20)
+#define CSCR_SSI1_SEL		(1<<19)
+#define CSCR_FIR_SEL		(1<<18)
+#define CSCR_SP_SEL		(1<<17)
+#define CSCR_MCU_SEL		(1<<16)
+#define CSCR_BCLKDIV_MASK	(0xf<<10)
+#define CSCR_BCLKDIV(x)		(((x) & 0xf) << 10)
+#define CSCR_IPDIV		(1<<9)
+#define CSCR_OSC26M_DIV1P5	(1<<4)
+#define CSCR_OSC28M_DIS		(1<<3)
+#define CSCR_FPM_EN		(1<<2)
+#define CSCR_SPEN		(1<<1)
+#define CSCR_MPEN		(1<<0)
+
+#define CRM_MPCTL0	__REG(MX2ADS_CRM_BASE + 0x4)
+#define MPCTL0_CPLM		(1<<31)
+#define MPCTL0_PD(x)		(((x) & 0xf) << 26)
+#define MPCTL0_MFD(x)		(((x) & 0x3ff) << 16)
+#define MPCTL0_MFI(x)		(((x) & 0xf) << 10)
+#define MPCTL0_MFN(x)		(((x) & 0x3ff) << 0)
+
+#define CRM_MPCTL1	__REG(MX2ADS_CRM_BASE + 0x8)
+#define MPCTL1_LF		(1<<15)
+#define MPCTL1_BRMO		(1<<6)
+
+#define CRM_SPCTL0	__REG(MX2ADS_CRM_BASE + 0xc)
+#define SPCTL0_CPLM		(1<<31)
+#define SPCTL0_PD(x)		(((x) & 0xf) << 26)
+#define SPCTL0_MFD(x)		(((x) & 0x3ff) << 16)
+#define SPCTL0_MFI(x)		(((x) & 0xf) << 10)
+#define SPCTL0_MFN(x)		(((x) & 0x3ff) << 0)
+
+#define CRM_SPCTL1	__REG(MX2ADS_CRM_BASE + 0x10)
+#define SPCTL1_LF		(1<<15)
+#define SPCTL1_BRMO		(1<<6)
+
+#define CRM_OSC26MCTL	__REG(MX2ADS_CRM_BASE + 0x14)
+#define OSC26MCTL_OSC26M_PEAK	(0x2<<16)
+#define OSC25MCTL_AGC(x)	(((x) & 0x3f) << 8)
+
+#define CRM_PCDR0	__REG(MX2ADS_CRM_BASE + 0x18)
+#define PCDR0_SSI2DIV(x)	(((x) & 0x3f) << 26)
+#define PCDR0_SSI1DIV(x)	(((x) & 0x3f) << 16)
+#define PCDR0_NFCDIV(x)		(((x) & 0xf) << 12)
+#define PCDR0_CLKO_48MDIV(x)	(((x) & 0x7) << 5)
+#define PCDR0_FIRI_DIV(x)	(((x) & 0x1f) << 0)
+		
+#define CRM_PCDR1	__REG(MX2ADS_CRM_BASE + 0x1c)
+#define PCDR1_PERDIV4_POS	24
+#define PCDR1_PERDIV4_MASK	(0x3f << PCDR1_PERDIV4_POS)
+#define PCDR1_PERDIV4(x)	(((x) & 0x3f) << 24)
+#define PCDR1_PERDIV3_POS	16
+#define PCDR1_PERDIV3_MASK	(0x3f << PCDR1_PERDIV3_POS)
+#define PCDR1_PERDIV3(x) 	(((x) & 0x3f) << 16)
+#define PCDR1_PERDIV2_POS	8
+#define PCDR1_PERDIV2_MASK	(0x3f << PCDR1_PERDIV2_POS)
+#define PCDR1_PERDIV2(x) 	(((x) & 0x3f) << 8)
+#define PCDR1_PERDIV1_POS	0
+#define PCDR1_PERDIV1_MASK	(0x3f << PCDR1_PERDIV1_POS)
+#define PCDR1_PERDIV1(x) 	(((x) & 0x3f) << 0)
+
+#define CRM_PCCR0	__REG(MX2ADS_CRM_BASE + 0x20) 
+#define PCCR0_HCLK_CSI_EN 	(1<<31)
+#define PCCR0_HCLK_DMA_EN 	(1<<30)
+#define PCCR0_HCLK_BROM_EN 	(1<<28)
+#define PCCR0_HCLK_EMMA_EN 	(1<<27)
+#define PCCR0_HCLK_LCDC_EN 	(1<<26)
+#define PCCR0_HCLK_SLCDC_EN 	(1<<25)
+#define PCCR0_HCLK_USBOTG_EN 	(1<<24)
+#define PCCR0_HCLK_BMI_EN 	(1<<23)
+#define PCCR0_PERCLK4_EN 	(1<<22)
+#define PCCR0_SLCDC_EN	 	(1<<21)
+#define PCCR0_FIRI_BAUD_EN 	(1<<20)
+#define PCCR0_NFC_EN		(1<<19)
+#define PCCR0_PERCLK3_EN 	(1<<18)
+#define PCCR0_SSI1_BAUD_EN 	(1<<17)
+#define PCCR0_SSI2_BAUD_EN 	(1<<16)
+#define PCCR0_EMMA_EN 		(1<<15)
+#define PCCR0_USBOTG_EN	 	(1<<14)
+#define PCCR0_DMA_EN 		(1<<13)
+#define PCCR0_I2C_EN 		(1<<12)
+#define PCCR0_GPIO_EN	 	(1<<11)
+#define PCCR0_SDHC2_EN	 	(1<<10)
+#define PCCR0_SDHC1_EN	 	(1<<9)
+#define PCCR0_FIRI_EN	 	(1<<8)
+#define PCCR0_SSI2_EN	 	(1<<7)
+#define PCCR0_SSI1_EN		(1<<6)
+#define PCCR0_CSPI2_EN	 	(1<<5)
+#define PCCR0_CSPI1_EN	 	(1<<4)
+#define PCCR0_UART4_EN	 	(1<<3)
+#define PCCR0_UART3_EN	 	(1<<2)
+#define PCCR0_UART2_EN 		(1<<1)
+#define PCCR0_UART1_EN	 	(1<<0)
+
+#define CRM_PCCR1	__REG(MX2ADS_CRM_BASE + 0x24)
+#define PCCR1_OWIRE_EN		(1<<31)
+#define PCCR1_KPP_EN		(1<<30)
+#define PCCR1_RTC_EN		(1<<29)
+#define PCCR1_PWM_EN		(1<<28)
+#define PCCR1_GPT3_EN		(1<<27)
+#define PCCR1_GPT2_EN		(1<<26)
+#define PCCR1_GPT1_EN		(1<<25)
+#define PCCR1_WDT_EN		(1<<24)
+#define PCCR1_CSPI3_EN		(1<<23)
+#define PCCR1_RTIC_EN		(1<<22)
+#define PCCR1_RNGA_EN		(1<<21)
+
+#define CRM_CCSR	__REG(MX2ADS_CRM_BASE + 0x28)
+#define CCSR_32K_SR		(1<<15)
+#define CCSR_CLK0_SEL(x)	(((x) & 0x1f) << 0)
+	
+#define CRM_WKGDCTL	__REG(MX2ADS_CRM_BASE + 0x34)
+#define WKGDCTL_WKDG_EN		(1<<0)
+
+/*
+ * LCD controller (LCDC) registers
+ */
+
+#define LCDC_LSSAR	__REG(MX2ADS_LCDC_BASE + 0x0)
+#define LSSAR_SSA(x)		(((x) & 0x3fffffff) << 2)
+
+#define LCDC_LSR 	__REG(MX2ADS_LCDC_BASE + 0x4)
+#define LSR_XMAX(x)		(((x) & 0x3f) << 20)
+#define LSR_YMAX(x)		(((x) & 0x3ff) << 0)
+
+#define LCDC_LVPWR 	__REG(MX2ADS_LCDC_BASE + 0x8)
+#define LVPWR_VPW(x)		(((x) & 0x3ff) << 0)
+
+#define LCDC_LCPR 	__REG(MX2ADS_LCDC_BASE + 0xc)
+#define LCPR_CC(x)		(((x) & 0x3) << 30)
+#define LCPR_OP			(1<<28)
+#define LCPR_CXP(x)		(((x) & 0x3ff) << 16)
+#define LCPR_CYP(x)		(((x) & 0x3ff) << 0)
+
+#define LCPR_CC_DISABLED	0
+#define LCPR_CC_OR		1
+#define LCPR_CC_XOR		2
+#define LCPR_CC_AND		3
+
+#define LCDC_LCWHBR 	__REG(MX2ADS_LCDC_BASE + 0x10)
+#define LCWHBR_BK_EN		(1<<31)
+#define LCWHBR_CW(x)		(((x) & 0x1f) << 24)
+#define LCWHBR_CH(x)		(((x) & 0x1f) << 16)
+#define LCWHBR_BD(x)		(((x) & 0xff) << 0)
+
+#define LCDC_LCCMR 	__REG(MX2ADS_LCDC_BASE + 0x14)
+#define LCCMR_CUR_COL_R(x)	(((x) & 0x3f) << 12)
+#define LCCMR_CUR_COL_G(x)	(((x) & 0x3f) << 6)
+#define LCCMR_CUR_COL_B(x)	(((x) & 0x3f) << 0)
+
+#define LCDC_LPCR 	__REG(MX2ADS_LCDC_BASE + 0x18)
+#define LPCR_TFT		(1<<31)
+#define LPCR_COLOR		(1<<30)
+#define LPCR_PBSIZ_POS		28
+#define LPCR_PBSIZ_MASK		(0x3 << LPCR_PBSIZ_POS)
+#define LPCR_PBSIZ(x)		(((x) << LPCR_PBSIZ_POS) & LPCR_PBSIZ_MASK)
+#define LPCR_BPIX_POS		25
+#define LPCR_BPIX_MASK		(0x7 << LPCR_BPIX_POS)
+#define LPCR_BPIX(x)		(((x) << LPCR_BPIX_POS) & LPCR_BPIX_MASK)
+#define LPCR_PIXPOL		(1<<24)
+#define LPCR_FLMPOL		(1<<23)
+#define LPCR_LPPOL		(1<<22)
+#define LPCR_CLKPOL		(1<<21)
+#define LPCR_OEPOL		(1<<20)
+#define LPCR_SCLKIDLE		(1<<19)
+#define LPCR_END_SEL		(1<<18)
+#define LPCR_SWAP_SEL		(1<<17)
+#define LPCR_REV_VS		(1<<16)
+#define LPCR_ACDSEL		(1<<15)
+#define LPCR_ACD(x)		(((x) & 0x7f) << 8)
+#define LPCR_SCLKSEL		(1<<7)
+#define LPCR_SHARP		(1<<6)
+#define LPCR_PCD(x)		(((x) & 0x3f) << 0)
+
+#define LPCR_PBSIZ_PANEL_BUS_WIDTH_1	0
+#define LPCR_PBSIZ_PANEL_BUS_WIDTH_4	2
+#define LPCR_PBSIZ_PANEL_BUS_WIDTH_8	3
+
+#define LPCR_BPIX_BITS_PER_PIXEL_1	0
+#define LPCR_BPIX_BITS_PER_PIXEL_2	1
+#define LPCR_BPIX_BITS_PER_PIXEL_4	2
+#define LPCR_BPIX_BITS_PER_PIXEL_8	3
+#define LPCR_BPIX_BITS_PER_PIXEL_12	4
+#define LPCR_BPIX_BITS_PER_PIXEL_16	5
+#define LPCR_BPIX_BITS_PER_PIXEL_18	6
+
+#define LCDC_LHCR 	__REG(MX2ADS_LCDC_BASE + 0x1c)
+#define LHCR_H_WIDTH(x)		(((x) & 0x3f) << 26)
+#define LHCR_H_WAIT_1(x)	(((x) & 0x1ff) << 8)
+#define LHCR_H_WAIT_2(x)	(((x) & 0x1ff) << 0)
+
+#define LCDC_LVCR 	__REG(MX2ADS_LCDC_BASE + 0x20)
+#define LVCR_V_WIDTH(x)		(((x) & 0x3f) << 26)
+#define LVCR_V_WAIT_1(x)	(((x) & 0x1ff) << 8)
+#define LVCR_V_WAIT_2(x)	(((x) & 0x1ff) << 0)
+
+#define LCDC_LPOR 	__REG(MX2ADS_LCDC_BASE + 0x24)
+#define LPOR_POS(x)		(((x) & 0x1f) << 0)
+
+#define LCDC_LSCR 	__REG(MX2ADS_LCDC_BASE + 0x28)
+#define LSCR_PS_RISE_DELAY(x)		(((x) & 0x3f) << 26)
+#define LSCR_CLS_RISE_DELAY(x)		(((x) & 0xff) << 16)
+#define LSCR_REV_TOGGLE_DELAY(x)	(((x) & 0xf) << 8)
+#define LSCR_GRAY2(x)			(((x) & 0xf) << 4)
+#define LSCR_GRAY1(x)			(((x) & 0xf) << 0)
+
+#define LCDC_LPCCR 	__REG(MX2ADS_LCDC_BASE + 0x2c)
+#define LPCCR_CLS_HI_WIDTH(x)	(((x) & 0x1ff) << 16)
+#define LPCCR_LDMSK		(1<<15)
+#define LPCCR_SCR(x)		(((x) & 0x3) << 9)
+#define LPCCR_CC_EN		(1<<8)
+#define LPCCR_PW(x)		(((x) & 0xff) << 0)
+
+#define LPCCR_SCR_LINE_PULSE	0
+#define LPCCR_SCR_PIXEL_CLOCK	1
+#define LPCCR_SCR_LCD_CLOCK	2
+
+#define LCDC_LDCR 	__REG(MX2ADS_LCDC_BASE + 0x30)
+#define LDCR_BURST		(1<<31)
+#define LDCR_HM(x)		(((x) & 0x1f) << 16)
+#define LDCR_TM(x)		(((x) & 0x1f) << 0)
+
+#define LCDC_LRMCR 	__REG(MX2ADS_LCDC_BASE + 0x34)
+#define LRMCR_LCDC_EN	        (1<<1)
+#define LRMCR_SELF_REF		(1<<0)
+
+
+#define LCDC_LICR 	__REG(MX2ADS_LCDC_BASE + 0x38)
+#define LICR_GW_INIT_CON	(1<<4)
+#define LICR_INTSYN		(1<<2)
+#define LICR_INTCON		(1<<0)
+
+#define LCDC_LIER 	__REG(MX2ADS_LCDC_BASE + 0x3c)
+#define LIER_GW_UDR_ERR_EN	(1<<7)
+#define LIER_GW_ERR_RES_EN	(1<<6)
+#define LIER_GW_EOF_EN		(1<<5)
+#define LIER_GW_BOF_EN		(1<<4)
+#define LIER_UDR_ERR_EN		(1<<3)
+#define LIER_ERR_RES_EN		(1<<2)
+#define LIER_EOF_EN		(1<<1)
+#define LIER_BOF_EN		(1<<0)
+
+#define LCDC_LISR 	__REG(MX2ADS_LCDC_BASE + 0x40)
+#define LISR_GW_UDR_ERR_MASK	(1<<7)
+#define LISR_GW_ERR_RES_MASK	(1<<6)
+#define LISR_GW_EOF_MASK	(1<<5)
+#define LISR_GW_BOF_MASK	(1<<4)
+#define LISR_UDR_ERR_MASK	(1<<3)
+#define LISR_ERR_RES_MASK	(1<<2)
+#define LISR_EOF_MASK		(1<<1)
+#define LISR_BOF_MASK		(1<<0)
+
+#define LCDC_LGWSAR 	__REG(MX2ADS_LCDC_BASE + 0x50)
+#define LGWSAR_GWSA(x)		(((x) & 0x3fffffff) << 2)
+
+#define LCDC_LGWSR 	__REG(MX2ADS_LCDC_BASE + 0x54)
+#define LGWSR_GWW(x)		(((x) & 0x3f) << 20)
+#define LGWSR_GWH(x)		(((x) & 0x3fff) << 0)
+
+#define LCDC_LGWVPWR 	__REG(MX2ADS_LCDC_BASE + 0x58)
+#define LGWVPWR_GWVPW(x)	(((x) & 0x3ff) << 0)
+
+#define LCDC_LGWPOR 	__REG(MX2ADS_LCDC_BASE + 0x5c)
+#define LGWPOR(x)		(((x) & 0x1f) << 0)
+
+#define LCDC_LGWPR 	__REG(MX2ADS_LCDC_BASE + 0x60)
+#define LGWPR_GWXP(x)		(((x) & 0x3ff) << 16)
+#define LGWPR_GWYP(x)		(((x) & 0x3ff) << 0)
+
+#define LCDC_LGWCR 	__REG(MX2ADS_LCDC_BASE + 0x64)
+#define LGWCR_GWAV(x)		(((x) & 0xff) << 24)
+#define LGWCR_GWCKE		(1<<23)
+#define LGWCR_GWE		(1<<22)
+#define LGWCR_GW_RVS		(1<<21)
+#define LGWCR_GWCKR(x)		(((x) & 0x3f) << 12)
+#define LGWCR_GWCKG(x)		(((x) & 0x3f) << 6)
+#define LGWCR_GWCKB(x)		(((x) & 0x3f) << 0)
+
+#define LCDC_LGWDCR 	__REG(MX2ADS_LCDC_BASE + 0x68)
+#define LGWDCR_GWBT		(1<<31)
+#define LGWDCR_GWHM(x)		(((x) & 0x1f) << 16)
+#define LGWDCR_GWTM(x)		(((x) & 0x1f) << 0)
+
+/*
+ *  General purpose timers
+ */
+#define WHICH_TIMER(x)     ((x)*0x1000)
+#define IMX21_TCTL(x)        __REG( 0x00 + MX2ADS_GPT1_BASE + WHICH_TIMER(x) )
+#define TCTL_SWR           (1<<15)
+#define TCTL_FRR           (1<<8)
+#define TCTL_CAP_RIS       (1<<6)
+#define TCTL_CAP_FAL       (2<<6)
+#define TCTL_CAP_RIS_FAL   (3<<6)
+#define TCTL_CLK_PCLK1     (1<<1)
+#define TCTL_CLK_PCLK1_16  (2<<1)
+#define TCTL_CLK_TIN       (3<<1)
+#define TCTL_CLK_32        (4<<1)
+#define TCTL_TEN           (1<<0)
+
+/*
+ * Update with Xenomai patch for iMx21 plateform
+ */
+#define TCTL_OM		   (1<<9)
+#define TCTL_CC            (1<<10)
+#define TCTL_IRQ_COMP	   (1<<4)
+#define TCTL_IRQ_CAPT	   (1<<5)
+
+#define IMX21_TPRER(x)       __REG( 0x04 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define IMX21_TCMP(x)        __REG( 0x08 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define IMX21_TCR(x)         __REG( 0x0C + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define IMX21_TCN(x)         __REG( 0x10 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define IMX21_TSTAT(x)       __REG( 0x14 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define TSTAT_CAPT         (1<<1)
+#define TSTAT_COMP         (1<<0)
+
+#define GPT1		0
+#define GPT2		1
+#define GPT3		2
+
+/*
+ *  Uart controller registers 
+ */
+
+#define UART_1  0
+#define UART_2  1
+#define UART_3  2
+#define UART_4  3
+
+
+#define URXD0(x) __REG( 0x0 + (x)) /* Receiver Register */
+#define URTX0(x) __REG( 0x40 + (x)) /* Transmitter Register */
+#define UCR1(x)  __REG( 0x80 + (x)) /* Control Register 1 */
+#define UCR2(x)  __REG( 0x84 + (x)) /* Control Register 2 */
+#define UCR3(x)  __REG( 0x88 + (x)) /* Control Register 3 */
+#define UCR4(x)  __REG( 0x8c + (x)) /* Control Register 4 */
+#define UFCR(x)  __REG( 0x90 + (x)) /* FIFO Control Register */
+#define USR1(x)  __REG( 0x94 + (x)) /* Status Register 1 */
+#define USR2(x)  __REG( 0x98 + (x)) /* Status Register 2 */
+#define UESC(x)  __REG( 0x9c + (x)) /* Escape Character Register */
+#define UTIM(x)  __REG( 0xa0 + (x)) /* Escape Timer Register */
+#define UBIR(x)  __REG( 0xa4 + (x)) /* BRM Incremental Register */
+#define UBMR(x)  __REG( 0xa8 + (x)) /* BRM Modulator Register */
+#define UBRC(x)  __REG( 0xac + (x)) /* Baud Rate Count Register */
+#define ONMES(x) __REG( 0xb0 + (x)) /* One Millisecond Register */
+#define UTS(x)   __REG( 0xb4 + (x)) /* UART Test Register */
+
+
+
+/* UART Control Register Bit Fields.*/
+#define  URXD_CHARRDY    (1<<15)
+#define  URXD_ERR        (1<<14)
+#define  URXD_OVRRUN     (1<<13)
+#define  URXD_FRMERR     (1<<12)
+#define  URXD_BRK        (1<<11)
+#define  URXD_PRERR      (1<<10)
+
+#define  UCR1_ADEN       (1<<15) /* Auto dectect interrupt */
+#define  UCR1_ADBR       (1<<14) /* Auto detect baud rate */
+#define  UCR1_TRDYEN     (1<<13) /* Transmitter ready interrupt enable */
+#define  UCR1_IDEN       (1<<12) /* Idle condition interrupt */
+#define  UCR1_RRDYEN     (1<<9)	 /* Recv ready interrupt enable */
+#define  UCR1_RDMAEN     (1<<8)	 /* Recv ready DMA enable */
+#define  UCR1_IREN       (1<<7)	 /* Infrared interface enable */
+#define  UCR1_TXMPTYEN   (1<<6)	 /* Transimitter empty interrupt enable */
+#define  UCR1_RTSDEN     (1<<5)	 /* RTS delta interrupt enable */
+#define  UCR1_SNDBRK     (1<<4)	 /* Send break */
+#define  UCR1_TDMAEN     (1<<3)	 /* Transmitter ready DMA enable */
+// not on mx21 #define  UCR1_UARTCLKEN  (1<<2)	 /* UART clock enabled */
+#define  UCR1_DOZE       (1<<1)	 /* Doze */
+#define  UCR1_UARTEN     (1<<0)	 /* UART enabled */
+
+#define  UCR2_ESCI     	 (1<<15) /* Escape seq interrupt enable */
+#define  UCR2_IRTS  	 (1<<14) /* Ignore RTS pin */
+#define  UCR2_CTSC  	 (1<<13) /* CTS pin control */
+#define  UCR2_CTS        (1<<12) /* Clear to send */
+#define  UCR2_ESCEN      (1<<11) /* Escape enable */
+#define  UCR2_PREN       (1<<8)  /* Parity enable */
+#define  UCR2_PROE       (1<<7)  /* Parity odd/even */
+#define  UCR2_STPB       (1<<6)	 /* Stop */
+#define  UCR2_WS         (1<<5)	 /* Word size */
+#define  UCR2_RTSEN      (1<<4)	 /* Request to send interrupt enable */
+#define  UCR2_ATEN	 (1<<3)  /* Aging Timer Enable */
+#define  UCR2_TXEN       (1<<2)	 /* Transmitter enabled */
+#define  UCR2_RXEN       (1<<1)	 /* Receiver enabled */
+#define  UCR2_SRST 	 (1<<0)	 /* SW reset */
+
+#define  UCR3_DTREN 	 (1<<13) /* DTR interrupt enable */
+#define  UCR3_PARERREN   (1<<12) /* Parity enable */
+#define  UCR3_FRAERREN   (1<<11) /* Frame error interrupt enable */
+#define  UCR3_DSR        (1<<10) /* Data set ready */
+#define  UCR3_DCD        (1<<9)  /* Data carrier detect */
+#define  UCR3_RI         (1<<8)  /* Ring indicator */
+#define  UCR3_ADNIMP     (1<<7)  /* Timeout interrupt enable */
+#define  UCR3_RXDSEN	 (1<<6)  /* Receive status interrupt enable */
+#define  UCR3_AIRINTEN   (1<<5)  /* Async IR wake interrupt enable */
+#define  UCR3_AWAKEN	 (1<<4)  /* Async wake interrupt enable */
+// not on mx21 #define  UCR3_REF25 	 (1<<3)  /* Ref freq 25 MHz */
+#define  UCR3_RXDMUXSEL  (1<<2)  /* RXD Mux Input Select */
+#define  UCR3_INVT  	 (1<<1)  /* Inverted Infrared transmission */
+#define  UCR3_ACIEN  	 (1<<0)  /* Autobaud Counter  Interrupt Enable */
+
+
+#define  UCR4_INVR  	 (1<<9)  /* Inverted infrared reception */
+#define  UCR4_ENIRI 	 (1<<8)  /* Serial infrared interrupt enable */
+#define  UCR4_WKEN  	 (1<<7)  /* Wake interrupt enable */
+// not on mx21 #define  UCR4_REF16 	 (1<<6)  /* Ref freq 16 MHz */
+#define  UCR4_IRSC  	 (1<<5)  /* IR special case */
+#define  UCR4_LPBYP  	 (1<<5)  /* Low Power Bypass */
+#define  UCR4_TCEN  	 (1<<3)  /* Transmit complete interrupt enable */
+#define  UCR4_BKEN  	 (1<<2)  /* Break condition interrupt enable */
+#define  UCR4_OREN  	 (1<<1)  /* Receiver overrun interrupt enable */
+#define  UCR4_DREN  	 (1<<0)  /* Recv data ready interrupt enable */
+
+#define  UFCR_RXTL_SHF   0       /* Receiver trigger level shift */
+#define  UFCR_RFDIV      (7<<7)  /* Reference freq divider mask */
+#define  UFCR_RFDIV_SHF  7	 /* Reference freq divider shift */
+#define  UFCR_TXTL_SHF   10      /* Transmitter trigger level shift */
+#define  UFCR_DCEDTE	 (1<<6)  /* DCE/DTE Mode */
+
+#define  USR1_PARITYERR  (1<<15) /* Parity error interrupt flag */
+#define  USR1_RTSS  	 (1<<14) /* RTS pin status */
+#define  USR1_TRDY  	 (1<<13) /* Transmitter ready interrupt/dma flag */
+#define  USR1_RTSD  	 (1<<12) /* RTS delta */
+#define  USR1_ESCF  	 (1<<11) /* Escape seq interrupt flag */
+#define  USR1_FRAMERR    (1<<10) /* Frame error interrupt flag */
+#define  USR1_RRDY       (1<<9)	 /* Receiver ready interrupt/dma flag */
+#define  USR1_AGTIM      (1<<8)	 /* Aging Timer Interrupt Flag */
+// not on mx21 #define  USR1_TIMEOUT    (1<<7)	 /* Receive timeout interrupt status */
+#define  USR1_RXDS  	 (1<<6)	 /* Receiver idle interrupt flag */
+#define  USR1_AIRINT	 (1<<5)	 /* Async IR wake interrupt flag */
+#define  USR1_AWAKE 	 (1<<4)	 /* Aysnc wake interrupt flag */
+
+#define  USR2_ADET  	 (1<<15) /* Auto baud rate detect complete */
+#define  USR2_TXFE  	 (1<<14) /* Transmit buffer FIFO empty */
+#define  USR2_DTRF  	 (1<<13) /* DTR edge interrupt flag */
+#define  USR2_IDLE  	 (1<<12) /* Idle condition */
+#define  USR2_ACST  	 (1<<11) /* Autobaud Controller Stopped*/
+#define  USR2_RIDELT  	 (1<<10) /* Ring Indicator Delta */
+#define  USR2_RIIN  	 (1<<9)  /* Ring Indicator Input*/
+#define  USR2_IRINT 	 (1<<8)	 /* Serial infrared interrupt flag */
+#define  USR2_WAKE  	 (1<<7)	 /* Wake */
+#define  USR2_DCDDELT  	 (1<<6)	 /* Data Carrier Delta Detect */
+#define  USR2_DCDIN  	 (1<<5)	 /* Data Carrier Detect Input */
+#define  USR2_RTSF  	 (1<<4)	 /* RTS edge interrupt flag */
+#define  USR2_TXDC  	 (1<<3)	 /* Transmitter complete */
+#define  USR2_BRCD  	 (1<<2)	 /* Break condition */
+#define  USR2_ORE        (1<<1)	 /* Overrun error */
+#define  USR2_RDR        (1<<0)	 /* Recv data ready */
+
+#define  UTS_FRCPERR	 (1<<13) /* Force parity error */
+#define  UTS_LOOP        (1<<12) /* Loop tx and rx */
+#define  UTS_DBGEN       (1<<11) /* /Debug Enable */
+#define  UTS_LOOPIR      (1<<10) /* Loop tx and rx for IR */
+#define  UTS_RXFIFO	 (1<<9)	 /* RXFifo Debug */
+#define  UTS_TXEMPTY	 (1<<6)	 /* TxFIFO empty */
+#define  UTS_RXEMPTY	 (1<<5)	 /* RxFIFO empty */
+#define  UTS_TXFULL 	 (1<<4)	 /* TxFIFO full */
+#define  UTS_RXFULL 	 (1<<3)	 /* RxFIFO full */
+#define  UTS_SOFTRST	 (1<<0)	 /* Software reset */
+
+#endif				// _MX2ADS_REGS_H
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx21/imx21fb.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/imx21fb.h
--- linux-2.6.14/include/asm-arm/arch-imx21/imx21fb.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/imx21fb.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,35 @@
+/*
+ * This structure describes the machine which we are running on.
+ */
+struct imxfb_mach_info {
+	u_long		pixclock;
+
+	u_short		xres;
+	u_short		yres;
+
+	u_char		bpp;
+	u_char		hsync_len;
+	u_char		left_margin;
+	u_char		right_margin;
+
+	u_char		vsync_len;
+	u_char		upper_margin;
+	u_char		lower_margin;
+	u_char		sync;
+
+	u_int		cmap_greyscale:1,
+			cmap_inverse:1,
+			cmap_static:1,
+			unused:29;
+
+	u_int		lpcr;
+	u_int		lpccr;
+	u_int		lscr;
+
+	u_char * fixed_screen_cpu;
+	dma_addr_t fixed_screen_dma;
+
+	void (*lcd_power)(int);
+	void (*backlight_power)(int);
+};
+void set_imx_fb_info(struct imxfb_mach_info *hard_imx_fb_info);
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx21/io.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/io.h
--- linux-2.6.14/include/asm-arm/arch-imx21/io.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/io.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,28 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/io.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+#define __io(a)		((void __iomem *)(a))
+#define __mem_pci(a)	(a)
+
+#endif
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx21/irq.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/irq.h
--- linux-2.6.14/include/asm-arm/arch-imx21/irq.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/irq.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,20 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/irq.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define fixup_irq(i)	(i)
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx21/irqs.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/irqs.h
--- linux-2.6.14/include/asm-arm/arch-imx21/irqs.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/irqs.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,131 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/irqs.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ARM_IRQS_H__
+#define __ARM_IRQS_H__
+
+/* Use the imx definitions */
+#include <asm/arch/hardware.h>
+
+/*
+ *  IMX21 Interrupt numbers
+ *
+ */
+
+#define INT_CSPI3		    6
+#define INT_SRCL		    7
+#define INT_GPIO                    8
+#define INT_FIRI                    9
+#define INT_SDHC2                   10
+#define INT_SDHC1                   11
+#define INT_I2C                     12
+#define INT_SSI2                    13
+#define INT_SSI1                    14
+#define INT_CSPI2                   15
+#define INT_CSPI1                   16
+#define INT_UART4                   17
+#define INT_UART3                   18
+#define INT_UART2                   19
+#define INT_UART1                   20
+#define INT_KPP_TX                  21
+#define INT_RTC_RX                  22
+#define INT_PWM                     23
+#define INT_GPT3                    24
+#define INT_GPT2                    25
+#define INT_GPT1                    26
+#define INT_WDOG                    27
+#define INT_PCMCIA                  28
+#define INT_NFC                     29
+#define INT_BMI                     30
+#define INT_CSI                     31
+#define INT_DMACH0                  32
+#define INT_DMACH1                  33
+#define INT_DMACH2                  34
+#define INT_DMACH3                  35
+#define INT_DMACH4                  36
+#define INT_DMACH5                  37
+#define INT_DMACH6                  38
+#define INT_DMACH7                  39
+#define INT_DMACH8                  40
+#define INT_DMACH9                  41
+#define INT_DMACH10                 42
+#define INT_DMACH11                 43
+#define INT_DMACH12                 44
+#define INT_DMACH13                 45
+#define INT_DMACH14                 46
+#define INT_DMACH15                 47
+#define INT_EMMAENC                 49
+#define INT_EMMADEC                 50
+#define INT_EMMAPRP                 51
+#define INT_EMMAPP                  52
+#define INT_USBWKUP                 53
+#define INT_USBMNP                  54
+#define INT_USBDMA                  55
+#define INT_USBFUNC                 56
+#define INT_USBHOST                 57
+#define INT_USBCTRL                 58
+#define INT_SAHARA                  59
+#define INT_SLCDC                   60
+#define INT_LCDC                    61
+
+
+#define IMX21_IRQS		    (64)
+
+/* note: the IMX21 has six gpio ports (A-F), but only
+ *       the following pins are connected to the outside
+ *       world:
+ *
+ * PORT A: bits 0-31
+ * PORT B: bits 8-31
+ * PORT C: bits 3-17
+ * PORT D: bits 6-31
+ * PORT E:
+ * PORT F: bits 0-31 (NAND Flash)
+ *
+ * We map these interrupts straight on. As a result we have
+ * several holes in the interrupt mapping. We do this for two
+ * reasons:
+ *   - mapping the interrupts without holes would get
+ *     far more complicated
+ *   - Motorola could well decide to bring some processor
+ *     with more pins connected
+ */
+
+#define IRQ_GPIOA(x)  (IMX21_IRQS + x)
+#define IRQ_GPIOB(x)  (IRQ_GPIOA(32) + x)
+#define IRQ_GPIOC(x)  (IRQ_GPIOB(32) + x)
+#define IRQ_GPIOD(x)  (IRQ_GPIOC(32) + x)
+#define IRQ_GPIOE(x)  (IRQ_GPIOD(32) + x)
+#define IRQ_GPIOF(x)  (IRQ_GPIOE(32) + x)
+
+/* decode irq number to use with IMR(x), ISR(x) and friends */
+#define IRQ_TO_REG(irq) ((irq - IMX21_IRQS) >> 5)
+
+#define NR_IRQS (IRQ_GPIOF(32) + 1)
+#define IRQ_GPIO(x)
+#endif
+
+#ifdef CONFIG_IPIPE
+#define __ipipe_mach_irq_mux_p(irq) ((irq) == INT_GPIO)
+#endif /* CONFIG_IPIPE */
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx21/memory.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/memory.h
--- linux-2.6.14/include/asm-arm/arch-imx21/memory.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/memory.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,41 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/memory.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_MMU_H
+#define __ASM_ARCH_MMU_H
+
+#define PHYS_OFFSET	(0xc0000000UL)
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus__is_a_macro
+#define __virt_to_bus(x)	(x - PAGE_OFFSET +  PHYS_OFFSET)
+#define __bus_to_virt__is_a_macro
+#define __bus_to_virt(x)	(x -  PHYS_OFFSET + PAGE_OFFSET)
+
+#endif
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx21/mx2ads.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/mx2ads.h
--- linux-2.6.14/include/asm-arm/arch-imx21/mx2ads.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/mx2ads.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,39 @@
+/*
+ * linux/include/asm-arm/arch-imx21/mx2ads.h
+ *
+ * Copyright (C) 2004 Robert Schwebel, Pengutronix
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __ASM_ARCH_MX2ADS_H
+#define __ASM_ARCH_MX2ADS_H
+
+/* ------------------------------------------------------------------------ */
+/* Memory Map for the M9328MX2ADS (MX2ADS) Board                            */
+/* ------------------------------------------------------------------------ */
+
+#define MX2ADS_FLASH_PHYS		0x10000000
+#define MX2ADS_FLASH_SIZE		(16*1024*1024)
+
+#define IMX_FB_PHYS			(0x0C000000 - 0x40000)
+
+#define CLK32 32768
+
+#endif /* __ASM_ARCH_MX2ADS_H */
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx21/param.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/param.h
--- linux-2.6.14/include/asm-arm/arch-imx21/param.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/param.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,19 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/param.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx21/system.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/system.h
--- linux-2.6.14/include/asm-arm/arch-imx21/system.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/system.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,40 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/system.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+static void
+arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+static inline void
+arch_reset(char mode)
+{
+	cpu_reset(0);
+}
+
+#endif
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx21/timex.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/timex.h
--- linux-2.6.14/include/asm-arm/arch-imx21/timex.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/timex.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,27 @@
+/*
+ *  linux/include/asm-arm/imx/timex.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+#include <asm/arch/hardware.h>
+#define CLOCK_TICK_RATE		(CLK32)
+
+#endif
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx21/uncompress.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/uncompress.h
--- linux-2.6.14/include/asm-arm/arch-imx21/uncompress.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/uncompress.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,182 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/uncompress.h
+ *
+ *
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) Shane Nay (shane@minirl.com)
+ *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#if 0		// TODO: use similar code (automatically pick port
+
+#define UART_TX  ((char *) (0xcc200000))
+#define UART_LSR ((char *) (0xcc200005))
+#if 1
+#define UARTDELAY { int x = 8000;		\
+	while (x--);				\
+    }	
+#else	
+#define UARTDELAY {				\
+	while ( ((*UART_LSR) & 0x20) ) {	\
+	    ;					\
+	}					\
+    }
+#endif
+void dputc(char c)
+{
+    UARTDELAY;
+    *UART_TX = c;
+}
+
+static void puts(const char *s)
+{
+    while (*s) {
+	dputc(*s);
+	if ( *s == '\n' ) {
+	    dputc('\r');
+	}
+	s++;
+    }
+}
+
+static void
+putstr(const char *s)
+{
+    puts(s);
+}
+
+void puthex(int x)
+{
+    int i;
+    char tmp[8];
+    
+    for ( i = 0; i <= 7; i++ ) {
+	int y = x & 0xf;
+	if ( y <= 9 )
+	    tmp[i] = y + '0';	    
+	else
+	    tmp[i] = y + 'a' - 10;
+	
+	x >>= 4;
+    }
+
+    puts("0x");
+    for ( i = 7; i >= 0; i-- ) {
+	dputc(tmp[i]);
+    }
+    
+}
+
+void pval(char *s, int v)
+{
+    puts(s);
+    puts(": ");
+    puthex(v);
+    puts("\n");
+    
+}
+
+
+#else		// orig 2.6 mx1 code:
+
+#define UART(x) (*(volatile unsigned long *)(serial_port + (x)))
+
+#define UART1_BASE 0x1000a000
+#define UART2_BASE 0x1000b000
+#define USR2 0x98
+#define USR2_TXFE (1<<14)
+#define TXR  0x40
+#define UCR1 0x80
+#define UCR1_UARTEN 1
+
+/*
+ * The following code assumes the serial port has already been
+ * initialized by the bootloader.  We search for the first enabled
+ * port in the most probable order.  If you didn't setup a port in
+ * your bootloader then nothing will appear (which might be desired).
+ *
+ * This does not append a newline
+ */
+static void
+putstr(const char *s)
+{
+	unsigned long serial_port;
+
+	do {
+		serial_port = UART1_BASE;
+		if ( UART(UCR1) & UCR1_UARTEN )
+			break;
+		serial_port = UART2_BASE;
+		if ( UART(UCR1) & UCR1_UARTEN )
+			break;
+		return;
+	} while(0);
+
+	while (*s) {
+		while ( !(UART(USR2) & USR2_TXFE) )
+			barrier();
+
+		UART(TXR) = *s;
+
+		if (*s == '\n') {
+			while ( !(UART(USR2) & USR2_TXFE) )
+				barrier();
+
+			UART(TXR) = '\r';
+		}
+		s++;
+	}
+}
+
+void puthex(int x)
+{
+    int i;
+    char tmp[8];
+    char num[11];
+    num[0]  = '0';
+    num[1]  = 'x';
+    num[10] = 0;
+
+    for ( i = 0; i <= 7; i++ ) {
+	int y = x & 0xf;
+	if ( y <= 9 )
+	    tmp[i] = y + '0';	    
+	else
+	    tmp[i] = y + 'a' - 10;
+	
+	x >>= 4;
+    }
+
+    for ( i = 7; i >= 0; i-- ) {
+        num[9-i] = tmp[i];
+    }
+
+    putstr(num);
+    
+}
+#endif		// TMP UART CODE....
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-imx21/vmalloc.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/vmalloc.h
--- linux-2.6.14/include/asm-arm/arch-imx21/vmalloc.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/vmalloc.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,32 @@
+/*
+ *  linux/include/asm-arm/arch-imx21/vmalloc.h
+ *
+ *  Copyright (C) 2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define VMALLOC_OFFSET	  (8*1024*1024)
+#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+#define VMALLOC_END       (PAGE_OFFSET + 0x10000000)
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-integrator/entry-macro.S ipipe-2.6.14-imx21/include/asm-arm/arch-integrator/entry-macro.S
--- linux-2.6.14/include/asm-arm/arch-integrator/entry-macro.S	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-integrator/entry-macro.S	2008-02-21 22:09:00.000000000 +0100
@@ -20,7 +20,11 @@
 		teq	\irqstat, #0
 		ldreq	\irqstat, [\base, #(INTEGRATOR_HDR_IC_OFFSET+IRQ_STATUS)]
 		moveq	\irqnr, #IRQ_CIC_START
-
+#ifdef CONFIG_IPIPE
+		tst	\irqstat, #0x00000040			@ check IRQ_TIMERINT1 first
+		movne	\irqnr, #6
+		bne	1003f
+#endif /* CONFIG_IPIPE */
 1001:		tst	\irqstat, #15
 		bne	1002f
 		add	\irqnr, \irqnr, #4
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-integrator/irqs.h ipipe-2.6.14-imx21/include/asm-arm/arch-integrator/irqs.h
--- linux-2.6.14/include/asm-arm/arch-integrator/irqs.h	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-integrator/irqs.h	2008-02-21 22:09:00.000000000 +0100
@@ -80,3 +80,6 @@
 
 #define NR_IRQS                         47
 
+#ifdef CONFIG_IPIPE
+#define __ipipe_mach_irq_mux_p(irq) ((irq) == IRQ_CP_CPPLDINT)
+#endif /* CONFIG_IPIPE */
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-integrator/platform.h ipipe-2.6.14-imx21/include/asm-arm/arch-integrator/platform.h
--- linux-2.6.14/include/asm-arm/arch-integrator/platform.h	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-integrator/platform.h	2008-02-21 22:09:00.000000000 +0100
@@ -26,13 +26,15 @@
  * 	NOTE: This is a multi-hosted header file for use with uHAL and
  * 	      supported debuggers.
  *
- * 	$Id: platform.s,v 1.32 2000/02/18 10:51:39 asims Exp $
+ * 	$Id: platform.h,v 1.2 2006/02/20 13:54:22 rpm Exp $
  *
  * ***********************************************************************/
 
 #ifndef __address_h
 #define __address_h                     1
 
+#include <linux/config.h>
+
 /* ========================================================================
  *  Integrator definitions
  * ========================================================================
@@ -436,7 +438,7 @@
  *  Timer definitions
  *
  *  Only use timer 1 & 2
- *  (both run at 24MHz and will need the clock divider set to 16).
+ *  (both run at 1MHZ on /CP and at 24MHz on /AP)
  *
  *  Timer 0 runs at bus frequency and therefore could vary and currently
  *  uHAL can't handle that.
@@ -449,7 +451,12 @@
 
 #define MAX_TIMER                       2
 #define MAX_PERIOD                      699050
+
+#ifdef CONFIG_ARCH_INTEGRATOR_CP
+#define TICKS_PER_uSEC                  1
+#else
 #define TICKS_PER_uSEC                  24
+#endif
 
 /*
  *  These are useconds NOT ticks.
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-integrator/timex.h ipipe-2.6.14-imx21/include/asm-arm/arch-integrator/timex.h
--- linux-2.6.14/include/asm-arm/arch-integrator/timex.h	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-integrator/timex.h	2008-02-21 22:09:00.000000000 +0100
@@ -21,6 +21,6 @@
  */
 
 /*
- * ??
+ * Timer rate
  */
-#define CLOCK_TICK_RATE		(50000000 / 16)
+#define CLOCK_TICK_RATE		(1000000)
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-pxa/irqs.h ipipe-2.6.14-imx21/include/asm-arm/arch-pxa/irqs.h
--- linux-2.6.14/include/asm-arm/arch-pxa/irqs.h	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-pxa/irqs.h	2008-02-21 22:09:00.000000000 +0100
@@ -73,6 +73,10 @@
 			((i) - IRQ_GPIO(2) + 2)
 #define IRQ_TO_GPIO(i)	(((i) < IRQ_GPIO(2)) ? ((i) - IRQ_GPIO0) : IRQ_TO_GPIO_2_x(i))
 
+#ifdef CONFIG_IPIPE
+#define __ipipe_mach_irq_mux_p(irq) ((irq) == IRQ_GPIO_2_x)
+#endif /* CONFIG_IPIPE */
+
 #if defined(CONFIG_PXA25x)
 #define PXA_LAST_GPIO	80
 #elif defined(CONFIG_PXA27x)
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-s3c2410/irqs.h ipipe-2.6.14-imx21/include/asm-arm/arch-s3c2410/irqs.h
--- linux-2.6.14/include/asm-arm/arch-s3c2410/irqs.h	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-s3c2410/irqs.h	2008-02-21 22:09:00.000000000 +0100
@@ -3,6 +3,8 @@
  * Copyright (c) 2003-2005 Simtec Electronics
  *   Ben Dooks <ben@simtec.co.uk>
  *
+ * Copyright (C) 2006 Sebastian Smolorz <ssmolorz@emlix.com>, emlix GmbH
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -13,6 +15,7 @@
  *  12-Mar-2004 BJD  Fixed bug in header protection
  *  10-Feb-2005 BJD  Added camera IRQ from guillaume.gourat@nexvision.tv
  *  28-Feb-2005 BJD  Updated s3c2440 IRQs
+ *  30-Oct-2006      Added Adeos/I-pipe support
  */
 
 
@@ -123,4 +126,26 @@
 #define NR_IRQS (IRQ_S3C2440_AC97+1)
 
 
+#ifdef CONFIG_IPIPE
+#define __ipipe_irqbit(irq)	(1 << ((irq) - S3C2410_CPUIRQ_OFFSET))
+
+#ifdef CONFIG_CPU_S3C2440
+#define __ipipe_muxed_irqmask	(__ipipe_irqbit(IRQ_UART0)	|	\
+				 __ipipe_irqbit(IRQ_UART1)	|	\
+				 __ipipe_irqbit(IRQ_UART2)	|	\
+				 __ipipe_irqbit(IRQ_ADCPARENT)	|	\
+				 __ipipe_irqbit(IRQ_WDT)	|	\
+				 __ipipe_irqbit(IRQ_CAM))
+#else /* !CONFIG_CPU_S3C2440 */
+#define __ipipe_muxed_irqmask	(__ipipe_irqbit(IRQ_UART0)	|	\
+				 __ipipe_irqbit(IRQ_UART1)	|	\
+				 __ipipe_irqbit(IRQ_UART2)	|	\
+				 __ipipe_irqbit(IRQ_ADCPARENT))
+#endif /* CONFIG_CPU_S3C2440 */
+
+#define __ipipe_mach_irq_mux_p(irq)	((irq) <= IRQ_ADCPARENT  &&	\
+					 (__ipipe_irqbit(irq) &		\
+					  __ipipe_muxed_irqmask))
+#endif /* CONFIG_IPIPE */
+
 #endif /* __ASM_ARCH_IRQ_H */
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/arch-sa1100/irqs.h ipipe-2.6.14-imx21/include/asm-arm/arch-sa1100/irqs.h
--- linux-2.6.14/include/asm-arm/arch-sa1100/irqs.h	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-sa1100/irqs.h	2008-02-21 22:09:00.000000000 +0100
@@ -145,6 +145,10 @@
 #define IRQ_LOCOMO_SPI_OVRN	(IRQ_BOARD_END + 20)
 #define IRQ_LOCOMO_SPI_TEND	(IRQ_BOARD_END + 21)
 
+#ifdef CONFIG_IPIPE
+#define __ipipe_mach_irq_mux_p(irq) ((irq) == IRQ_GPIO11_27)
+#endif /* CONFIG_IPIPE */
+
 /*
  * Figure out the MAX IRQ number.
  *
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/atomic.h ipipe-2.6.14-imx21/include/asm-arm/atomic.h
--- linux-2.6.14/include/asm-arm/atomic.h	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/asm-arm/atomic.h	2008-02-21 22:09:00.000000000 +0100
@@ -85,9 +85,9 @@ static inline void atomic_clear_mask(uns
 	unsigned long tmp, tmp2;
 
 	__asm__ __volatile__("@ atomic_clear_mask\n"
-"1:	ldrex	%0, %2\n"
+"1:	ldrex	%0, [%2]\n"
 "	bic	%0, %0, %3\n"
-"	strex	%1, %0, %2\n"
+"	strex	%1, %0, [%2]\n"
 "	teq	%1, #0\n"
 "	bne	1b"
 	: "=&r" (tmp), "=&r" (tmp2)
@@ -110,10 +110,10 @@ static inline int atomic_add_return(int 
 	unsigned long flags;
 	int val;
 
-	local_irq_save(flags);
+	local_irq_save_hw(flags);
 	val = v->counter;
 	v->counter = val += i;
-	local_irq_restore(flags);
+	local_irq_restore_hw(flags);
 
 	return val;
 }
@@ -123,10 +123,10 @@ static inline int atomic_sub_return(int 
 	unsigned long flags;
 	int val;
 
-	local_irq_save(flags);
+	local_irq_save_hw(flags);
 	val = v->counter;
 	v->counter = val -= i;
-	local_irq_restore(flags);
+	local_irq_restore_hw(flags);
 
 	return val;
 }
@@ -135,9 +135,9 @@ static inline void atomic_clear_mask(uns
 {
 	unsigned long flags;
 
-	local_irq_save(flags);
+	local_irq_save_hw(flags);
 	*addr &= ~mask;
-	local_irq_restore(flags);
+	local_irq_restore_hw(flags);
 }
 
 #endif /* __LINUX_ARM_ARCH__ */
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/bitops.h ipipe-2.6.14-imx21/include/asm-arm/bitops.h
--- linux-2.6.14/include/asm-arm/bitops.h	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/asm-arm/bitops.h	2008-02-21 22:09:00.000000000 +0100
@@ -36,9 +36,9 @@ static inline void ____atomic_set_bit(un
 
 	p += bit >> 5;
 
-	local_irq_save(flags);
+	local_irq_save_hw(flags);
 	*p |= mask;
-	local_irq_restore(flags);
+	local_irq_restore_hw(flags);
 }
 
 static inline void ____atomic_clear_bit(unsigned int bit, volatile unsigned long *p)
@@ -48,9 +48,9 @@ static inline void ____atomic_clear_bit(
 
 	p += bit >> 5;
 
-	local_irq_save(flags);
+	local_irq_save_hw(flags);
 	*p &= ~mask;
-	local_irq_restore(flags);
+	local_irq_restore_hw(flags);
 }
 
 static inline void ____atomic_change_bit(unsigned int bit, volatile unsigned long *p)
@@ -60,9 +60,9 @@ static inline void ____atomic_change_bit
 
 	p += bit >> 5;
 
-	local_irq_save(flags);
+	local_irq_save_hw(flags);
 	*p ^= mask;
-	local_irq_restore(flags);
+	local_irq_restore_hw(flags);
 }
 
 static inline int
@@ -74,10 +74,10 @@ ____atomic_test_and_set_bit(unsigned int
 
 	p += bit >> 5;
 
-	local_irq_save(flags);
+	local_irq_save_hw(flags);
 	res = *p;
 	*p = res | mask;
-	local_irq_restore(flags);
+	local_irq_restore_hw(flags);
 
 	return res & mask;
 }
@@ -91,10 +91,10 @@ ____atomic_test_and_clear_bit(unsigned i
 
 	p += bit >> 5;
 
-	local_irq_save(flags);
+	local_irq_save_hw(flags);
 	res = *p;
 	*p = res & ~mask;
-	local_irq_restore(flags);
+	local_irq_restore_hw(flags);
 
 	return res & mask;
 }
@@ -108,10 +108,10 @@ ____atomic_test_and_change_bit(unsigned 
 
 	p += bit >> 5;
 
-	local_irq_save(flags);
+	local_irq_save_hw(flags);
 	res = *p;
 	*p = res ^ mask;
-	local_irq_restore(flags);
+	local_irq_restore_hw(flags);
 
 	return res & mask;
 }
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/ipipe.h ipipe-2.6.14-imx21/include/asm-arm/ipipe.h
--- linux-2.6.14/include/asm-arm/ipipe.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/ipipe.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,217 @@
+/* -*- linux-c -*-
+ * include/asm-arm/ipipe.h
+ *
+ * Copyright (C) 2002-2005 Philippe Gerum.
+ * Copyright (C) 2005 Stelian Pop.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge MA 02139,
+ * USA; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __ARM_IPIPE_H
+#define __ARM_IPIPE_H
+
+#include <linux/config.h>
+
+#ifdef CONFIG_IPIPE
+
+#include <linux/list.h>
+#include <linux/cpumask.h>
+#include <linux/threads.h>
+#include <asm/ptrace.h>
+#include <asm/irq.h>
+#include <asm/bitops.h>
+#include <asm/mach/irq.h>
+#include <asm/percpu.h>
+
+#define IPIPE_ARCH_STRING	"1.5-08"
+#define IPIPE_MAJOR_NUMBER	1
+#define IPIPE_MINOR_NUMBER	5
+#define IPIPE_PATCH_NUMBER	8
+
+#define IPIPE_NR_XIRQS		NR_IRQS
+#define IPIPE_IRQ_ISHIFT	5	/* 25 for 32bits arch. */
+
+#ifdef CONFIG_SMP
+#error "I-pipe/arm: SMP not yet implemented"
+#define ipipe_processor_id()	(current_thread_info()->cpu)
+#else /* !CONFIG_SMP */
+#define ipipe_processor_id()	0
+#endif	/* CONFIG_SMP */
+
+/* Note that we disable the interrupts around context_switch,
+ * or we'll get into severe problems when scheduling Xenomai's
+ * user space real time threads.
+ * This can however cause high latencies, see for example:
+ * 	http://www.ussg.iu.edu/hypermail/linux/kernel/0405.2/1388.html
+ * This may need further optimization...
+ */
+#define prepare_arch_switch(next)				\
+do {								\
+	ipipe_schedule_notify(current, next);			\
+	local_irq_disable_hw();					\
+} while(0)
+
+#define task_hijacked(p)						\
+	({								\
+		int __x__ = ipipe_current_domain != ipipe_root_domain;	\
+		/* We would need to clear the SYNC flag for the root domain */ \
+		/* over the current processor in SMP mode. */		\
+		local_irq_enable_hw(); __x__;				\
+	})
+
+/* ARM traps */
+#define IPIPE_TRAP_ACCESS	 0	/* Data or instruction access exception */
+#define IPIPE_TRAP_SECTION	 1	/* Section fault */
+#define IPIPE_TRAP_DABT		 2	/* Generic data abort */
+#define IPIPE_TRAP_UNKNOWN	 3	/* Unknown exception */
+#define IPIPE_TRAP_BREAK	 4	/* Instruction breakpoint */
+#define IPIPE_TRAP_FPU		 5	/* Floating point exception */
+#define IPIPE_TRAP_VFP		 6	/* VFP floating point exception */
+#define IPIPE_TRAP_UNDEFINSTR	 7	/* Undefined instruction */
+#define IPIPE_NR_FAULTS		 8
+
+/* Pseudo-vectors used for kernel events */
+#define IPIPE_FIRST_EVENT	IPIPE_NR_FAULTS
+#define IPIPE_EVENT_SYSCALL	(IPIPE_FIRST_EVENT)
+#define IPIPE_EVENT_SCHEDULE	(IPIPE_FIRST_EVENT + 1)
+#define IPIPE_EVENT_SIGWAKE	(IPIPE_FIRST_EVENT + 2)
+#define IPIPE_EVENT_SETSCHED	(IPIPE_FIRST_EVENT + 3)
+#define IPIPE_EVENT_INIT	(IPIPE_FIRST_EVENT + 4)
+#define IPIPE_EVENT_EXIT	(IPIPE_FIRST_EVENT + 5)
+#define IPIPE_EVENT_CLEANUP	(IPIPE_FIRST_EVENT + 6)
+#define IPIPE_LAST_EVENT	IPIPE_EVENT_CLEANUP
+#define IPIPE_NR_EVENTS		(IPIPE_LAST_EVENT + 1)
+
+extern unsigned long arm_return_addr(int level);
+
+#define BROKEN_BUILTIN_RETURN_ADDRESS
+#define __BUILTIN_RETURN_ADDRESS0 arm_return_addr(0)
+#define __BUILTIN_RETURN_ADDRESS1 arm_return_addr(1)
+
+
+struct ipipe_domain;
+
+struct ipipe_sysinfo {
+
+	int ncpus;		/* Number of CPUs on board */
+	u64 cpufreq;		/* CPU frequency (in Hz) */
+
+	/* Arch-dependent block */
+
+	struct {
+		unsigned tmirq;	/* Timer tick IRQ */
+		u64 tmfreq;	/* Timer frequency */
+	} archdep;
+};
+
+/* arch specific stuff */
+extern int __ipipe_mach_timerint;
+extern int __ipipe_mach_timerstolen;
+extern unsigned int __ipipe_mach_ticks_per_jiffy;
+extern void __ipipe_mach_acktimer(void);
+extern unsigned long long __ipipe_mach_get_tsc(void);
+extern void __ipipe_mach_set_dec(unsigned long);
+extern void __ipipe_mach_release_timer(void);
+extern unsigned long __ipipe_mach_get_dec(void);
+extern void __ipipe_mach_demux_irq(unsigned irq, struct pt_regs *regs);
+
+#define ipipe_read_tsc(t)		do { t = __ipipe_mach_get_tsc(); } while (0)
+#define __ipipe_read_timebase()		__ipipe_mach_get_tsc()
+
+#define ipipe_cpu_freq()	(HZ * __ipipe_mach_ticks_per_jiffy)
+#define ipipe_tsc2ns(t) \
+({ \
+	unsigned long long delta = (t)*1000; \
+	do_div(delta, ipipe_cpu_freq() / 1000000 + 1); \
+	(unsigned long)delta; \
+})
+#define ipipe_tsc2us(t) \
+({ \
+	unsigned long long delta = (t); \
+	do_div(delta, ipipe_cpu_freq() / 1000000 + 1); \
+	(unsigned long)delta; \
+})
+
+/* Private interface -- Internal use only */
+
+#define __ipipe_check_platform()	do { } while(0)
+
+#define __ipipe_enable_irqdesc(irq)	do { irq_desc[irq].disable_depth = 0; } while(0)
+
+#define __ipipe_enable_irq(irq)	irq_desc[irq].chip->unmask(irq)
+
+#define __ipipe_disable_irq(irq)	irq_desc[irq].chip->mask(irq)
+
+void __ipipe_init_platform(void);
+
+void __ipipe_enable_pipeline(void);
+
+int __ipipe_ack_irq(unsigned irq);
+
+int __ipipe_ack_timerirq(unsigned irq);
+
+void __ipipe_do_IRQ(int irq,
+		    struct pt_regs *regs);
+
+void __ipipe_do_timer(int irq,
+		      struct pt_regs *regs);
+
+void __ipipe_do_critical_sync(unsigned irq,
+			      void *cookie);
+
+extern unsigned long __ipipe_decr_ticks;
+
+extern unsigned long long __ipipe_decr_next[];
+
+extern struct pt_regs __ipipe_tick_regs[];
+
+void __ipipe_handle_irq(int irq,
+			struct pt_regs *regs);
+
+#define __ipipe_tick_irq	ipipe_timerint
+
+static inline unsigned long __ipipe_ffnz(unsigned long ul)
+{
+	return ffs(ul) - 1;
+}
+
+/* When running handlers, enable hw interrupts for all domains but the
+ * one heading the pipeline, so that IRQs can never be significantly
+ * deferred for the latter. */
+#define __ipipe_run_isr(ipd, irq, cpuid) 	\
+do {					 	\
+	local_irq_enable_nohead(ipd);		\
+	if (ipd == ipipe_root_domain) {		\
+		((void (*)(unsigned, struct pt_regs *))			\
+		 ipd->irqs[irq].handler) (irq, __ipipe_tick_regs + cpuid); \
+	} else {							\
+		__clear_bit(IPIPE_SYNC_FLAG, &cpudata->status);		\
+		ipd->irqs[irq].handler(irq,ipd->irqs[irq].cookie);	\
+		__set_bit(IPIPE_SYNC_FLAG, &cpudata->status);		\
+	}								\
+	local_irq_disable_nohead(ipd);					\
+} while(0)
+
+#define __ipipe_syscall_watched_p(p, sc)	\
+	(((p)->flags & PF_EVNOTIFY) || (unsigned long)sc >= __ARM_NR_BASE + 64)
+
+#else /* !CONFIG_IPIPE */
+
+#define task_hijacked(p)	0
+
+#endif /* CONFIG_IPIPE */
+
+#endif	/* !__ARM_IPIPE_H */
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/mmu_context.h ipipe-2.6.14-imx21/include/asm-arm/mmu_context.h
--- linux-2.6.14/include/asm-arm/mmu_context.h	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/asm-arm/mmu_context.h	2008-02-21 22:09:00.000000000 +0100
@@ -80,13 +80,16 @@ static inline void
 switch_mm(struct mm_struct *prev, struct mm_struct *next,
 	  struct task_struct *tsk)
 {
-	unsigned int cpu = smp_processor_id();
+	unsigned int cpu = smp_processor_id_hw();
 
 	if (prev != next) {
+		unsigned long flags;
+		local_irq_save_hw_cond(flags);
 		cpu_set(cpu, next->cpu_vm_mask);
 		check_context(next);
 		cpu_switch_mm(next->pgd, next);
 		cpu_clear(cpu, prev->cpu_vm_mask);
+		local_irq_restore_hw_cond(flags);
 	}
 }
 
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/pgalloc.h ipipe-2.6.14-imx21/include/asm-arm/pgalloc.h
--- linux-2.6.14/include/asm-arm/pgalloc.h	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/asm-arm/pgalloc.h	2008-02-21 22:09:00.000000000 +0100
@@ -29,6 +29,11 @@ extern void free_pgd_slow(pgd_t *pgd);
 
 #define check_pgt_cache()		do { } while (0)
 
+static inline void set_pgdir(unsigned long address, pgd_t entry)
+{
+	/* nop */
+}
+
 /*
  * Allocate one PTE table.
  *
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/asm-arm/system.h ipipe-2.6.14-imx21/include/asm-arm/system.h
--- linux-2.6.14/include/asm-arm/system.h	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/asm-arm/system.h	2008-02-21 22:09:00.000000000 +0100
@@ -4,6 +4,7 @@
 #ifdef __KERNEL__
 
 #include <linux/config.h>
+#include <asm/ptrace.h>
 
 #define CPU_ARCH_UNKNOWN	0
 #define CPU_ARCH_ARMv3		1
@@ -176,30 +177,30 @@ do {									\
  */
 #if __LINUX_ARM_ARCH__ >= 6
 
-#define local_irq_save(x)					\
+#define local_irq_save_hw_notrace(x)				\
 	({							\
 	__asm__ __volatile__(					\
-	"mrs	%0, cpsr		@ local_irq_save\n"	\
+	"mrs	%0, cpsr		@ local_irq_save_hw\n"	\
 	"cpsid	i"						\
 	: "=r" (x) : : "memory", "cc");				\
 	})
 
-#define local_irq_enable()  __asm__("cpsie i	@ __sti" : : : "memory", "cc")
-#define local_irq_disable() __asm__("cpsid i	@ __cli" : : : "memory", "cc")
-#define local_fiq_enable()  __asm__("cpsie f	@ __stf" : : : "memory", "cc")
-#define local_fiq_disable() __asm__("cpsid f	@ __clf" : : : "memory", "cc")
+#define local_irq_enable_hw_notrace()  __asm__("cpsie i	@ __sti" : : : "memory", "cc")
+#define local_irq_disable_hw_notrace() __asm__("cpsid i	@ __cli" : : : "memory", "cc")
+#define local_fiq_enable_hw_notrace()  __asm__("cpsie f	@ __stf" : : : "memory", "cc")
+#define local_fiq_disable_hw_notrace() __asm__("cpsid f	@ __clf" : : : "memory", "cc")
 
 #else
 
 /*
  * Save the current interrupt enable state & disable IRQs
  */
-#define local_irq_save(x)					\
+#define local_irq_save_hw_notrace(x)				\
 	({							\
 		unsigned long temp;				\
 		(void) (&temp == &x);				\
 	__asm__ __volatile__(					\
-	"mrs	%0, cpsr		@ local_irq_save\n"	\
+	"mrs	%0, cpsr		@ local_irq_save_hw\n"	\
 "	orr	%1, %0, #128\n"					\
 "	msr	cpsr_c, %1"					\
 	: "=r" (x), "=r" (temp)					\
@@ -210,11 +211,11 @@ do {									\
 /*
  * Enable IRQs
  */
-#define local_irq_enable()					\
+#define local_irq_enable_hw_notrace()				\
 	({							\
 		unsigned long temp;				\
 	__asm__ __volatile__(					\
-	"mrs	%0, cpsr		@ local_irq_enable\n"	\
+	"mrs	%0, cpsr		@ local_irq_enable_hw\n"\
 "	bic	%0, %0, #128\n"					\
 "	msr	cpsr_c, %0"					\
 	: "=r" (temp)						\
@@ -225,11 +226,11 @@ do {									\
 /*
  * Disable IRQs
  */
-#define local_irq_disable()					\
+#define local_irq_disable_hw_notrace()				\
 	({							\
 		unsigned long temp;				\
 	__asm__ __volatile__(					\
-	"mrs	%0, cpsr		@ local_irq_disable\n"	\
+	"mrs	%0, cpsr		@ local_irq_disable_hw\n"\
 "	orr	%0, %0, #128\n"					\
 "	msr	cpsr_c, %0"					\
 	: "=r" (temp)						\
@@ -240,7 +241,7 @@ do {									\
 /*
  * Enable FIQs
  */
-#define local_fiq_enable()					\
+#define local_fiq_enable_hw_notrace()				\
 	({							\
 		unsigned long temp;				\
 	__asm__ __volatile__(					\
@@ -255,7 +256,7 @@ do {									\
 /*
  * Disable FIQs
  */
-#define local_fiq_disable()					\
+#define local_fiq_disable_hw_notrace()				\
 	({							\
 		unsigned long temp;				\
 	__asm__ __volatile__(					\
@@ -272,29 +273,112 @@ do {									\
 /*
  * Save the current interrupt enable state.
  */
-#define local_save_flags(x)					\
+#define local_save_flags_hw(x)					\
 	({							\
 	__asm__ __volatile__(					\
-	"mrs	%0, cpsr		@ local_save_flags"	\
+	"mrs	%0, cpsr		@ local_save_flags_hw"	\
 	: "=r" (x) : : "memory", "cc");				\
 	})
 
 /*
  * restore saved IRQ & FIQ state
  */
-#define local_irq_restore(x)					\
+#define local_irq_restore_hw_notrace(x)				\
 	__asm__ __volatile__(					\
-	"msr	cpsr_c, %0		@ local_irq_restore\n"	\
+	"msr	cpsr_c, %0		@ local_irq_restore_hw\n"\
 	:							\
 	: "r" (x)						\
 	: "memory", "cc")
 
-#define irqs_disabled()			\
-({					\
+#define irqs_disabled_hw()		\
+	({				\
 	unsigned long flags;		\
-	local_save_flags(flags);	\
+	local_save_flags_hw(flags);	\
 	(int)(flags & PSR_I_BIT);	\
-})
+	})
+
+
+#ifdef CONFIG_IPIPE
+
+void __ipipe_stall_root(void);
+void __ipipe_unstall_root(void);
+unsigned long __ipipe_test_root(void);
+unsigned long __ipipe_test_and_stall_root(void);
+void __ipipe_restore_root(unsigned long flags);
+
+#define local_test_iflag_hw(x)   (!((x) & PSR_I_BIT))
+
+/* PSR_I_BIT is bit no. 7 and is set if interrupts are _disabled_ */
+#define local_irq_save(flags)		((flags) = __ipipe_test_and_stall_root() << 7)
+#define local_irq_enable()		__ipipe_unstall_root()
+#define local_irq_disable()		__ipipe_stall_root()
+#define local_fiq_enable()		__ipipe_unstall_root()
+#define local_fiq_disable()		__ipipe_stall_root()
+#define local_save_flags(flags)	((flags) = __ipipe_test_root() << 7)
+#define local_irq_restore(flags)	__ipipe_restore_root(flags & (1 << 7))
+
+#define irqs_disabled()		__ipipe_test_root()
+
+#ifdef CONFIG_IPIPE_TRACE_IRQSOFF
+
+#include <linux/ipipe_trace.h>
+
+#define local_irq_disable_hw() do { \
+	if (!irqs_disabled_hw()) { \
+		local_irq_disable_hw_notrace(); \
+		ipipe_trace_begin(0x80000000); \
+	} \
+} while (0)
+#define local_irq_enable_hw() do { \
+	if (irqs_disabled_hw()) { \
+		ipipe_trace_end(0x80000000); \
+		local_irq_enable_hw_notrace(); \
+	} \
+} while (0)
+#define local_irq_save_hw(x) do { \
+	local_save_flags_hw(x); \
+	if (local_test_iflag_hw(x)) { \
+		local_irq_disable_hw_notrace(); \
+		ipipe_trace_begin(0x80000001); \
+	} \
+} while (0)
+#define local_irq_restore_hw(x) do { \
+	if (local_test_iflag_hw(x)) \
+		ipipe_trace_end(0x80000001); \
+	local_irq_restore_hw_notrace(x); \
+} while (0)
+
+#else /* !CONFIG_IPIPE_TRACE_IRQSOFF */
+
+#define local_irq_save_hw(flags)	local_irq_save_hw_notrace(flags)
+#define local_irq_enable_hw()		local_irq_enable_hw_notrace()
+#define local_irq_disable_hw()		local_irq_disable_hw_notrace()
+#define local_fiq_enable_hw()		local_fiq_enable_hw_notrace()
+#define local_fiq_disable_hw()		local_fiq_disable_hw_notrace()
+#define local_irq_restore_hw(flags)	local_irq_restore_hw_notrace(flags)
+
+#endif /* CONFIG_IPIPE_TRACE_IRQSOFF */
+
+#else /* !CONFIG_IPIPE */
+
+#define local_irq_save(flags)		local_irq_save_hw_notrace(flags)
+#define local_irq_enable()		local_irq_enable_hw_notrace()
+#define local_irq_disable()		local_irq_disable_hw_notrace()
+#define local_fiq_enable()		local_fiq_enable_hw_notrace()
+#define local_fiq_disable()		local_fiq_disable_hw_notrace()
+#define local_save_flags(flags)		local_save_flags_hw(flags)
+#define local_irq_restore(flags)	local_irq_restore_hw_notrace(flags)
+
+#define local_irq_save_hw(flags)	local_irq_save_hw_notrace(flags)
+#define local_irq_enable_hw()		local_irq_enable_hw_notrace()
+#define local_irq_disable_hw()		local_irq_disable_hw_notrace()
+#define local_fiq_enable_hw()		local_fiq_enable_hw_notrace()
+#define local_fiq_disable_hw()		local_fiq_disable_hw_notrace()
+#define local_irq_restore_hw(flags)	local_irq_restore_hw_notrace(flags)
+
+#define irqs_disabled()		irqs_disabled_hw()
+
+#endif /* CONFIG_IPIPE */
 
 #ifdef CONFIG_SMP
 
@@ -369,17 +453,17 @@ static inline unsigned long __xchg(unsig
 #error SMP is not supported on this platform
 #endif
 	case 1:
-		local_irq_save(flags);
+		local_irq_save_hw(flags);
 		ret = *(volatile unsigned char *)ptr;
 		*(volatile unsigned char *)ptr = x;
-		local_irq_restore(flags);
+		local_irq_restore_hw(flags);
 		break;
 
 	case 4:
-		local_irq_save(flags);
+		local_irq_save_hw(flags);
 		ret = *(volatile unsigned long *)ptr;
 		*(volatile unsigned long *)ptr = x;
-		local_irq_restore(flags);
+		local_irq_restore_hw(flags);
 		break;
 #else
 	case 1:
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/linux/hardirq.h ipipe-2.6.14-imx21/include/linux/hardirq.h
--- linux-2.6.14/include/linux/hardirq.h	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/linux/hardirq.h	2008-02-21 22:09:00.000000000 +0100
@@ -87,8 +87,21 @@ extern void synchronize_irq(unsigned int
 # define synchronize_irq(irq)	barrier()
 #endif
 
+#ifdef CONFIG_IPIPE
+#define nmi_enter() \
+do { \
+    if (ipipe_current_domain == ipipe_root_domain) \
+	irq_enter(); \
+} while(0)
+#define nmi_exit() \
+do { \
+    if (ipipe_current_domain == ipipe_root_domain) \
+	sub_preempt_count(HARDIRQ_OFFSET); \
+} while(0)
+#else /* !CONFIG_IPIPE */
 #define nmi_enter()		irq_enter()
 #define nmi_exit()		sub_preempt_count(HARDIRQ_OFFSET)
+#endif /* CONFIG_IPIPE */
 
 #ifndef CONFIG_VIRT_CPU_ACCOUNTING
 static inline void account_user_vtime(struct task_struct *tsk)
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/linux/ipipe.h ipipe-2.6.14-imx21/include/linux/ipipe.h
--- linux-2.6.14/include/linux/ipipe.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/linux/ipipe.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,770 @@
+/* -*- linux-c -*-
+ * include/linux/ipipe.h
+ *
+ * Copyright (C) 2002-2005 Philippe Gerum.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge MA 02139,
+ * USA; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __LINUX_IPIPE_H
+#define __LINUX_IPIPE_H
+
+#include <linux/config.h>
+#include <linux/spinlock.h>
+#include <linux/cache.h>
+#include <linux/percpu.h>
+#include <asm/ipipe.h>
+
+#ifdef CONFIG_IPIPE
+
+#define IPIPE_VERSION_STRING	IPIPE_ARCH_STRING
+#define IPIPE_RELEASE_NUMBER	((IPIPE_MAJOR_NUMBER << 16) | \
+				 (IPIPE_MINOR_NUMBER <<  8) | \
+				 (IPIPE_PATCH_NUMBER))
+
+#ifndef BROKEN_BUILTIN_RETURN_ADDRESS
+#define __BUILTIN_RETURN_ADDRESS0 ((unsigned long)__builtin_return_address(0))
+#define __BUILTIN_RETURN_ADDRESS1 ((unsigned long)__builtin_return_address(1))
+#endif /* !BROKEN_BUILTIN_RETURN_ADDRESS */
+
+#define IPIPE_ROOT_PRIO		100
+#define IPIPE_ROOT_ID		0
+#define IPIPE_ROOT_NPTDKEYS	4	/* Must be <= BITS_PER_LONG */
+
+#define IPIPE_RESET_TIMER	0x1
+#define IPIPE_GRAB_TIMER	0x2
+
+/* Global domain flags */
+#define IPIPE_SPRINTK_FLAG	0	/* Synchronous printk() allowed */
+#define IPIPE_AHEAD_FLAG	1	/* Domain always heads the pipeline */
+
+/* Per-cpu pipeline status */
+#define IPIPE_STALL_FLAG	0	/* Stalls a pipeline stage -- guaranteed at bit #0 */
+#define IPIPE_SYNC_FLAG		1	/* The interrupt syncer is running for the domain */
+#define IPIPE_NOSTACK_FLAG	2	/* Domain currently runs on a foreign stack */
+
+#define IPIPE_SYNC_MASK		(1 << IPIPE_SYNC_FLAG)
+
+/* Interrupt control bits */
+#define IPIPE_HANDLE_FLAG	0
+#define IPIPE_PASS_FLAG		1
+#define IPIPE_ENABLE_FLAG	2
+#define IPIPE_DYNAMIC_FLAG	IPIPE_HANDLE_FLAG
+#define IPIPE_STICKY_FLAG	3
+#define IPIPE_SYSTEM_FLAG	4
+#define IPIPE_LOCK_FLAG		5
+#define IPIPE_SHARED_FLAG	6
+#define IPIPE_WIRED_FLAG	7
+#define IPIPE_EXCLUSIVE_FLAG	8
+
+#define IPIPE_HANDLE_MASK	(1 << IPIPE_HANDLE_FLAG)
+#define IPIPE_PASS_MASK		(1 << IPIPE_PASS_FLAG)
+#define IPIPE_ENABLE_MASK	(1 << IPIPE_ENABLE_FLAG)
+#define IPIPE_DYNAMIC_MASK	IPIPE_HANDLE_MASK
+#define IPIPE_STICKY_MASK	(1 << IPIPE_STICKY_FLAG)
+#define IPIPE_SYSTEM_MASK	(1 << IPIPE_SYSTEM_FLAG)
+#define IPIPE_LOCK_MASK		(1 << IPIPE_LOCK_FLAG)
+#define IPIPE_SHARED_MASK	(1 << IPIPE_SHARED_FLAG)
+#define IPIPE_WIRED_MASK	(1 << IPIPE_WIRED_FLAG)
+#define IPIPE_EXCLUSIVE_MASK	(1 << IPIPE_EXCLUSIVE_FLAG)
+
+#define IPIPE_DEFAULT_MASK	(IPIPE_HANDLE_MASK|IPIPE_PASS_MASK)
+#define IPIPE_STDROOT_MASK	(IPIPE_HANDLE_MASK|IPIPE_PASS_MASK|IPIPE_SYSTEM_MASK)
+
+#define IPIPE_EVENT_SELF        0x80000000
+
+/* Number of virtual IRQs */
+#define IPIPE_NR_VIRQS		BITS_PER_LONG
+/* First virtual IRQ # */
+#define IPIPE_VIRQ_BASE		(((IPIPE_NR_XIRQS + BITS_PER_LONG - 1) / BITS_PER_LONG) * BITS_PER_LONG)
+/* Total number of IRQ slots */
+#define IPIPE_NR_IRQS		(IPIPE_VIRQ_BASE + IPIPE_NR_VIRQS)
+/* Number of indirect words needed to map the whole IRQ space. */
+#define IPIPE_IRQ_IWORDS	((IPIPE_NR_IRQS + BITS_PER_LONG - 1) / BITS_PER_LONG)
+#define IPIPE_IRQ_IMASK		(BITS_PER_LONG - 1)
+#define IPIPE_IRQMASK_ANY	(~0L)
+#define IPIPE_IRQMASK_VIRT	(IPIPE_IRQMASK_ANY << (IPIPE_VIRQ_BASE / BITS_PER_LONG))
+
+#ifdef CONFIG_SMP
+
+#define IPIPE_NR_CPUS		NR_CPUS
+#define ipipe_declare_cpuid	int cpuid
+#define ipipe_load_cpuid()	do { \
+					(cpuid) = ipipe_processor_id();	\
+				} while(0)
+#define ipipe_lock_cpu(flags)	do { \
+					local_irq_save_hw(flags); \
+					(cpuid) = ipipe_processor_id(); \
+				} while(0)
+#define ipipe_unlock_cpu(flags)	local_irq_restore_hw(flags)
+#define ipipe_get_cpu(flags)	ipipe_lock_cpu(flags)
+#define ipipe_put_cpu(flags)	ipipe_unlock_cpu(flags)
+#define ipipe_current_domain	per_cpu(ipipe_percpu_domain, ipipe_processor_id())
+
+#else /* !CONFIG_SMP */
+
+#define IPIPE_NR_CPUS		1
+#define ipipe_declare_cpuid	const int cpuid = 0
+#define ipipe_load_cpuid()	do { } while(0)
+#define ipipe_lock_cpu(flags)	local_irq_save_hw(flags)
+#define ipipe_unlock_cpu(flags)	local_irq_restore_hw(flags)
+#define ipipe_get_cpu(flags)	do { (void)(flags); } while(0)
+#define ipipe_put_cpu(flags)	do { } while(0)
+#define ipipe_current_domain	per_cpu(ipipe_percpu_domain, 0)
+
+#endif /* CONFIG_SMP */
+
+#define ipipe_virtual_irq_p(irq)	((irq) >= IPIPE_VIRQ_BASE && \
+					 (irq) < IPIPE_NR_IRQS)
+
+typedef void (*ipipe_irq_handler_t)(unsigned irq,
+				    void *cookie);
+
+#define IPIPE_SAME_HANDLER	((ipipe_irq_handler_t)(-1))
+
+typedef int (*ipipe_irq_ackfn_t)(unsigned irq);
+
+typedef int (*ipipe_event_handler_t)(unsigned event,
+				     struct ipipe_domain *from,
+				     void *data);
+struct ipipe_domain {
+
+	struct list_head p_link;	/* Link in pipeline */
+
+	struct ipcpudata {
+		unsigned long status;
+		unsigned long irq_pending_hi;
+		unsigned long irq_pending_lo[IPIPE_IRQ_IWORDS];
+		struct ipirqcnt {
+			unsigned long pending_hits;
+			unsigned long total_hits;
+		} irq_counters[IPIPE_NR_IRQS];
+		unsigned long long evsync;
+	} ____cacheline_aligned_in_smp cpudata[IPIPE_NR_CPUS];
+
+	struct {
+		unsigned long control;
+		ipipe_irq_ackfn_t acknowledge;
+		ipipe_irq_handler_t handler;
+		void *cookie;
+	} ____cacheline_aligned irqs[IPIPE_NR_IRQS];
+
+	ipipe_event_handler_t evhand[IPIPE_NR_EVENTS]; /* Event handlers. */
+	unsigned long long evself;	/* Self-monitored event bits. */
+	unsigned long flags;
+	unsigned domid;
+	const char *name;
+	int priority;
+	void *pdd;
+};
+
+#define IPIPE_HEAD_PRIORITY	(-1) /* For domains always heading the pipeline */
+
+struct ipipe_domain_attr {
+
+	unsigned domid;		/* Domain identifier -- Magic value set by caller */
+	const char *name;	/* Domain name -- Warning: won't be dup'ed! */
+	int priority;		/* Priority in interrupt pipeline */
+	void (*entry) (void);	/* Domain entry point */
+	void *pdd;		/* Per-domain (opaque) data pointer */
+};
+
+/* The following macros must be used hw interrupts off. */
+
+#define __ipipe_irq_cookie(ipd,irq)	(ipd)->irqs[irq].cookie
+#define __ipipe_irq_handler(ipd,irq)	(ipd)->irqs[irq].handler
+
+#define __ipipe_cpudata_irq_hits(ipd,cpuid,irq)	((ipd)->cpudata[cpuid].irq_counters[irq].total_hits)
+
+#define __ipipe_set_irq_bit(ipd,cpuid,irq) \
+do { \
+	if (!test_bit(IPIPE_LOCK_FLAG,&(ipd)->irqs[irq].control)) { \
+		__set_bit(irq & IPIPE_IRQ_IMASK,&(ipd)->cpudata[cpuid].irq_pending_lo[irq >> IPIPE_IRQ_ISHIFT]); \
+		__set_bit(irq >> IPIPE_IRQ_ISHIFT,&(ipd)->cpudata[cpuid].irq_pending_hi); \
+	} \
+} while(0)
+
+#define __ipipe_clear_pend(ipd,cpuid,irq) \
+do { \
+	__clear_bit(irq & IPIPE_IRQ_IMASK,&(ipd)->cpudata[cpuid].irq_pending_lo[irq >> IPIPE_IRQ_ISHIFT]); \
+	if ((ipd)->cpudata[cpuid].irq_pending_lo[irq >> IPIPE_IRQ_ISHIFT] == 0) \
+		__clear_bit(irq >> IPIPE_IRQ_ISHIFT,&(ipd)->cpudata[cpuid].irq_pending_hi); \
+} while(0)
+
+#define __ipipe_lock_irq(ipd,cpuid,irq) \
+do { \
+	if (!test_and_set_bit(IPIPE_LOCK_FLAG,&(ipd)->irqs[irq].control)) \
+		__ipipe_clear_pend(ipd,cpuid,irq); \
+} while(0)
+
+#define __ipipe_unlock_irq(ipd,irq) \
+do { \
+	int __cpuid, __nr_cpus = num_online_cpus(); \
+	if (test_and_clear_bit(IPIPE_LOCK_FLAG,&(ipd)->irqs[irq].control)) \
+		for (__cpuid = 0; __cpuid < __nr_cpus; __cpuid++) \
+			if ((ipd)->cpudata[__cpuid].irq_counters[irq].pending_hits > 0) { /* We need atomic ops next. */ \
+				set_bit(irq & IPIPE_IRQ_IMASK,&(ipd)->cpudata[__cpuid].irq_pending_lo[irq >> IPIPE_IRQ_ISHIFT]); \
+				set_bit(irq >> IPIPE_IRQ_ISHIFT,&(ipd)->cpudata[__cpuid].irq_pending_hi); \
+			} \
+} while(0)
+
+#define __ipipe_clear_irq(ipd,irq) \
+do { \
+	int __cpuid, __nr_cpus = num_online_cpus(); \
+	clear_bit(IPIPE_LOCK_FLAG,&(ipd)->irqs[irq].control); \
+	for (__cpuid = 0; __cpuid < __nr_cpus; __cpuid++) { \
+		(ipd)->cpudata[__cpuid].irq_counters[irq].pending_hits = 0; \
+		__ipipe_clear_pend(ipd,__cpuid,irq); \
+	} \
+} while(0)
+
+#ifdef __RAW_SPIN_LOCK_UNLOCKED
+#define spin_lock_hw(x)		__raw_spin_lock(&(x)->raw_lock)
+#define spin_trylock_hw(x)		__raw_spin_trylock(&(x)->raw_lock)
+#define spin_unlock_hw(x)		__raw_spin_unlock(&(x)->raw_lock)
+#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)
+#define write_lock_hw(x)		__raw_write_lock(&(x)->raw_lock)
+#define write_trylock_hw(x)		__raw_write_trylock(&(x)->raw_lock)
+#define write_unlock_hw(x)		__raw_write_unlock(&(x)->raw_lock)
+#define read_lock_hw(x)		__raw_read_lock(&(x)->raw_lock)
+#define read_trylock_hw(x)		__raw_read_trylock(&(x)->raw_lock)
+#define read_unlock_hw(x)		__raw_read_unlock(&(x)->raw_lock)
+#else /* UP non-debug */
+#define write_lock_hw(lock)		do { (void)(lock); } while (0)
+#define write_trylock_hw(lock)	({ (void)(lock); 1; })
+#define write_unlock_hw(lock)		do { (void)(lock); } while (0)
+#define read_lock_hw(lock)		do { (void)(lock); } while (0)
+#define read_trylock_hw(lock)		({ (void)(lock); 1; })
+#define read_unlock_hw(lock)		do { (void)(lock); } while (0)
+#endif /* CONFIG_SMP || CONFIG_DEBUG_SPINLOCK */
+#else	/* !__RAW_SPIN_LOCK_UNLOCKED */
+#define spin_lock_hw(x)		_raw_spin_lock(x)
+#define spin_unlock_hw(x)		_raw_spin_unlock(x)
+#define spin_trylock_hw(x)		_raw_spin_trylock(x)
+#define write_lock_hw(x)		_raw_write_lock(x)
+#define write_unlock_hw(x)		_raw_write_unlock(x)
+#define write_trylock_hw(x)		_raw_write_trylock(x)
+#define read_lock_hw(x)		_raw_read_lock(x)
+#define read_unlock_hw(x)		_raw_read_unlock(x)
+#endif	/* __RAW_SPIN_LOCK_UNLOCKED */
+
+typedef spinlock_t			ipipe_spinlock_t;
+typedef rwlock_t			ipipe_rwlock_t;
+#define IPIPE_SPIN_LOCK_UNLOCKED	SPIN_LOCK_UNLOCKED
+#define IPIPE_RW_LOCK_UNLOCKED		RW_LOCK_UNLOCKED
+
+#define spin_lock_irqsave_hw(x,flags)		\
+do {						\
+	local_irq_save_hw(flags);		\
+	spin_lock_hw(x);			\
+} while (0)
+
+#define spin_unlock_irqrestore_hw(x,flags)	\
+do {						\
+	spin_unlock_hw(x);			\
+	local_irq_restore_hw(flags);		\
+} while (0)
+
+#define spin_lock_irq_hw(x)			\
+do {						\
+	local_irq_disable_hw();			\
+	spin_lock_hw(x);			\
+} while (0)
+
+#define spin_unlock_irq_hw(x)			\
+do {						\
+	spin_unlock_hw(x);			\
+	local_irq_enable_hw();			\
+} while (0)
+
+#define read_lock_irqsave_hw(lock, flags)	\
+do {						\
+	local_irq_save_hw(flags);		\
+	read_lock_hw(lock);			\
+} while (0)
+
+#define read_unlock_irqrestore_hw(lock, flags)	\
+do {						\
+	read_unlock_hw(lock);			\
+	local_irq_restore_hw(flags);		\
+} while (0)
+
+#define write_lock_irqsave_hw(lock, flags)	\
+do {						\
+	local_irq_save_hw(flags);		\
+	write_lock_hw(lock);			\
+} while (0)
+
+#define write_unlock_irqrestore_hw(lock, flags)	\
+do {						\
+	write_unlock_hw(lock);			\
+	local_irq_restore_hw(flags);		\
+} while (0)
+
+DECLARE_PER_CPU(struct ipipe_domain *, ipipe_percpu_domain);
+
+extern struct ipipe_domain ipipe_root;
+
+#define ipipe_root_domain (&ipipe_root)
+
+extern unsigned __ipipe_printk_virq;
+
+extern unsigned long __ipipe_virtual_irq_map;
+
+extern struct list_head __ipipe_pipeline;
+
+extern ipipe_spinlock_t __ipipe_pipelock;
+
+extern int __ipipe_event_monitors[];
+
+/* Private interface */
+
+void ipipe_init(void);
+
+#ifdef CONFIG_PROC_FS
+void ipipe_init_proc(void);
+
+#ifdef CONFIG_IPIPE_TRACE
+void __ipipe_init_tracer(void);
+#else /* !CONFIG_IPIPE_TRACE */
+#define __ipipe_init_tracer()       do { } while(0)
+#endif /* CONFIG_IPIPE_TRACE */
+
+#else	/* !CONFIG_PROC_FS */
+#define ipipe_init_proc()	do { } while(0)
+#endif	/* CONFIG_PROC_FS */
+
+void __ipipe_init_stage(struct ipipe_domain *ipd);
+
+void __ipipe_cleanup_domain(struct ipipe_domain *ipd);
+
+void __ipipe_add_domain_proc(struct ipipe_domain *ipd);
+
+void __ipipe_remove_domain_proc(struct ipipe_domain *ipd);
+
+void __ipipe_flush_printk(unsigned irq, void *cookie);
+
+void __ipipe_stall_root(void);
+
+void __ipipe_unstall_root(void);
+
+unsigned long __ipipe_test_root(void);
+
+unsigned long __ipipe_test_and_stall_root(void);
+
+void fastcall __ipipe_walk_pipeline(struct list_head *pos, int cpuid);
+
+void fastcall __ipipe_restore_root(unsigned long x);
+
+int fastcall __ipipe_schedule_irq(unsigned irq, struct list_head *head);
+
+int fastcall __ipipe_dispatch_event(unsigned event, void *data);
+
+int fastcall __ipipe_dispatch_wired(struct ipipe_domain *head, unsigned irq);
+
+void fastcall __ipipe_sync_stage(unsigned long syncmask);
+
+#ifndef __ipipe_sync_pipeline
+#define __ipipe_sync_pipeline(syncmask) __ipipe_sync_stage(syncmask)
+#endif
+
+#ifndef __ipipe_run_irqtail
+#define __ipipe_run_irqtail() do { } while(0)
+#endif
+
+#define __ipipe_pipeline_head_p(ipd) (&(ipd)->p_link == __ipipe_pipeline.next)
+
+/*
+ * Keep the following as a macro, so that client code could check for
+ * the support of the invariant pipeline head optimization.
+ */
+#define __ipipe_pipeline_head() list_entry(__ipipe_pipeline.next,struct ipipe_domain,p_link)
+
+#define __ipipe_event_monitored_p(ev) \
+	(__ipipe_event_monitors[ev] > 0 || (ipipe_current_domain->evself & (1LL << ev)))
+
+#ifdef CONFIG_SMP
+
+cpumask_t __ipipe_set_irq_affinity(unsigned irq,
+				   cpumask_t cpumask);
+
+int fastcall __ipipe_send_ipi(unsigned ipi,
+			      cpumask_t cpumask);
+
+#endif /* CONFIG_SMP */
+
+/* Called with hw interrupts off. */
+static inline void __ipipe_switch_to(struct ipipe_domain *out,
+				     struct ipipe_domain *in, int cpuid)
+{
+	void ipipe_suspend_domain(void);
+
+	/*
+	 * "in" is guaranteed to be closer than "out" from the head of the
+	 * pipeline (and obviously different).
+	 */
+
+	out->cpudata[cpuid].evsync = 0;
+	per_cpu(ipipe_percpu_domain, cpuid) = in;
+
+	ipipe_suspend_domain();	/* Sync stage and propagate interrupts. */
+	ipipe_load_cpuid();	/* Processor might have changed. */
+
+	if (per_cpu(ipipe_percpu_domain, cpuid) == in)
+		/*
+		 * Otherwise, something has changed the current domain under
+		 * our feet recycling the register set; do not override.
+		 */
+		per_cpu(ipipe_percpu_domain, cpuid) = out;
+}
+
+#define ipipe_sigwake_notify(p)	\
+do {					\
+	if (((p)->flags & PF_EVNOTIFY) && __ipipe_event_monitored_p(IPIPE_EVENT_SIGWAKE)) \
+		__ipipe_dispatch_event(IPIPE_EVENT_SIGWAKE,p);		\
+} while(0)
+
+#define ipipe_exit_notify(p)	\
+do {				\
+	if (((p)->flags & PF_EVNOTIFY) && __ipipe_event_monitored_p(IPIPE_EVENT_EXIT)) \
+		__ipipe_dispatch_event(IPIPE_EVENT_EXIT,p);		\
+} while(0)
+
+#define ipipe_setsched_notify(p)	\
+do {					\
+	if (((p)->flags & PF_EVNOTIFY) && __ipipe_event_monitored_p(IPIPE_EVENT_SETSCHED)) \
+		__ipipe_dispatch_event(IPIPE_EVENT_SETSCHED,p);		\
+} while(0)
+
+#define ipipe_schedule_notify(prev, next)				\
+do {									\
+	if ((((prev)->flags|(next)->flags) & PF_EVNOTIFY) &&		\
+	    __ipipe_event_monitored_p(IPIPE_EVENT_SCHEDULE))		\
+		__ipipe_dispatch_event(IPIPE_EVENT_SCHEDULE,next);	\
+} while(0)
+
+#define ipipe_trap_notify(ex, regs)		\
+({						\
+	ipipe_declare_cpuid;			\
+	int ret = 0;				\
+	ipipe_load_cpuid();			\
+	if ((test_bit(IPIPE_NOSTACK_FLAG, &ipipe_current_domain->cpudata[cpuid].status) || \
+	     ((current)->flags & PF_EVNOTIFY)) &&			\
+	    __ipipe_event_monitored_p(ex))				\
+		ret = __ipipe_dispatch_event(ex, regs);			\
+	ret;								\
+})
+
+static inline void ipipe_init_notify(struct task_struct *p)
+{
+	if (__ipipe_event_monitored_p(IPIPE_EVENT_INIT))
+		__ipipe_dispatch_event(IPIPE_EVENT_INIT,p);
+}
+
+struct mm_struct;
+
+static inline void ipipe_cleanup_notify(struct mm_struct *mm)
+{
+	if (__ipipe_event_monitored_p(IPIPE_EVENT_CLEANUP))
+		__ipipe_dispatch_event(IPIPE_EVENT_CLEANUP,mm);
+}
+
+/* Public interface */
+
+int ipipe_register_domain(struct ipipe_domain *ipd,
+			  struct ipipe_domain_attr *attr);
+
+int ipipe_unregister_domain(struct ipipe_domain *ipd);
+
+void ipipe_suspend_domain(void);
+
+int ipipe_virtualize_irq(struct ipipe_domain *ipd,
+			 unsigned irq,
+			 ipipe_irq_handler_t handler,
+			 void *cookie,
+			 ipipe_irq_ackfn_t acknowledge,
+			 unsigned modemask);
+
+static inline int ipipe_share_irq(unsigned irq,
+				  ipipe_irq_ackfn_t acknowledge)
+{
+	return ipipe_virtualize_irq(ipipe_current_domain,
+				    irq,
+				    IPIPE_SAME_HANDLER,
+				    NULL,
+				    acknowledge,
+				    IPIPE_SHARED_MASK | IPIPE_HANDLE_MASK |
+				    IPIPE_PASS_MASK);
+}
+
+int ipipe_control_irq(unsigned irq,
+		      unsigned clrmask,
+		      unsigned setmask);
+
+unsigned ipipe_alloc_virq(void);
+
+int ipipe_free_virq(unsigned virq);
+
+int fastcall ipipe_trigger_irq(unsigned irq);
+
+static inline int ipipe_propagate_irq(unsigned irq)
+{
+	return __ipipe_schedule_irq(irq, ipipe_current_domain->p_link.next);
+}
+
+static inline int ipipe_schedule_irq(unsigned irq)
+{
+	return __ipipe_schedule_irq(irq, &ipipe_current_domain->p_link);
+}
+
+void fastcall ipipe_stall_pipeline_from(struct ipipe_domain *ipd);
+
+unsigned long fastcall ipipe_test_and_stall_pipeline_from(struct ipipe_domain *ipd);
+
+void fastcall ipipe_unstall_pipeline_from(struct ipipe_domain *ipd);
+
+unsigned long fastcall ipipe_test_and_unstall_pipeline_from(struct ipipe_domain *ipd);
+
+void fastcall ipipe_restore_pipeline_from(struct ipipe_domain *ipd,
+					  unsigned long x);
+
+static inline unsigned long ipipe_test_pipeline_from(struct ipipe_domain *ipd)
+{
+	unsigned long flags, x;
+	ipipe_declare_cpuid;
+
+	ipipe_get_cpu(flags);
+	x = test_bit(IPIPE_STALL_FLAG, &ipd->cpudata[cpuid].status);
+	ipipe_put_cpu(flags);
+
+	return x;
+}
+
+static inline void ipipe_restore_pipeline_nosync(struct ipipe_domain *ipd,
+						 unsigned long x, int cpuid)
+{
+	/*
+	 * If cpuid is current, then it must be held on entry
+	 * (ipipe_get_cpu/local_irq_save_hw/local_irq_disable_hw).
+	 */
+
+	if (x)
+		__set_bit(IPIPE_STALL_FLAG, &ipd->cpudata[cpuid].status);
+	else
+		__clear_bit(IPIPE_STALL_FLAG, &ipd->cpudata[cpuid].status);
+}
+
+static inline void ipipe_stall_pipeline_head(void)
+{
+	ipipe_declare_cpuid;
+	unsigned long flags;
+
+	ipipe_lock_cpu(flags);
+	__set_bit(IPIPE_STALL_FLAG, &__ipipe_pipeline_head()->cpudata[cpuid].status);
+}
+
+static inline unsigned long ipipe_test_and_stall_pipeline_head(void)
+{
+	unsigned long flags;
+	ipipe_declare_cpuid;
+
+	ipipe_lock_cpu(flags);
+	return __test_and_set_bit(IPIPE_STALL_FLAG, &__ipipe_pipeline_head()->cpudata[cpuid].status);
+}
+
+void ipipe_unstall_pipeline_head(void);
+
+void fastcall __ipipe_restore_pipeline_head(struct ipipe_domain *head,
+					    unsigned long x);
+
+static inline void ipipe_restore_pipeline_head(unsigned long x)
+{
+	struct ipipe_domain *head = __ipipe_pipeline_head();
+	/* On some archs, __test_and_set_bit() might return different
+	 * truth value than test_bit(), so we test the exclusive OR of
+	 * both statuses, assuming that the lowest bit is always set in
+	 * the truth value (if this is wrong, the failed optimization will
+	 * be caught in __ipipe_restore_pipeline_head() if
+	 * CONFIG_DEBUG_KERNEL is set). */
+	if ((x ^ test_bit(IPIPE_STALL_FLAG, &head->cpudata[ipipe_processor_id()].status)) & 1)
+		__ipipe_restore_pipeline_head(head,x);
+}
+
+#define ipipe_unstall_pipeline() \
+	ipipe_unstall_pipeline_from(ipipe_current_domain)
+
+#define ipipe_test_and_unstall_pipeline() \
+	ipipe_test_and_unstall_pipeline_from(ipipe_current_domain)
+
+#define ipipe_test_pipeline() \
+	ipipe_test_pipeline_from(ipipe_current_domain)
+
+#define ipipe_test_and_stall_pipeline() \
+	ipipe_test_and_stall_pipeline_from(ipipe_current_domain)
+
+#define ipipe_stall_pipeline() \
+	ipipe_stall_pipeline_from(ipipe_current_domain)
+
+#define ipipe_restore_pipeline(x) \
+	ipipe_restore_pipeline_from(ipipe_current_domain, (x))
+
+void ipipe_init_attr(struct ipipe_domain_attr *attr);
+
+int ipipe_get_sysinfo(struct ipipe_sysinfo *sysinfo);
+
+int ipipe_tune_timer(unsigned long ns,
+		     int flags);
+
+unsigned long ipipe_critical_enter(void (*syncfn) (void));
+
+void ipipe_critical_exit(unsigned long flags);
+
+static inline void ipipe_set_printk_sync(struct ipipe_domain *ipd)
+{
+	set_bit(IPIPE_SPRINTK_FLAG, &ipd->flags);
+}
+
+static inline void ipipe_set_printk_async(struct ipipe_domain *ipd)
+{
+	clear_bit(IPIPE_SPRINTK_FLAG, &ipd->flags);
+}
+
+static inline void ipipe_set_foreign_stack(struct ipipe_domain *ipd)
+{
+	/* Must be called hw interrupts off. */
+	ipipe_declare_cpuid;
+	ipipe_load_cpuid();
+	__set_bit(IPIPE_NOSTACK_FLAG, &ipd->cpudata[cpuid].status);
+}
+
+static inline void ipipe_clear_foreign_stack(struct ipipe_domain *ipd)
+{
+	/* Must be called hw interrupts off. */
+	ipipe_declare_cpuid;
+	ipipe_load_cpuid();
+	__clear_bit(IPIPE_NOSTACK_FLAG, &ipd->cpudata[cpuid].status);
+}
+
+#define ipipe_safe_current()					\
+({								\
+	ipipe_declare_cpuid;					\
+	struct task_struct *p;					\
+	ipipe_load_cpuid();					\
+	p = test_bit(IPIPE_NOSTACK_FLAG,			\
+		     &per_cpu(ipipe_percpu_domain, cpuid)->cpudata[cpuid].status) ? &init_task : current; \
+	p; \
+})
+
+ipipe_event_handler_t ipipe_catch_event(struct ipipe_domain *ipd,
+					unsigned event,
+					ipipe_event_handler_t handler);
+
+cpumask_t ipipe_set_irq_affinity(unsigned irq,
+				 cpumask_t cpumask);
+
+int fastcall ipipe_send_ipi(unsigned ipi,
+			    cpumask_t cpumask);
+
+int ipipe_setscheduler_root(struct task_struct *p,
+			    int policy,
+			    int prio);
+
+int ipipe_reenter_root(struct task_struct *prev,
+		       int policy,
+		       int prio);
+
+int ipipe_alloc_ptdkey(void);
+
+int ipipe_free_ptdkey(int key);
+
+int fastcall ipipe_set_ptd(int key,
+			   void *value);
+
+void fastcall *ipipe_get_ptd(int key);
+
+#define local_irq_enable_hw_cond()		local_irq_enable_hw()
+#define local_irq_disable_hw_cond()		local_irq_disable_hw()
+#define local_irq_save_hw_cond(flags)	local_irq_save_hw(flags)
+#define local_irq_restore_hw_cond(flags)	local_irq_restore_hw(flags)
+
+#define local_irq_enable_nohead(ipd)			\
+	do {						\
+		if (!__ipipe_pipeline_head_p(ipd))	\
+			local_irq_enable_hw();		\
+	} while(0)
+
+#define local_irq_disable_nohead(ipd)		\
+	do {						\
+		if (!__ipipe_pipeline_head_p(ipd))	\
+			local_irq_disable_hw();		\
+	} while(0)
+
+#define spin_lock_irqsave_hw_cond(lock,flags)	spin_lock_irqsave_hw(lock,flags)
+#define spin_unlock_irqrestore_hw_cond(lock,flags)	spin_unlock_irqrestore_hw(lock,flags)
+#define smp_processor_id_hw()				ipipe_processor_id()
+
+#define ipipe_irq_lock(irq)						\
+	do {								\
+		ipipe_declare_cpuid;					\
+		ipipe_load_cpuid();					\
+		__ipipe_lock_irq(per_cpu(ipipe_percpu_domain, cpuid), cpuid, irq);\
+	} while(0)
+
+#define ipipe_irq_unlock(irq)						\
+	do {								\
+		ipipe_declare_cpuid;					\
+		ipipe_load_cpuid();					\
+		__ipipe_unlock_irq(per_cpu(ipipe_percpu_domain, cpuid), irq);	\
+	} while(0)
+
+#define ipipe_root_domain_p		(ipipe_current_domain == ipipe_root_domain)
+
+#else	/* !CONFIG_IPIPE */
+
+#define ipipe_init()			do { } while(0)
+#define ipipe_suspend_domain()	do { } while(0)
+#define ipipe_sigwake_notify(p)	do { } while(0)
+#define ipipe_setsched_notify(p)	do { } while(0)
+#define ipipe_init_notify(p)		do { } while(0)
+#define ipipe_exit_notify(p)		do { } while(0)
+#define ipipe_cleanup_notify(mm)	do { } while(0)
+#define ipipe_trap_notify(t,r)	0
+#define ipipe_init_proc()		do { } while(0)
+
+#define spin_lock_hw(lock)			spin_lock(lock)
+#define spin_unlock_hw(lock)			spin_unlock(lock)
+#define spin_lock_irq_hw(lock)		spin_lock_irq(lock)
+#define spin_unlock_irq_hw(lock)		spin_unlock_irq(lock)
+#define spin_lock_irqsave_hw(lock,flags)	spin_lock_irqsave(lock, flags)
+#define spin_unlock_irqrestore_hw(lock,flags)	spin_unlock_irqrestore(lock, flags)
+
+#define local_irq_enable_hw_cond()		do { } while(0)
+#define local_irq_disable_hw_cond()		do { } while(0)
+#define local_irq_save_hw_cond(flags)	do { (void)(flags); } while(0)
+#define local_irq_restore_hw_cond(flags)	do { } while(0)
+#define spin_lock_irqsave_hw_cond(lock,flags)	do { (void)(flags); spin_lock(lock); } while(0)
+#define spin_unlock_irqrestore_hw_cond(lock,flags)	spin_unlock(lock)
+#define smp_processor_id_hw()			smp_processor_id()
+
+#define ipipe_irq_lock(irq)		do { } while(0)
+#define ipipe_irq_unlock(irq)		do { } while(0)
+
+#define ipipe_root_domain_p		1
+#define ipipe_safe_current		current
+
+#endif	/* CONFIG_IPIPE */
+
+#endif	/* !__LINUX_IPIPE_H */
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/linux/ipipe_trace.h ipipe-2.6.14-imx21/include/linux/ipipe_trace.h
--- linux-2.6.14/include/linux/ipipe_trace.h	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/include/linux/ipipe_trace.h	2008-02-21 22:09:00.000000000 +0100
@@ -0,0 +1,40 @@
+/* -*- linux-c -*-
+ * include/linux/ipipe_trace.h
+ *
+ * Copyright (C) 2005 Luotao Fu.
+ *               2005, 2006 Jan Kiszka.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge MA 02139,
+ * USA; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _LINUX_IPIPE_TRACE_H
+#define _LINUX_IPIPE_TRACE_H
+
+#include <linux/types.h>
+
+void ipipe_trace_begin(unsigned long v);
+void ipipe_trace_end(unsigned long v);
+void ipipe_trace_freeze(unsigned long v);
+void ipipe_trace_special(unsigned char special_id, unsigned long v);
+void ipipe_trace_pid(pid_t pid, short prio);
+
+int ipipe_trace_max_reset(void);
+int ipipe_trace_frozen_reset(void);
+
+void ipipe_trace_panic_freeze(void);
+void ipipe_trace_panic_dump(void);
+
+#endif	/* !__LINUX_IPIPE_H */
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/linux/linkage.h ipipe-2.6.14-imx21/include/linux/linkage.h
--- linux-2.6.14/include/linux/linkage.h	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/linux/linkage.h	2008-02-21 22:09:00.000000000 +0100
@@ -51,4 +51,8 @@
 #define fastcall
 #endif
 
+#ifndef notrace
+#define notrace		__attribute__((no_instrument_function))
+#endif
+
 #endif
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/linux/preempt.h ipipe-2.6.14-imx21/include/linux/preempt.h
--- linux-2.6.14/include/linux/preempt.h	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/linux/preempt.h	2008-02-21 22:09:00.000000000 +0100
@@ -13,41 +13,57 @@
   extern void fastcall add_preempt_count(int val);
   extern void fastcall sub_preempt_count(int val);
 #else
-# define add_preempt_count(val)	do { preempt_count() += (val); } while (0)
-# define sub_preempt_count(val)	do { preempt_count() -= (val); } while (0)
+#define add_preempt_count(val)	do { preempt_count() += (val); } while (0)
+#define sub_preempt_count(val)	do { preempt_count() -= (val); } while (0)
 #endif
 
-#define inc_preempt_count() add_preempt_count(1)
-#define dec_preempt_count() sub_preempt_count(1)
+#define inc_preempt_count()	add_preempt_count(1)
+#define dec_preempt_count()	sub_preempt_count(1)
 
-#define preempt_count()	(current_thread_info()->preempt_count)
+#define preempt_count()		(current_thread_info()->preempt_count)
 
 #ifdef CONFIG_PREEMPT
 
 asmlinkage void preempt_schedule(void);
 
-#define preempt_disable() \
-do { \
-	inc_preempt_count(); \
-	barrier(); \
+#ifdef CONFIG_IPIPE
+
+#include <asm/ipipe.h>
+DECLARE_PER_CPU(struct ipipe_domain *, ipipe_percpu_domain);
+extern struct ipipe_domain ipipe_root;
+#define ipipe_preempt_guard()	(per_cpu(ipipe_percpu_domain, ipipe_processor_id()) == &ipipe_root)
+#else
+#define ipipe_preempt_guard()	1
+#endif
+
+#define preempt_disable()						\
+do {									\
+	if (ipipe_preempt_guard()) {					\
+		inc_preempt_count();					\
+		barrier();						\
+	}								\
 } while (0)
 
-#define preempt_enable_no_resched() \
-do { \
-	barrier(); \
-	dec_preempt_count(); \
+#define preempt_enable_no_resched()					\
+do {									\
+	if (ipipe_preempt_guard()) {					\
+		barrier();						\
+		dec_preempt_count();					\
+	}								\
 } while (0)
 
-#define preempt_check_resched() \
-do { \
-	if (unlikely(test_thread_flag(TIF_NEED_RESCHED))) \
-		preempt_schedule(); \
+#define preempt_check_resched()						\
+do {									\
+	if (ipipe_preempt_guard()) {					\
+		if (unlikely(test_thread_flag(TIF_NEED_RESCHED)))	\
+			preempt_schedule();				\
+	}								\
 } while (0)
 
-#define preempt_enable() \
-do { \
-	preempt_enable_no_resched(); \
-	preempt_check_resched(); \
+#define preempt_enable()						\
+do {									\
+	preempt_enable_no_resched();					\
+	preempt_check_resched();					\
 } while (0)
 
 #else
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/include/linux/sched.h ipipe-2.6.14-imx21/include/linux/sched.h
--- linux-2.6.14/include/linux/sched.h	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/linux/sched.h	2008-02-21 22:09:00.000000000 +0100
@@ -4,6 +4,7 @@
 #include <asm/param.h>	/* for HZ */
 
 #include <linux/config.h>
+#include <linux/ipipe.h>
 #include <linux/capability.h>
 #include <linux/threads.h>
 #include <linux/kernel.h>
@@ -127,6 +128,13 @@ extern unsigned long nr_iowait(void);
 #define EXIT_DEAD		32
 /* in tsk->state again */
 #define TASK_NONINTERACTIVE	64
+#ifdef CONFIG_IPIPE
+#define TASK_ATOMICSWITCH	512
+#define TASK_NOWAKEUP          1024
+#else  /* !CONFIG_IPIPE */
+#define TASK_ATOMICSWITCH	0
+#define TASK_NOWAKEUP          0
+#endif /* CONFIG_IPIPE */
 
 #define __set_task_state(tsk, state_value)		\
 	do { (tsk)->state = (state_value); } while (0)
@@ -813,6 +821,9 @@ struct task_struct {
 	int cpuset_mems_generation;
 #endif
 	atomic_t fs_excl;	/* holding fs exclusive resources */
+#ifdef CONFIG_IPIPE
+        void *ptd[IPIPE_ROOT_NPTDKEYS];
+#endif
 };
 
 static inline pid_t process_group(struct task_struct *tsk)
@@ -864,6 +875,11 @@ do { if (atomic_dec_and_test(&(tsk)->usa
 #define PF_SYNCWRITE	0x00200000	/* I am doing a sync write */
 #define PF_BORROWED_MM	0x00400000	/* I am a kthread doing use_mm */
 #define PF_RANDOMIZE	0x00800000	/* randomize virtual address space */
+#ifdef CONFIG_IPIPE
+#define PF_EVNOTIFY    0x40000000	/* Notify other domains about internal events */
+#else
+#define PF_EVNOTIFY    0
+#endif /* CONFIG_IPIPE */
 
 /*
  * Only the _current_ task can read/write to tsk->flags, but other
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/init/Kconfig ipipe-2.6.14-imx21/init/Kconfig
--- linux-2.6.14/init/Kconfig	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/init/Kconfig	2008-02-21 22:09:03.000000000 +0100
@@ -69,6 +69,7 @@ menu "General setup"
 
 config LOCALVERSION
 	string "Local version - append to kernel release"
+	default "-ipipe"
 	help
 	  Append an extra string to the end of your kernel version.
 	  This will show up when you type uname, for example.
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/init/main.c ipipe-2.6.14-imx21/init/main.c
--- linux-2.6.14/init/main.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/init/main.c	2008-02-21 22:09:03.000000000 +0100
@@ -487,6 +487,11 @@ asmlinkage void __init start_kernel(void
 	init_timers();
 	softirq_init();
 	time_init();
+	/*
+	 * We need to wait for the interrupt and time subsystems to be
+	 * initialized before enabling the pipeline.
+	 */
+ 	ipipe_init();
 
 	/*
 	 * HACK ALERT! This is early. We're enabling the console before
@@ -611,6 +616,7 @@ static void __init do_basic_setup(void)
 #ifdef CONFIG_SYSCTL
 	sysctl_init();
 #endif
+	ipipe_init_proc();
 
 	/* Networking initialization needs a process context */ 
 	sock_init();
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/kernel/Makefile ipipe-2.6.14-imx21/kernel/Makefile
--- linux-2.6.14/kernel/Makefile	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/kernel/Makefile	2008-02-21 22:09:03.000000000 +0100
@@ -32,6 +32,7 @@ obj-$(CONFIG_DETECT_SOFTLOCKUP) += softl
 obj-$(CONFIG_GENERIC_HARDIRQS) += irq/
 obj-$(CONFIG_CRASH_DUMP) += crash_dump.o
 obj-$(CONFIG_SECCOMP) += seccomp.o
+obj-$(CONFIG_IPIPE) += ipipe/
 
 ifneq ($(CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/kernel/exit.c ipipe-2.6.14-imx21/kernel/exit.c
--- linux-2.6.14/kernel/exit.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/kernel/exit.c	2008-02-21 22:09:03.000000000 +0100
@@ -846,6 +846,7 @@ fastcall NORET_TYPE void do_exit(long co
 		exit_itimers(tsk->signal);
 		acct_process(code);
 	}
+ 	ipipe_exit_notify(tsk);
 	exit_mm(tsk);
 
 	exit_sem(tsk);
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/kernel/fork.c ipipe-2.6.14-imx21/kernel/fork.c
--- linux-2.6.14/kernel/fork.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/kernel/fork.c	2008-02-21 22:09:03.000000000 +0100
@@ -372,6 +372,7 @@ void fastcall __mmdrop(struct mm_struct 
 void mmput(struct mm_struct *mm)
 {
 	if (atomic_dec_and_test(&mm->mm_users)) {
+		ipipe_cleanup_notify(mm);
 		exit_aio(mm);
 		exit_mmap(mm);
 		if (!list_empty(&mm->mmlist)) {
@@ -848,7 +849,7 @@ static inline void copy_flags(unsigned l
 {
 	unsigned long new_flags = p->flags;
 
-	new_flags &= ~(PF_SUPERPRIV | PF_NOFREEZE);
+	new_flags &= ~(PF_SUPERPRIV | PF_NOFREEZE | PF_EVNOTIFY);
 	new_flags |= PF_FORKNOEXEC;
 	if (!(clone_flags & CLONE_PTRACE))
 		p->ptrace = 0;
@@ -1153,6 +1154,14 @@ static task_t *copy_process(unsigned lon
 	total_forks++;
 	write_unlock_irq(&tasklist_lock);
 	retval = 0;
+#ifdef CONFIG_IPIPE
+	{
+	int k;
+
+	for (k = 0; k < IPIPE_ROOT_NPTDKEYS; k++)
+	    p->ptd[k] = NULL;
+	}
+#endif /* CONFIG_IPIPE */
 
 fork_out:
 	if (retval)
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/kernel/ipipe/Kconfig ipipe-2.6.14-imx21/kernel/ipipe/Kconfig
--- linux-2.6.14/kernel/ipipe/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/kernel/ipipe/Kconfig	2008-02-21 22:09:03.000000000 +0100
@@ -0,0 +1,6 @@
+config IPIPE
+	bool "Interrupt pipeline"
+	default y
+	---help---
+	  Activate this option if you want the interrupt pipeline to be
+	  compiled in.
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/kernel/ipipe/Kconfig.debug ipipe-2.6.14-imx21/kernel/ipipe/Kconfig.debug
--- linux-2.6.14/kernel/ipipe/Kconfig.debug	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/kernel/ipipe/Kconfig.debug	2008-02-21 22:09:03.000000000 +0100
@@ -0,0 +1,69 @@
+config IPIPE_DEBUG
+	bool "I-pipe debugging"
+	depends on IPIPE
+
+config IPIPE_TRACE
+	bool "Latency tracing"
+	depends on IPIPE_DEBUG
+	select FRAME_POINTER
+	select KALLSYMS
+	select PROC_FS
+	---help---
+	  Activate this option if you want to use per-function tracing of
+	  the kernel. The tracer will collect data via instrumentation
+	  features like the one below or with the help of explicite calls
+	  of ipipe_trace_xxx(). See include/linux/ipipe_trace.h for the
+	  in-kernel tracing API. The collected data and runtime control
+	  is available via /proc/ipipe/trace/*.
+
+config IPIPE_TRACE_ENABLE
+	bool "Enable tracing on boot"
+	depends on IPIPE_TRACE
+	default y
+	---help---
+	  Disable this option if you want to arm the tracer after booting
+	  manually ("echo 1 > /proc/ipipe/tracer/enable"). This can reduce
+	  boot time on slow embedded devices due to the tracer overhead.
+
+config IPIPE_TRACE_MCOUNT
+	bool "Instrument function entries"
+	depends on IPIPE_TRACE
+	default y
+	---help---
+	  When enabled, records every kernel function entry in the tracer
+	  log. While this slows down the system noticeably, it provides
+	  the highest level of information about the flow of events.
+	  However, it can be switch off in order to record only explicit
+	  I-pipe trace points.
+
+config IPIPE_TRACE_IRQSOFF
+	bool "Trace IRQs-off times"
+	depends on IPIPE_TRACE
+	default y
+	---help---
+	  Activate this option if I-pipe shall trace the longest path
+	  with hard-IRQs switched off.
+
+config IPIPE_TRACE_SHIFT
+	int "Depth of trace log (14 => 16Kpoints, 15 => 32Kpoints)"
+	range 10 18
+	default 14
+	depends on IPIPE_TRACE
+	---help---
+	  The number of trace points to hold tracing data for each
+	  trace path, as a power of 2.
+
+config IPIPE_TRACE_VMALLOC
+	bool "Use vmalloc'ed trace buffer"
+	depends on IPIPE_TRACE
+	---help---
+	  Instead of reserving static kernel data, the required buffer
+	  is allocated via vmalloc during boot-up when this option is
+	  enabled. This can help to start systems that are low on memory,
+	  but it slightly degrades overall performance. Try this option
+	  when a traced kernel hangs unexpectedly at boot time.
+
+config IPIPE_TRACE_ENABLE_VALUE
+	int
+	default 0 if !IPIPE_TRACE_ENABLE
+	default 1 if IPIPE_TRACE_ENABLE
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/kernel/ipipe/Makefile ipipe-2.6.14-imx21/kernel/ipipe/Makefile
--- linux-2.6.14/kernel/ipipe/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/kernel/ipipe/Makefile	2008-02-21 22:09:03.000000000 +0100
@@ -0,0 +1,3 @@
+
+obj-$(CONFIG_IPIPE)	+= core.o generic.o
+obj-$(CONFIG_IPIPE_TRACE) += tracer.o
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/kernel/ipipe/core.c ipipe-2.6.14-imx21/kernel/ipipe/core.c
--- linux-2.6.14/kernel/ipipe/core.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/kernel/ipipe/core.c	2008-02-21 22:09:03.000000000 +0100
@@ -0,0 +1,1051 @@
+/* -*- linux-c -*-
+ * linux/kernel/ipipe/core.c
+ *
+ * Copyright (C) 2002-2005 Philippe Gerum.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge MA 02139,
+ * USA; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Architecture-independent I-PIPE core support.
+ */
+
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/kallsyms.h>
+#include <linux/interrupt.h>
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#endif	/* CONFIG_PROC_FS */
+
+struct ipipe_domain ipipe_root =
+	{ .cpudata = {[0 ... IPIPE_NR_CPUS-1] =
+		{ .status = (1<<IPIPE_STALL_FLAG) } } };
+
+DEFINE_PER_CPU(struct ipipe_domain *, ipipe_percpu_domain) =
+	{ &ipipe_root };
+
+ipipe_spinlock_t __ipipe_pipelock = IPIPE_SPIN_LOCK_UNLOCKED;
+
+LIST_HEAD(__ipipe_pipeline);
+
+unsigned long __ipipe_virtual_irq_map;
+
+#ifdef CONFIG_PRINTK
+unsigned __ipipe_printk_virq;
+#endif /* CONFIG_PRINTK */
+
+int __ipipe_event_monitors[IPIPE_NR_EVENTS];
+
+/*
+ * ipipe_init() -- Initialization routine of the IPIPE layer. Called
+ * by the host kernel early during the boot procedure.
+ */
+void ipipe_init(void)
+{
+	struct ipipe_domain *ipd = &ipipe_root;
+
+	__ipipe_check_platform();	/* Do platform dependent checks first. */
+
+	/*
+	 * A lightweight registration code for the root domain. We are
+	 * running on the boot CPU, hw interrupts are off, and
+	 * secondary CPUs are still lost in space.
+	 */
+
+	ipd->name = "Linux";
+	ipd->domid = IPIPE_ROOT_ID;
+	ipd->priority = IPIPE_ROOT_PRIO;
+
+	__ipipe_init_stage(ipd);
+
+	INIT_LIST_HEAD(&ipd->p_link);
+	list_add_tail(&ipd->p_link, &__ipipe_pipeline);
+
+	__ipipe_init_platform();
+
+#ifdef CONFIG_PRINTK
+	__ipipe_printk_virq = ipipe_alloc_virq();	/* Cannot fail here. */
+	ipd->irqs[__ipipe_printk_virq].handler = &__ipipe_flush_printk;
+	ipd->irqs[__ipipe_printk_virq].cookie = NULL;
+	ipd->irqs[__ipipe_printk_virq].acknowledge = NULL;
+	ipd->irqs[__ipipe_printk_virq].control = IPIPE_HANDLE_MASK;
+#endif /* CONFIG_PRINTK */
+
+	__ipipe_enable_pipeline();
+
+	printk(KERN_INFO "I-pipe %s: pipeline enabled.\n",
+	       IPIPE_VERSION_STRING);
+}
+
+void __ipipe_init_stage(struct ipipe_domain *ipd)
+{
+	int cpuid, n;
+
+	for (cpuid = 0; cpuid < IPIPE_NR_CPUS; cpuid++) {
+		ipd->cpudata[cpuid].irq_pending_hi = 0;
+
+		for (n = 0; n < IPIPE_IRQ_IWORDS; n++)
+			ipd->cpudata[cpuid].irq_pending_lo[n] = 0;
+
+		for (n = 0; n < IPIPE_NR_IRQS; n++) {
+			ipd->cpudata[cpuid].irq_counters[n].total_hits = 0;
+			ipd->cpudata[cpuid].irq_counters[n].pending_hits = 0;
+		}
+
+		ipd->cpudata[cpuid].evsync = 0;
+	}
+
+	for (n = 0; n < IPIPE_NR_IRQS; n++) {
+		ipd->irqs[n].acknowledge = NULL;
+		ipd->irqs[n].handler = NULL;
+		ipd->irqs[n].control = IPIPE_PASS_MASK;	/* Pass but don't handle */
+	}
+
+	for (n = 0; n < IPIPE_NR_EVENTS; n++)
+		ipd->evhand[n] = NULL;
+
+	ipd->evself = 0LL;
+
+#ifdef CONFIG_SMP
+	ipd->irqs[IPIPE_CRITICAL_IPI].acknowledge = &__ipipe_ack_system_irq;
+	ipd->irqs[IPIPE_CRITICAL_IPI].handler = &__ipipe_do_critical_sync;
+	ipd->irqs[IPIPE_CRITICAL_IPI].cookie = NULL;
+	/* Immediately handle in the current domain but *never* pass */
+	ipd->irqs[IPIPE_CRITICAL_IPI].control =
+		IPIPE_HANDLE_MASK|IPIPE_STICKY_MASK|IPIPE_SYSTEM_MASK;
+#endif	/* CONFIG_SMP */
+}
+
+void __ipipe_stall_root(void)
+{
+	ipipe_declare_cpuid;
+	unsigned long flags;
+
+	ipipe_get_cpu(flags); /* Care for migration. */
+	set_bit(IPIPE_STALL_FLAG, &ipipe_root_domain->cpudata[cpuid].status);
+	ipipe_put_cpu(flags);
+}
+
+void __ipipe_cleanup_domain(struct ipipe_domain *ipd)
+{
+	ipipe_unstall_pipeline_from(ipd);
+
+#ifdef CONFIG_SMP
+	{
+		int cpu;
+
+		for_each_online_cpu(cpu) {
+			while (ipd->cpudata[cpu].irq_pending_hi != 0)
+				cpu_relax();
+		}
+	}
+#endif	/* CONFIG_SMP */
+}
+
+void __ipipe_unstall_root(void)
+{
+	ipipe_declare_cpuid;
+
+	local_irq_disable_hw();
+
+	ipipe_load_cpuid();
+
+	__clear_bit(IPIPE_STALL_FLAG, &ipipe_root_domain->cpudata[cpuid].status);
+
+	if (unlikely(ipipe_root_domain->cpudata[cpuid].irq_pending_hi != 0))
+		__ipipe_sync_pipeline(IPIPE_IRQMASK_ANY);
+
+	local_irq_enable_hw();
+}
+
+unsigned long __ipipe_test_root(void)
+{
+	unsigned long flags, x;
+	ipipe_declare_cpuid;
+
+	ipipe_get_cpu(flags); /* Care for migration. */
+	x = test_bit(IPIPE_STALL_FLAG, &ipipe_root_domain->cpudata[cpuid].status);
+	ipipe_put_cpu(flags);
+
+	return x;
+}
+
+unsigned long __ipipe_test_and_stall_root(void)
+{
+	unsigned long flags, x;
+	ipipe_declare_cpuid;
+
+	ipipe_get_cpu(flags); /* Care for migration. */
+	x = test_and_set_bit(IPIPE_STALL_FLAG,
+			     &ipipe_root_domain->cpudata[cpuid].status);
+	ipipe_put_cpu(flags);
+
+	return x;
+}
+
+void fastcall __ipipe_restore_root(unsigned long x)
+{
+	if (x)
+		__ipipe_stall_root();
+	else
+		__ipipe_unstall_root();
+}
+
+void fastcall ipipe_stall_pipeline_from(struct ipipe_domain *ipd)
+{
+	ipipe_declare_cpuid;
+#ifdef CONFIG_SMP
+	unsigned long flags;
+
+	ipipe_lock_cpu(flags); /* Care for migration. */
+
+	__set_bit(IPIPE_STALL_FLAG, &ipd->cpudata[cpuid].status);
+
+	if (!__ipipe_pipeline_head_p(ipd))
+		ipipe_unlock_cpu(flags);
+#else	/* CONFIG_SMP */
+	set_bit(IPIPE_STALL_FLAG, &ipd->cpudata[cpuid].status);
+
+	if (__ipipe_pipeline_head_p(ipd))
+		local_irq_disable_hw();
+#endif	/* CONFIG_SMP */
+}
+
+unsigned long fastcall ipipe_test_and_stall_pipeline_from(struct ipipe_domain *ipd)
+{
+	ipipe_declare_cpuid;
+	unsigned long s;
+#ifdef CONFIG_SMP
+	unsigned long flags;
+
+	ipipe_lock_cpu(flags); /* Care for migration. */
+
+	s = __test_and_set_bit(IPIPE_STALL_FLAG, &ipd->cpudata[cpuid].status);
+
+	if (!__ipipe_pipeline_head_p(ipd))
+		ipipe_unlock_cpu(flags);
+#else	/* CONFIG_SMP */
+	s = test_and_set_bit(IPIPE_STALL_FLAG, &ipd->cpudata[cpuid].status);
+
+	if (__ipipe_pipeline_head_p(ipd))
+		local_irq_disable_hw();
+#endif	/* CONFIG_SMP */
+
+	return s;
+}
+
+/*
+ * ipipe_unstall_pipeline_from() -- Unstall the pipeline and
+ * synchronize pending interrupts for a given domain. See
+ * __ipipe_walk_pipeline() for more information.
+ */
+void fastcall ipipe_unstall_pipeline_from(struct ipipe_domain *ipd)
+{
+	struct list_head *pos;
+	unsigned long flags;
+	ipipe_declare_cpuid;
+
+	ipipe_lock_cpu(flags);
+
+	__clear_bit(IPIPE_STALL_FLAG, &ipd->cpudata[cpuid].status);
+
+	if (ipd == per_cpu(ipipe_percpu_domain, cpuid))
+		pos = &ipd->p_link;
+	else
+		pos = __ipipe_pipeline.next;
+
+	__ipipe_walk_pipeline(pos, cpuid);
+
+	if (__ipipe_pipeline_head_p(ipd))
+		local_irq_enable_hw();
+	else
+		ipipe_unlock_cpu(flags);
+}
+
+unsigned long fastcall ipipe_test_and_unstall_pipeline_from(struct ipipe_domain *ipd)
+{
+	unsigned long flags, x;
+	ipipe_declare_cpuid;
+
+	ipipe_get_cpu(flags);
+	x = test_bit(IPIPE_STALL_FLAG, &ipd->cpudata[cpuid].status);
+	ipipe_unstall_pipeline_from(ipd);
+	ipipe_put_cpu(flags);
+
+	return x;
+}
+
+void fastcall ipipe_restore_pipeline_from(struct ipipe_domain *ipd,
+					  unsigned long x)
+{
+	if (x)
+		ipipe_stall_pipeline_from(ipd);
+	else
+		ipipe_unstall_pipeline_from(ipd);
+}
+
+void ipipe_unstall_pipeline_head(void)
+{
+	struct ipipe_domain *head;
+	unsigned long flags;
+	ipipe_declare_cpuid;
+
+	ipipe_lock_cpu(flags);
+	head = __ipipe_pipeline_head();
+	__clear_bit(IPIPE_STALL_FLAG, &head->cpudata[cpuid].status);
+
+	if (unlikely(head->cpudata[cpuid].irq_pending_hi != 0)) {
+		if (likely(head == per_cpu(ipipe_percpu_domain, cpuid)))
+			__ipipe_sync_pipeline(IPIPE_IRQMASK_ANY);
+		else
+			__ipipe_walk_pipeline(&head->p_link, cpuid);
+        }
+
+	local_irq_enable_hw();
+}
+
+void fastcall __ipipe_restore_pipeline_head(struct ipipe_domain *head, unsigned long x)
+{
+	ipipe_declare_cpuid;
+	unsigned long flags;
+
+	ipipe_lock_cpu(flags);
+
+	if (x) {
+#ifdef CONFIG_DEBUG_KERNEL
+		static int warned;
+		if (!warned && test_and_set_bit(IPIPE_STALL_FLAG, &head->cpudata[cpuid].status)) {
+			/*
+			 * Already stalled albeit ipipe_restore_pipeline_head()
+			 * should have detected it? Send a warning once.\n");
+			 */
+			warned = 1;
+			printk(KERN_WARNING
+				   "I-pipe: ipipe_restore_pipeline_head() optimization failed.\n");
+			dump_stack();
+		}
+#else /* !CONFIG_DEBUG_KERNEL */
+		set_bit(IPIPE_STALL_FLAG, &head->cpudata[cpuid].status);
+#endif /* CONFIG_DEBUG_KERNEL */
+	}
+	else {
+		__clear_bit(IPIPE_STALL_FLAG, &head->cpudata[cpuid].status);
+		if (unlikely(head->cpudata[cpuid].irq_pending_hi != 0)) {
+			if (likely(head == per_cpu(ipipe_percpu_domain, cpuid)))
+				__ipipe_sync_pipeline(IPIPE_IRQMASK_ANY);
+			else
+				__ipipe_walk_pipeline(&head->p_link, cpuid);
+		}
+		local_irq_enable_hw();
+	}
+}
+
+/* __ipipe_walk_pipeline(): Plays interrupts pending in the log. Must
+   be called with local hw interrupts disabled. */
+
+void fastcall __ipipe_walk_pipeline(struct list_head *pos, int cpuid)
+{
+	struct ipipe_domain *this_domain = per_cpu(ipipe_percpu_domain, cpuid);
+
+	while (pos != &__ipipe_pipeline) {
+		struct ipipe_domain *next_domain =
+		    list_entry(pos, struct ipipe_domain, p_link);
+
+		if (test_bit
+		    (IPIPE_STALL_FLAG, &next_domain->cpudata[cpuid].status))
+			break;	/* Stalled stage -- do not go further. */
+
+		if (next_domain->cpudata[cpuid].irq_pending_hi != 0) {
+
+			if (next_domain == this_domain)
+				__ipipe_sync_pipeline(IPIPE_IRQMASK_ANY);
+			else {
+				__ipipe_switch_to(this_domain, next_domain,
+						  cpuid);
+
+				ipipe_load_cpuid();	/* Processor might have changed. */
+
+				if (this_domain->cpudata[cpuid].
+				    irq_pending_hi != 0
+				    && !test_bit(IPIPE_STALL_FLAG,
+						 &this_domain->cpudata[cpuid].status))
+					__ipipe_sync_pipeline(IPIPE_IRQMASK_ANY);
+			}
+
+			break;
+		} else if (next_domain == this_domain)
+			break;
+
+		pos = next_domain->p_link.next;
+	}
+}
+
+/*
+ * ipipe_suspend_domain() -- Suspend the current domain, switching to
+ * the next one which has pending work down the pipeline.
+ */
+void ipipe_suspend_domain(void)
+{
+	struct ipipe_domain *this_domain, *next_domain;
+	struct list_head *ln;
+	unsigned long flags;
+	ipipe_declare_cpuid;
+
+	ipipe_lock_cpu(flags);
+
+	this_domain = next_domain = per_cpu(ipipe_percpu_domain, cpuid);
+
+	__clear_bit(IPIPE_STALL_FLAG, &this_domain->cpudata[cpuid].status);
+
+	if (this_domain->cpudata[cpuid].irq_pending_hi != 0)
+		goto sync_stage;
+
+	for (;;) {
+		ln = next_domain->p_link.next;
+
+		if (ln == &__ipipe_pipeline)
+			break;
+
+		next_domain = list_entry(ln, struct ipipe_domain, p_link);
+
+		if (test_bit(IPIPE_STALL_FLAG,
+			     &next_domain->cpudata[cpuid].status))
+			break;
+
+		if (next_domain->cpudata[cpuid].irq_pending_hi == 0)
+			continue;
+
+		per_cpu(ipipe_percpu_domain, cpuid) = next_domain;
+
+sync_stage:
+		__ipipe_sync_pipeline(IPIPE_IRQMASK_ANY);
+
+		ipipe_load_cpuid();	/* Processor might have changed. */
+
+		if (per_cpu(ipipe_percpu_domain, cpuid) != next_domain)
+			/*
+			 * Something has changed the current domain under our
+			 * feet, recycling the register set; take note.
+			 */
+			this_domain = per_cpu(ipipe_percpu_domain, cpuid);
+	}
+
+	per_cpu(ipipe_percpu_domain, cpuid) = this_domain;
+
+	ipipe_unlock_cpu(flags);
+}
+
+/* ipipe_alloc_virq() -- Allocate a pipelined virtual/soft interrupt.
+ * Virtual interrupts are handled in exactly the same way than their
+ * hw-generated counterparts wrt pipelining.
+ */
+unsigned ipipe_alloc_virq(void)
+{
+	unsigned long flags, irq = 0;
+	int ipos;
+
+	spin_lock_irqsave_hw(&__ipipe_pipelock, flags);
+
+	if (__ipipe_virtual_irq_map != ~0) {
+		ipos = ffz(__ipipe_virtual_irq_map);
+		set_bit(ipos, &__ipipe_virtual_irq_map);
+		irq = ipos + IPIPE_VIRQ_BASE;
+	}
+
+	spin_unlock_irqrestore_hw(&__ipipe_pipelock, flags);
+
+	return irq;
+}
+
+/* ipipe_virtualize_irq() -- Attach a handler (and optionally a hw
+   acknowledge routine) to an interrupt for a given domain. */
+
+int ipipe_virtualize_irq(struct ipipe_domain *ipd,
+			 unsigned irq,
+			 ipipe_irq_handler_t handler,
+			 void *cookie,
+			 ipipe_irq_ackfn_t acknowledge,
+			 unsigned modemask)
+{
+	unsigned long flags;
+	int err;
+
+	if (irq >= IPIPE_NR_IRQS)
+		return -EINVAL;
+
+	if (ipd->irqs[irq].control & IPIPE_SYSTEM_MASK)
+		return -EPERM;
+
+	if (!test_bit(IPIPE_AHEAD_FLAG, &ipd->flags))
+		/* Silently unwire interrupts for non-heading domains. */
+		modemask &= ~IPIPE_WIRED_MASK;
+
+	spin_lock_irqsave_hw(&__ipipe_pipelock, flags);
+
+	if (handler != NULL) {
+
+		if (handler == IPIPE_SAME_HANDLER) {
+			handler = ipd->irqs[irq].handler;
+			cookie = ipd->irqs[irq].cookie;
+
+			if (handler == NULL) {
+				err = -EINVAL;
+				goto unlock_and_exit;
+			}
+		} else if ((modemask & IPIPE_EXCLUSIVE_MASK) != 0 &&
+			   ipd->irqs[irq].handler != NULL) {
+			err = -EBUSY;
+			goto unlock_and_exit;
+		}
+
+		if ((modemask & (IPIPE_SHARED_MASK | IPIPE_PASS_MASK)) ==
+		    IPIPE_SHARED_MASK) {
+			err = -EINVAL;
+			goto unlock_and_exit;
+		}
+
+		/* Wired interrupts can only be delivered to domains
+		 * always heading the pipeline. */
+
+		if ((modemask & IPIPE_WIRED_MASK) != 0) {
+			if ((modemask & (IPIPE_SHARED_MASK | IPIPE_PASS_MASK | IPIPE_STICKY_MASK)) != 0) {
+				err = -EINVAL;
+				goto unlock_and_exit;
+			}
+			modemask |= (IPIPE_HANDLE_MASK);
+		}
+
+		if ((modemask & IPIPE_STICKY_MASK) != 0)
+			modemask |= IPIPE_HANDLE_MASK;
+	} else
+		modemask &=
+		    ~(IPIPE_HANDLE_MASK | IPIPE_STICKY_MASK |
+		      IPIPE_SHARED_MASK | IPIPE_EXCLUSIVE_MASK | IPIPE_WIRED_MASK);
+
+	if (acknowledge == NULL) {
+		if ((modemask & IPIPE_SHARED_MASK) == 0) {
+			if (!ipipe_virtual_irq_p(irq)) {
+				/* Acknowledge handler unspecified for a hw
+				   interrupt -- this is ok in non-shared
+				   management mode, but we will force the use
+				   of the Linux-defined handler instead. */
+				acknowledge = ipipe_root_domain->irqs[irq].acknowledge;
+			}
+		}
+		else {
+			/* A valid acknowledge handler to be called in shared mode
+			   is required when declaring a shared IRQ. */
+			err = -EINVAL;
+			goto unlock_and_exit;
+		}
+	}
+
+	ipd->irqs[irq].handler = handler;
+	ipd->irqs[irq].cookie = cookie;
+	ipd->irqs[irq].acknowledge = acknowledge;
+	ipd->irqs[irq].control = modemask;
+
+	if (irq < NR_IRQS && handler != NULL && !ipipe_virtual_irq_p(irq)) {
+		__ipipe_enable_irqdesc(irq);
+
+		if ((modemask & IPIPE_ENABLE_MASK) != 0) {
+			if (ipd != ipipe_current_domain) {
+				/* IRQ enable/disable state is domain-sensitive, so we may
+				   not change it for another domain. What is allowed
+				   however is forcing some domain to handle an interrupt
+				   source, by passing the proper 'ipd' descriptor which
+				   thus may be different from ipipe_current_domain. */
+				err = -EPERM;
+				goto unlock_and_exit;
+			}
+			
+			__ipipe_enable_irq(irq);
+		}
+	}
+
+	err = 0;
+
+      unlock_and_exit:
+
+	spin_unlock_irqrestore_hw(&__ipipe_pipelock, flags);
+
+	return err;
+}
+
+/* ipipe_control_irq() -- Change modes of a pipelined interrupt for
+ * the current domain. */
+
+int ipipe_control_irq(unsigned irq, unsigned clrmask, unsigned setmask)
+{
+	struct ipipe_domain *ipd;
+	unsigned long flags;
+
+	if (irq >= IPIPE_NR_IRQS)
+		return -EINVAL;
+
+	ipd = ipipe_current_domain;
+
+	if (ipd->irqs[irq].control & IPIPE_SYSTEM_MASK)
+		return -EPERM;
+
+	if (((setmask | clrmask) & IPIPE_SHARED_MASK) != 0)
+		return -EINVAL;
+
+	if (ipd->irqs[irq].handler == NULL)
+		setmask &= ~(IPIPE_HANDLE_MASK | IPIPE_STICKY_MASK);
+
+	if ((setmask & IPIPE_STICKY_MASK) != 0)
+		setmask |= IPIPE_HANDLE_MASK;
+
+	if ((clrmask & (IPIPE_HANDLE_MASK | IPIPE_STICKY_MASK)) != 0)	/* If one goes, both go. */
+		clrmask |= (IPIPE_HANDLE_MASK | IPIPE_STICKY_MASK);
+
+	spin_lock_irqsave_hw(&__ipipe_pipelock, flags);
+
+	ipd->irqs[irq].control &= ~clrmask;
+	ipd->irqs[irq].control |= setmask;
+
+	if ((setmask & IPIPE_ENABLE_MASK) != 0)
+		__ipipe_enable_irq(irq);
+	else if ((clrmask & IPIPE_ENABLE_MASK) != 0)
+		__ipipe_disable_irq(irq);
+
+	spin_unlock_irqrestore_hw(&__ipipe_pipelock, flags);
+
+	return 0;
+}
+
+/* __ipipe_dispatch_event() -- Low-level event dispatcher. */
+
+int fastcall __ipipe_dispatch_event (unsigned event, void *data)
+{
+	struct ipipe_domain *start_domain, *this_domain, *next_domain;
+	ipipe_event_handler_t evhand;
+	struct list_head *pos, *npos;
+	unsigned long flags;
+	ipipe_declare_cpuid;
+	int propagate = 1;
+
+	ipipe_lock_cpu(flags);
+
+	start_domain = this_domain = per_cpu(ipipe_percpu_domain, cpuid);
+
+	list_for_each_safe(pos,npos,&__ipipe_pipeline) {
+
+		/*
+		 * Note: Domain migration may occur while running
+		 * event or interrupt handlers, in which case the
+		 * current register set is going to be recycled for a
+		 * different domain than the initiating one. We do
+		 * care for that, always tracking the current domain
+		 * descriptor upon return from those handlers.
+		 */
+		next_domain = list_entry(pos,struct ipipe_domain,p_link);
+
+		/*
+		 * Keep a cached copy of the handler's address since
+		 * ipipe_catch_event() may clear it under our feet.
+		 */
+
+		evhand = next_domain->evhand[event];
+
+		if (evhand != NULL) {
+			per_cpu(ipipe_percpu_domain, cpuid) = next_domain;
+			next_domain->cpudata[cpuid].evsync |= (1LL << event);
+			ipipe_unlock_cpu(flags);
+			propagate = !evhand(event,start_domain,data);
+			ipipe_lock_cpu(flags);
+			next_domain->cpudata[cpuid].evsync &= ~(1LL << event);
+			if (per_cpu(ipipe_percpu_domain, cpuid) != next_domain)
+				this_domain = per_cpu(ipipe_percpu_domain, cpuid);
+		}
+
+		if (next_domain != ipipe_root_domain &&	/* NEVER sync the root stage here. */
+		    next_domain->cpudata[cpuid].irq_pending_hi != 0 &&
+		    !test_bit(IPIPE_STALL_FLAG,&next_domain->cpudata[cpuid].status)) {
+			per_cpu(ipipe_percpu_domain, cpuid) = next_domain;
+			__ipipe_sync_pipeline(IPIPE_IRQMASK_ANY);
+			ipipe_load_cpuid();
+			if (per_cpu(ipipe_percpu_domain, cpuid) != next_domain)
+				this_domain = per_cpu(ipipe_percpu_domain, cpuid);
+		}
+
+		per_cpu(ipipe_percpu_domain, cpuid) = this_domain;
+
+		if (next_domain == this_domain || !propagate)
+			break;
+	}
+
+	ipipe_unlock_cpu(flags);
+
+	return !propagate;
+}
+
+/*
+ * __ipipe_dispatch_wired -- Wired interrupt dispatcher. Wired
+ * interrupts are immediately and unconditionally delivered to the
+ * domain heading the pipeline upon receipt, and such domain must have
+ * been registered as an invariant head for the system (priority ==
+ * IPIPE_HEAD_PRIORITY). The motivation for using wired interrupts is
+ * to get an extra-fast dispatching path for those IRQs, by relying on
+ * a straightforward logic based on assumptions that must always be
+ * true for invariant head domains.  The following assumptions are
+ * made when dealing with such interrupts:
+ *
+ * 1- Wired interrupts are purely dynamic, i.e. the decision to
+ * propagate them down the pipeline must be done from the head domain
+ * ISR.
+ * 2- Wired interrupts cannot be shared or sticky.
+ * 3- The root domain cannot be an invariant pipeline head, in
+ * consequence of what the root domain cannot handle wired
+ * interrupts.
+ * 4- Wired interrupts must have a valid acknowledge handler for the
+ * head domain (if needed), and in any case, must not rely on handlers
+ * provided by lower priority domains during the acknowledge cycle
+ * (see __ipipe_handle_irq).
+ *
+ * Called with hw interrupts off.
+ */
+
+int fastcall __ipipe_dispatch_wired(struct ipipe_domain *head, unsigned irq)
+{
+	struct ipcpudata *cpudata;
+	struct ipipe_domain *old;
+	ipipe_declare_cpuid;
+
+	ipipe_load_cpuid();
+	cpudata = &head->cpudata[cpuid];
+	cpudata->irq_counters[irq].total_hits++;
+
+	if (test_bit(IPIPE_LOCK_FLAG, &head->irqs[irq].control)) {
+		/* If we can't process this IRQ right now, we must
+		 * mark it as pending, so that it will get played
+		 * during normal log sync when the corresponding
+		 * interrupt source is eventually unlocked. */
+		cpudata->irq_counters[irq].pending_hits++;
+		return 0;
+	}
+
+	if (test_bit(IPIPE_STALL_FLAG, &cpudata->status)) {
+		cpudata->irq_counters[irq].pending_hits++;
+		__ipipe_set_irq_bit(head, cpuid, irq);
+		return 0;
+	}
+
+	old = per_cpu(ipipe_percpu_domain, cpuid);
+	per_cpu(ipipe_percpu_domain, cpuid) = head; /* Switch to the head domain. */
+
+	__set_bit(IPIPE_STALL_FLAG, &cpudata->status);
+	head->irqs[irq].handler(irq,head->irqs[irq].cookie); /* Call the ISR. */
+	__ipipe_run_irqtail();
+	__clear_bit(IPIPE_STALL_FLAG, &cpudata->status);
+
+	/* We expect the caller to start a complete pipeline walk upon
+	 * return, so that propagated interrupts will get played. */
+
+	if (per_cpu(ipipe_percpu_domain, cpuid) == head)
+		per_cpu(ipipe_percpu_domain, cpuid) = old; /* Back to the preempted domain. */
+
+	return 1;
+}
+
+/*
+ * __ipipe_sync_stage() -- Flush the pending IRQs for the current
+ * domain (and processor). This routine flushes the interrupt log
+ * (see "Optimistic interrupt protection" from D. Stodolsky et al. for
+ * more on the deferred interrupt scheme). Every interrupt that
+ * occurred while the pipeline was stalled gets played. WARNING:
+ * callers on SMP boxen should always check for CPU migration on
+ * return of this routine. One can control the kind of interrupts
+ * which are going to be sync'ed using the syncmask
+ * parameter. IPIPE_IRQMASK_ANY plays them all, IPIPE_IRQMASK_VIRT
+ * plays virtual interrupts only.
+ *
+ * This routine must be called with hw interrupts off.
+ */
+void fastcall __ipipe_sync_stage(unsigned long syncmask)
+{
+	unsigned long mask, submask;
+	struct ipcpudata *cpudata;
+	struct ipipe_domain *ipd;
+	ipipe_declare_cpuid;
+	int level, rank;
+	unsigned irq;
+
+	ipipe_load_cpuid();
+	ipd = per_cpu(ipipe_percpu_domain, cpuid);
+	cpudata = &ipd->cpudata[cpuid];
+
+	if (__test_and_set_bit(IPIPE_SYNC_FLAG, &cpudata->status))
+		return;
+
+	/*
+	 * The policy here is to keep the dispatching code interrupt-free
+	 * by stalling the current stage. If the upper domain handler
+	 * (which we call) wants to re-enable interrupts while in a safe
+	 * portion of the code (e.g. SA_INTERRUPT flag unset for Linux's
+	 * sigaction()), it will have to unstall (then stall again before
+	 * returning to us!) the stage when it sees fit.
+	 */
+	while ((mask = (cpudata->irq_pending_hi & syncmask)) != 0) {
+		level = __ipipe_ffnz(mask);
+
+		while ((submask = cpudata->irq_pending_lo[level]) != 0) {
+			rank = __ipipe_ffnz(submask);
+			irq = (level << IPIPE_IRQ_ISHIFT) + rank;
+
+			if (test_bit(IPIPE_LOCK_FLAG, &ipd->irqs[irq].control)) {
+				__clear_bit(rank, &cpudata->irq_pending_lo[level]);
+				continue;
+			}
+
+			if (--cpudata->irq_counters[irq].pending_hits == 0) {
+				__clear_bit(rank, &cpudata->irq_pending_lo[level]);
+				if (cpudata->irq_pending_lo[level] == 0)
+					__clear_bit(level, &cpudata->irq_pending_hi);
+			}
+
+			__set_bit(IPIPE_STALL_FLAG, &cpudata->status);
+			__ipipe_run_isr(ipd, irq, cpuid);
+#ifdef CONFIG_SMP
+			{
+				int _cpuid = ipipe_processor_id();
+
+				if (_cpuid != cpuid) {	/* Handle CPU migration. */
+					/*
+					 * We expect any domain to clear the SYNC bit each
+					 * time it switches in a new task, so that preemptions
+					 * and/or CPU migrations (in the SMP case) over the
+					 * ISR do not lock out the log syncer for some
+					 * indefinite amount of time. In the Linux case,
+					 * schedule() handles this (see kernel/sched.c). For
+					 * this reason, we don't bother clearing it here for
+					 * the source CPU in the migration handling case,
+					 * since it must have scheduled another task in by
+					 * now.
+					 */
+					cpuid = _cpuid;
+					cpudata = &ipd->cpudata[cpuid];
+					__set_bit(IPIPE_SYNC_FLAG, &cpudata->status);
+				}
+			}
+#endif	/* CONFIG_SMP */
+
+			__clear_bit(IPIPE_STALL_FLAG, &cpudata->status);
+		}
+	}
+
+	__clear_bit(IPIPE_SYNC_FLAG, &cpudata->status);
+}
+
+#ifdef CONFIG_PROC_FS
+
+#include <linux/proc_fs.h>
+
+struct proc_dir_entry *ipipe_proc_root;
+
+static int __ipipe_version_info_proc(char *page,
+				     char **start,
+				     off_t off, int count, int *eof, void *data)
+{
+	int len = sprintf(page, "%s\n", IPIPE_VERSION_STRING);
+
+	len -= off;
+
+	if (len <= off + count)
+		*eof = 1;
+
+	*start = page + off;
+
+	if(len > count)
+		len = count;
+
+	if(len < 0)
+		len = 0;
+
+	return len;
+}
+
+static int __ipipe_common_info_proc(char *page,
+				    char **start,
+				    off_t off, int count, int *eof, void *data)
+{
+	struct ipipe_domain *ipd = (struct ipipe_domain *)data;
+	unsigned long ctlbits;
+	unsigned irq, _irq;
+	char *p = page;
+	int len;
+
+	spin_lock(&__ipipe_pipelock);
+
+	if (test_bit(IPIPE_AHEAD_FLAG,&ipd->flags))
+		p += sprintf(p, "Invariant head");
+	else
+		p += sprintf(p, "Priority=%d", ipd->priority);
+
+	p += sprintf(p, ", Id=0x%.8x\n", ipd->domid);
+
+	irq = 0;
+
+	while (irq < IPIPE_NR_IRQS) {
+		ctlbits =
+			(ipd->irqs[irq].
+			 control & (IPIPE_HANDLE_MASK | IPIPE_PASS_MASK |
+				    IPIPE_STICKY_MASK | IPIPE_WIRED_MASK));
+		if (irq >= IPIPE_NR_XIRQS && !ipipe_virtual_irq_p(irq)) {
+			/*
+			 * There might be a hole between the last external
+			 * IRQ and the first virtual one; skip it.
+			 */
+			irq++;
+			continue;
+		}
+
+		if (ipipe_virtual_irq_p(irq)
+		    && !test_bit(irq - IPIPE_VIRQ_BASE,
+				 &__ipipe_virtual_irq_map)) {
+			/* Non-allocated virtual IRQ; skip it. */
+			irq++;
+			continue;
+		}
+
+		/*
+		 * Attempt to group consecutive IRQ numbers having the
+		 * same virtualization settings in a single line.
+		 */
+
+		_irq = irq;
+
+		while (++_irq < IPIPE_NR_IRQS) {
+			if (ipipe_virtual_irq_p(_irq) !=
+			    ipipe_virtual_irq_p(irq)
+			    || (ipipe_virtual_irq_p(_irq)
+				&& !test_bit(_irq - IPIPE_VIRQ_BASE,
+					     &__ipipe_virtual_irq_map))
+			    || ctlbits != (ipd->irqs[_irq].
+			     control & (IPIPE_HANDLE_MASK |
+					IPIPE_PASS_MASK |
+					IPIPE_STICKY_MASK)))
+				break;
+		}
+
+		if (_irq == irq + 1)
+			p += sprintf(p, "irq%u: ", irq);
+		else
+			p += sprintf(p, "irq%u-%u: ", irq, _irq - 1);
+
+		/*
+		 * Statuses are as follows:
+		 * o "accepted" means handled _and_ passed down the pipeline.
+		 * o "grabbed" means handled, but the interrupt might be
+		 * terminated _or_ passed down the pipeline depending on
+		 * what the domain handler asks for to the I-pipe.
+		 * o "wired" is basically the same as "grabbed", except that
+		 * the interrupt is unconditionally delivered to an invariant
+		 * pipeline head domain.
+		 * o "passed" means unhandled by the domain but passed
+		 * down the pipeline.
+		 * o "discarded" means unhandled and _not_ passed down the
+		 * pipeline. The interrupt merely disappears from the
+		 * current domain down to the end of the pipeline.
+		 */
+		if (ctlbits & IPIPE_HANDLE_MASK) {
+			if (ctlbits & IPIPE_PASS_MASK)
+				p += sprintf(p, "accepted");
+			else if (ctlbits & IPIPE_WIRED_MASK)
+				p += sprintf(p, "wired");
+			else
+				p += sprintf(p, "grabbed");
+		} else if (ctlbits & IPIPE_PASS_MASK)
+			p += sprintf(p, "passed");
+		else
+			p += sprintf(p, "discarded");
+
+		if (ctlbits & IPIPE_STICKY_MASK)
+			p += sprintf(p, ", sticky");
+
+		if (ipipe_virtual_irq_p(irq))
+			p += sprintf(p, ", virtual");
+
+		p += sprintf(p, "\n");
+
+		irq = _irq;
+	}
+
+	spin_unlock(&__ipipe_pipelock);
+
+	len = p - page;
+
+	if (len <= off + count)
+		*eof = 1;
+
+	*start = page + off;
+
+	len -= off;
+
+	if (len > count)
+		len = count;
+
+	if (len < 0)
+		len = 0;
+
+	return len;
+}
+
+void __ipipe_add_domain_proc(struct ipipe_domain *ipd)
+{
+	create_proc_read_entry(ipd->name,0444,ipipe_proc_root,&__ipipe_common_info_proc,ipd);
+}
+
+void __ipipe_remove_domain_proc(struct ipipe_domain *ipd)
+{
+	remove_proc_entry(ipd->name,ipipe_proc_root);
+}
+
+void ipipe_init_proc(void)
+{
+	ipipe_proc_root = create_proc_entry("ipipe",S_IFDIR, 0);
+	create_proc_read_entry("version",0444,ipipe_proc_root,&__ipipe_version_info_proc,NULL);
+	__ipipe_add_domain_proc(ipipe_root_domain);
+
+	__ipipe_init_tracer();
+}
+
+#endif	/* CONFIG_PROC_FS */
+
+EXPORT_SYMBOL(ipipe_virtualize_irq);
+EXPORT_SYMBOL(ipipe_control_irq);
+EXPORT_SYMBOL(ipipe_suspend_domain);
+EXPORT_SYMBOL(ipipe_alloc_virq);
+EXPORT_PER_CPU_SYMBOL(ipipe_percpu_domain);
+EXPORT_SYMBOL(ipipe_root);
+EXPORT_SYMBOL(ipipe_stall_pipeline_from);
+EXPORT_SYMBOL(ipipe_test_and_stall_pipeline_from);
+EXPORT_SYMBOL(ipipe_unstall_pipeline_from);
+EXPORT_SYMBOL(ipipe_restore_pipeline_from);
+EXPORT_SYMBOL(ipipe_test_and_unstall_pipeline_from);
+EXPORT_SYMBOL(ipipe_unstall_pipeline_head);
+EXPORT_SYMBOL(__ipipe_restore_pipeline_head);
+EXPORT_SYMBOL(__ipipe_unstall_root);
+EXPORT_SYMBOL(__ipipe_stall_root);
+EXPORT_SYMBOL(__ipipe_restore_root);
+EXPORT_SYMBOL(__ipipe_test_and_stall_root);
+EXPORT_SYMBOL(__ipipe_test_root);
+EXPORT_SYMBOL(__ipipe_dispatch_event);
+EXPORT_SYMBOL(__ipipe_dispatch_wired);
+EXPORT_SYMBOL(__ipipe_sync_stage);
+EXPORT_SYMBOL(__ipipe_pipeline);
+EXPORT_SYMBOL(__ipipe_pipelock);
+EXPORT_SYMBOL(__ipipe_virtual_irq_map);
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/kernel/ipipe/generic.c ipipe-2.6.14-imx21/kernel/ipipe/generic.c
--- linux-2.6.14/kernel/ipipe/generic.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/kernel/ipipe/generic.c	2008-02-21 22:09:03.000000000 +0100
@@ -0,0 +1,424 @@
+/* -*- linux-c -*-
+ * linux/kernel/ipipe/generic.c
+ *
+ * Copyright (C) 2002-2005 Philippe Gerum.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge MA 02139,
+ * USA; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Architecture-independent I-PIPE services.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#endif	/* CONFIG_PROC_FS */
+
+MODULE_DESCRIPTION("I-pipe");
+MODULE_LICENSE("GPL");
+
+static int __ipipe_ptd_key_count;
+
+static unsigned long __ipipe_ptd_key_map;
+
+/* ipipe_register_domain() -- Link a new domain to the pipeline. */
+
+int ipipe_register_domain(struct ipipe_domain *ipd,
+			  struct ipipe_domain_attr *attr)
+{
+	struct list_head *pos;
+	unsigned long flags;
+
+	if (ipipe_current_domain != ipipe_root_domain) {
+		printk(KERN_WARNING
+		       "I-pipe: Only the root domain may register a new domain.\n");
+		return -EPERM;
+	}
+
+	if (attr->priority == IPIPE_HEAD_PRIORITY &&
+	    test_bit(IPIPE_AHEAD_FLAG,&__ipipe_pipeline_head()->flags))
+		return -EAGAIN;	/* Cannot override current head. */
+
+	flags = ipipe_critical_enter(NULL);
+
+	list_for_each(pos, &__ipipe_pipeline) {
+		struct ipipe_domain *_ipd =
+			list_entry(pos, struct ipipe_domain, p_link);
+		if (_ipd->domid == attr->domid)
+			break;
+	}
+
+	ipipe_critical_exit(flags);
+
+	if (pos != &__ipipe_pipeline)
+		/* A domain with the given id already exists -- fail. */
+		return -EBUSY;
+
+	ipd->name = attr->name;
+	ipd->domid = attr->domid;
+	ipd->pdd = attr->pdd;
+	ipd->flags = 0;
+
+	if (attr->priority == IPIPE_HEAD_PRIORITY) {
+		ipd->priority = INT_MAX;
+		__set_bit(IPIPE_AHEAD_FLAG,&ipd->flags);
+	}
+	else
+		ipd->priority = attr->priority;
+
+	__ipipe_init_stage(ipd);
+
+	INIT_LIST_HEAD(&ipd->p_link);
+
+#ifdef CONFIG_PROC_FS
+	__ipipe_add_domain_proc(ipd);
+#endif /* CONFIG_PROC_FS */
+
+	flags = ipipe_critical_enter(NULL);
+
+	list_for_each(pos, &__ipipe_pipeline) {
+		struct ipipe_domain *_ipd =
+			list_entry(pos, struct ipipe_domain, p_link);
+		if (ipd->priority > _ipd->priority)
+			break;
+	}
+
+	list_add_tail(&ipd->p_link, pos);
+
+	ipipe_critical_exit(flags);
+
+	printk(KERN_WARNING "I-pipe: Domain %s registered.\n", ipd->name);
+
+	/*
+	 * Finally, allow the new domain to perform its initialization
+	 * chores.
+	 */
+
+	if (attr->entry != NULL) {
+		ipipe_declare_cpuid;
+
+		ipipe_lock_cpu(flags);
+
+		per_cpu(ipipe_percpu_domain, cpuid) = ipd;
+		attr->entry();
+		per_cpu(ipipe_percpu_domain, cpuid) = ipipe_root_domain;
+
+		ipipe_load_cpuid();	/* Processor might have changed. */
+
+		if (ipipe_root_domain->cpudata[cpuid].irq_pending_hi != 0 &&
+		    !test_bit(IPIPE_STALL_FLAG,
+			      &ipipe_root_domain->cpudata[cpuid].status))
+			__ipipe_sync_pipeline(IPIPE_IRQMASK_ANY);
+
+		ipipe_unlock_cpu(flags);
+	}
+
+	return 0;
+}
+
+/* ipipe_unregister_domain() -- Remove a domain from the pipeline. */
+
+int ipipe_unregister_domain(struct ipipe_domain *ipd)
+{
+	unsigned long flags;
+
+	if (ipipe_current_domain != ipipe_root_domain) {
+		printk(KERN_WARNING
+		       "I-pipe: Only the root domain may unregister a domain.\n");
+		return -EPERM;
+	}
+
+	if (ipd == ipipe_root_domain) {
+		printk(KERN_WARNING
+		       "I-pipe: Cannot unregister the root domain.\n");
+		return -EPERM;
+	}
+#ifdef CONFIG_SMP
+	{
+		int nr_cpus = num_online_cpus(), _cpuid;
+		unsigned irq;
+
+		/*
+		 * In the SMP case, wait for the logged events to drain on
+		 * other processors before eventually removing the domain
+		 * from the pipeline.
+		 */
+
+		ipipe_unstall_pipeline_from(ipd);
+
+		flags = ipipe_critical_enter(NULL);
+
+		for (irq = 0; irq < IPIPE_NR_IRQS; irq++) {
+			clear_bit(IPIPE_HANDLE_FLAG, &ipd->irqs[irq].control);
+			clear_bit(IPIPE_STICKY_FLAG, &ipd->irqs[irq].control);
+			set_bit(IPIPE_PASS_FLAG, &ipd->irqs[irq].control);
+		}
+
+		ipipe_critical_exit(flags);
+
+		for (_cpuid = 0; _cpuid < nr_cpus; _cpuid++)
+			for (irq = 0; irq < IPIPE_NR_IRQS; irq++)
+				while (ipd->cpudata[_cpuid].irq_counters[irq].pending_hits > 0)
+					cpu_relax();
+	}
+#endif	/* CONFIG_SMP */
+
+#ifdef CONFIG_PROC_FS
+	__ipipe_remove_domain_proc(ipd);
+#endif /* CONFIG_PROC_FS */
+
+	/*
+	 * Simply remove the domain from the pipeline and we are almost done.
+	 */
+
+	flags = ipipe_critical_enter(NULL);
+	list_del_init(&ipd->p_link);
+	ipipe_critical_exit(flags);
+
+	__ipipe_cleanup_domain(ipd);
+
+	printk(KERN_WARNING "I-pipe: Domain %s unregistered.\n", ipd->name);
+
+	return 0;
+}
+
+/*
+ * ipipe_propagate_irq() -- Force a given IRQ propagation on behalf of
+ * a running interrupt handler to the next domain down the pipeline.
+ * ipipe_schedule_irq() -- Does almost the same as above, but attempts
+ * to pend the interrupt for the current domain first.
+ */
+int fastcall __ipipe_schedule_irq(unsigned irq, struct list_head *head)
+{
+	struct list_head *ln;
+	unsigned long flags;
+	ipipe_declare_cpuid;
+
+	if (irq >= IPIPE_NR_IRQS ||
+	    (ipipe_virtual_irq_p(irq)
+	     && !test_bit(irq - IPIPE_VIRQ_BASE, &__ipipe_virtual_irq_map)))
+		return -EINVAL;
+
+	ipipe_lock_cpu(flags);
+
+	ln = head;
+
+	while (ln != &__ipipe_pipeline) {
+		struct ipipe_domain *ipd =
+			list_entry(ln, struct ipipe_domain, p_link);
+
+		if (test_bit(IPIPE_HANDLE_FLAG, &ipd->irqs[irq].control)) {
+			ipd->cpudata[cpuid].irq_counters[irq].total_hits++;
+			ipd->cpudata[cpuid].irq_counters[irq].pending_hits++;
+			__ipipe_set_irq_bit(ipd, cpuid, irq);
+			ipipe_unlock_cpu(flags);
+			return 1;
+		}
+
+		ln = ipd->p_link.next;
+	}
+
+	ipipe_unlock_cpu(flags);
+
+	return 0;
+}
+
+/* ipipe_free_virq() -- Release a virtual/soft interrupt. */
+
+int ipipe_free_virq(unsigned virq)
+{
+	if (!ipipe_virtual_irq_p(virq))
+		return -EINVAL;
+
+	clear_bit(virq - IPIPE_VIRQ_BASE, &__ipipe_virtual_irq_map);
+
+	return 0;
+}
+
+void ipipe_init_attr(struct ipipe_domain_attr *attr)
+{
+	attr->name = "anon";
+	attr->domid = 1;
+	attr->entry = NULL;
+	attr->priority = IPIPE_ROOT_PRIO;
+	attr->pdd = NULL;
+}
+
+/*
+ * ipipe_catch_event() -- Interpose or remove an event handler for a
+ * given domain.
+ */
+ipipe_event_handler_t ipipe_catch_event(struct ipipe_domain *ipd,
+					unsigned event,
+					ipipe_event_handler_t handler)
+{
+	ipipe_event_handler_t old_handler;
+	unsigned long flags;
+	int self = 0, cpuid;
+
+	if (event & IPIPE_EVENT_SELF) {
+		event &= ~IPIPE_EVENT_SELF;
+		self = 1;
+	}
+
+	if (event >= IPIPE_NR_EVENTS)
+		return NULL;
+
+	flags = ipipe_critical_enter(NULL);
+
+	if (!(old_handler = xchg(&ipd->evhand[event],handler)))	{
+		if (handler) {
+			if (self)
+				ipd->evself |= (1LL << event);
+			else
+				__ipipe_event_monitors[event]++;
+		}
+	}
+	else if (!handler) {
+		if (ipd->evself & (1LL << event))
+			ipd->evself &= ~(1LL << event);
+		else
+			__ipipe_event_monitors[event]--;
+	} else if ((ipd->evself & (1LL << event)) && !self) {
+			__ipipe_event_monitors[event]++;
+			ipd->evself &= ~(1LL << event);
+	} else if (!(ipd->evself & (1LL << event)) && self) {
+			__ipipe_event_monitors[event]--;
+			ipd->evself |= (1LL << event);
+	}
+	
+	ipipe_critical_exit(flags);
+
+	if (!handler && ipipe_root_domain_p) {
+		/*
+		 * If we cleared a handler on behalf of the root
+		 * domain, we have to wait for any current invocation
+		 * to drain, since our caller might subsequently unmap
+		 * the target domain. To this aim, this code
+		 * synchronizes with __ipipe_dispatch_event(),
+		 * guaranteeing that either the dispatcher sees a null
+		 * handler in which case it discards the invocation
+		 * (which also prevents from entering a livelock), or
+		 * finds a valid handler and calls it. Symmetrically,
+		 * ipipe_catch_event() ensures that the called code
+		 * won't be unmapped under our feet until the event
+		 * synchronization flag is cleared for the given event
+		 * on all CPUs.
+		 */
+
+		for_each_online_cpu(cpuid) {
+			while (ipd->cpudata[cpuid].evsync & (1LL << event))
+				schedule_timeout_interruptible(HZ / 50);
+		}
+	}
+
+	return old_handler;
+}
+
+cpumask_t ipipe_set_irq_affinity (unsigned irq, cpumask_t cpumask)
+{
+#ifdef CONFIG_SMP
+	if (irq >= IPIPE_NR_XIRQS)
+		/* Allow changing affinity of external IRQs only. */
+		return CPU_MASK_NONE;
+
+	if (num_online_cpus() > 1)
+		return __ipipe_set_irq_affinity(irq,cpumask);
+#endif /* CONFIG_SMP */
+
+	return CPU_MASK_NONE;
+}
+
+int fastcall ipipe_send_ipi (unsigned ipi, cpumask_t cpumask)
+
+{
+#ifdef CONFIG_SMP
+	return __ipipe_send_ipi(ipi,cpumask);
+#else /* !CONFIG_SMP */
+	return -EINVAL;
+#endif /* CONFIG_SMP */
+}
+
+int ipipe_alloc_ptdkey (void)
+{
+	unsigned long flags;
+	int key = -1;
+
+	spin_lock_irqsave_hw(&__ipipe_pipelock,flags);
+
+	if (__ipipe_ptd_key_count < IPIPE_ROOT_NPTDKEYS) {
+		key = ffz(__ipipe_ptd_key_map);
+		set_bit(key,&__ipipe_ptd_key_map);
+		__ipipe_ptd_key_count++;
+	}
+
+	spin_unlock_irqrestore_hw(&__ipipe_pipelock,flags);
+
+	return key;
+}
+
+int ipipe_free_ptdkey (int key)
+{
+	unsigned long flags;
+
+	if (key < 0 || key >= IPIPE_ROOT_NPTDKEYS)
+		return -EINVAL;
+
+	spin_lock_irqsave_hw(&__ipipe_pipelock,flags);
+
+	if (test_and_clear_bit(key,&__ipipe_ptd_key_map))
+		__ipipe_ptd_key_count--;
+
+	spin_unlock_irqrestore_hw(&__ipipe_pipelock,flags);
+
+	return 0;
+}
+
+int fastcall ipipe_set_ptd (int key, void *value)
+
+{
+	if (key < 0 || key >= IPIPE_ROOT_NPTDKEYS)
+		return -EINVAL;
+
+	current->ptd[key] = value;
+
+	return 0;
+}
+
+void fastcall *ipipe_get_ptd (int key)
+
+{
+	if (key < 0 || key >= IPIPE_ROOT_NPTDKEYS)
+		return NULL;
+
+	return current->ptd[key];
+}
+
+EXPORT_SYMBOL(ipipe_register_domain);
+EXPORT_SYMBOL(ipipe_unregister_domain);
+EXPORT_SYMBOL(ipipe_free_virq);
+EXPORT_SYMBOL(ipipe_init_attr);
+EXPORT_SYMBOL(ipipe_catch_event);
+EXPORT_SYMBOL(ipipe_alloc_ptdkey);
+EXPORT_SYMBOL(ipipe_free_ptdkey);
+EXPORT_SYMBOL(ipipe_set_ptd);
+EXPORT_SYMBOL(ipipe_get_ptd);
+EXPORT_SYMBOL(ipipe_set_irq_affinity);
+EXPORT_SYMBOL(ipipe_send_ipi);
+EXPORT_SYMBOL(__ipipe_schedule_irq);
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/kernel/ipipe/tracer.c ipipe-2.6.14-imx21/kernel/ipipe/tracer.c
--- linux-2.6.14/kernel/ipipe/tracer.c	1970-01-01 01:00:00.000000000 +0100
+++ ipipe-2.6.14-imx21/kernel/ipipe/tracer.c	2008-02-21 22:09:03.000000000 +0100
@@ -0,0 +1,1241 @@
+/* -*- linux-c -*-
+ * kernel/ipipe/tracer.c
+ *
+ * Copyright (C) 2005 Luotao Fu.
+ *               2005, 2006 Jan Kiszka.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge MA 02139,
+ * USA; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kallsyms.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/vmalloc.h>
+#include <linux/ipipe_trace.h>
+#include <asm/uaccess.h>
+
+#define IPIPE_TRACE_PATHS           4 /* <!> Do not lower below 3 */
+#define IPIPE_DEFAULT_ACTIVE        0
+#define IPIPE_DEFAULT_MAX           1
+#define IPIPE_DEFAULT_FROZEN        2
+
+#define IPIPE_TRACE_POINTS          (1 << CONFIG_IPIPE_TRACE_SHIFT)
+#define WRAP_POINT_NO(point)        ((point) & (IPIPE_TRACE_POINTS-1))
+
+#define IPIPE_DEFAULT_PRE_TRACE     10
+#define IPIPE_DEFAULT_POST_TRACE    10
+#define IPIPE_DEFAULT_BACK_TRACE    30
+
+#define IPIPE_DELAY_NOTE            1000  /* in nanoseconds */
+#define IPIPE_DELAY_WARN            10000 /* in nanoseconds */
+
+#define IPIPE_TFLG_NMI_LOCK         0x0001
+#define IPIPE_TFLG_NMI_HIT          0x0002
+#define IPIPE_TFLG_NMI_FREEZE_REQ   0x0004
+
+#define IPIPE_TFLG_HWIRQ_OFF        0x0100
+#define IPIPE_TFLG_FREEZING         0x0200
+#define IPIPE_TFLG_CURRDOM_SHIFT    10   /* bits 10..11: current domain */
+#define IPIPE_TFLG_CURRDOM_MASK     0x0C00
+#define IPIPE_TFLG_DOMSTATE_SHIFT   12   /* bits 12..15: domain stalled? */
+#define IPIPE_TFLG_DOMSTATE_BITS    3
+
+#define IPIPE_TFLG_DOMAIN_STALLED(point, n) \
+	(point->flags & (1 << (n + IPIPE_TFLG_DOMSTATE_SHIFT)))
+#define IPIPE_TFLG_CURRENT_DOMAIN(point) \
+	((point->flags & IPIPE_TFLG_CURRDOM_MASK) >> IPIPE_TFLG_CURRDOM_SHIFT)
+
+
+struct ipipe_trace_point{
+	short type;
+	short flags;
+	unsigned long eip;
+	unsigned long parent_eip;
+	unsigned long v;
+	unsigned long long timestamp;
+};
+
+struct ipipe_trace_path{
+	volatile int flags;
+	int dump_lock; /* separated from flags due to cross-cpu access */
+	int trace_pos; /* next point to fill */
+	int begin, end; /* finalised path begin and end */
+	int post_trace; /* non-zero when in post-trace phase */
+	unsigned long long length; /* max path length in cycles */
+	unsigned long nmi_saved_eip; /* for deferred requests from NMIs */
+	unsigned long nmi_saved_parent_eip;
+	unsigned long nmi_saved_v;
+	struct ipipe_trace_point point[IPIPE_TRACE_POINTS];
+} ____cacheline_aligned_in_smp;
+
+enum ipipe_trace_type
+{
+	IPIPE_TRACE_FUNC = 0,
+	IPIPE_TRACE_BEGIN,
+	IPIPE_TRACE_END,
+	IPIPE_TRACE_FREEZE,
+	IPIPE_TRACE_SPECIAL,
+	IPIPE_TRACE_PID,
+};
+
+#define IPIPE_TYPE_MASK             0x0007
+#define IPIPE_TYPE_BITS             3
+
+
+#ifdef CONFIG_IPIPE_TRACE_VMALLOC
+
+static struct ipipe_trace_path *trace_paths[NR_CPUS];
+
+#else /* !CONFIG_IPIPE_TRACE_VMALLOC */
+
+static struct ipipe_trace_path trace_paths[NR_CPUS][IPIPE_TRACE_PATHS] =
+	{ [0 ... NR_CPUS-1] =
+		{ [0 ... IPIPE_TRACE_PATHS-1] =
+			{ .begin = -1, .end = -1 }
+		}
+	};
+#endif /* CONFIG_IPIPE_TRACE_VMALLOC */
+
+int ipipe_trace_enable = 0;
+
+static int active_path[NR_CPUS] =
+	{ [0 ... NR_CPUS-1] = IPIPE_DEFAULT_ACTIVE };
+static int max_path[NR_CPUS] =
+	{ [0 ... NR_CPUS-1] = IPIPE_DEFAULT_MAX };
+static int frozen_path[NR_CPUS] =
+	{ [0 ... NR_CPUS-1] = IPIPE_DEFAULT_FROZEN };
+static ipipe_spinlock_t global_path_lock = IPIPE_SPIN_LOCK_UNLOCKED;
+static int pre_trace = IPIPE_DEFAULT_PRE_TRACE;
+static int post_trace = IPIPE_DEFAULT_POST_TRACE;
+static int back_trace = IPIPE_DEFAULT_BACK_TRACE;
+static int verbose_trace = 0;
+
+static DECLARE_MUTEX(out_mutex);
+static struct ipipe_trace_path *print_path;
+static struct ipipe_trace_path *panic_path;
+static int print_pre_trace;
+static int print_post_trace;
+
+
+static long __ipipe_signed_tsc2us(long long tsc);
+static void
+__ipipe_trace_point_type(char *buf, struct ipipe_trace_point *point);
+static void __ipipe_print_symname(struct seq_file *m, unsigned long eip);
+
+
+static notrace void
+__ipipe_store_domain_states(struct ipipe_trace_point *point, int cpu_id)
+{
+	struct list_head *pos;
+	int i = 0;
+
+	list_for_each_prev(pos, &__ipipe_pipeline) {
+		struct ipipe_domain *ipd =
+			list_entry(pos, struct ipipe_domain, p_link);
+
+		if (test_bit(IPIPE_STALL_FLAG, &ipd->cpudata[cpu_id].status))
+			point->flags |= 1 << (i + IPIPE_TFLG_DOMSTATE_SHIFT);
+
+		if (ipd == per_cpu(ipipe_percpu_domain, cpu_id))
+			point->flags |= i << IPIPE_TFLG_CURRDOM_SHIFT;
+
+		if (++i > IPIPE_TFLG_DOMSTATE_BITS)
+			break;
+	}
+}
+
+static notrace int __ipipe_get_free_trace_path(int old, int cpu_id)
+{
+	int new_active = old;
+	struct ipipe_trace_path *tp;
+
+	do {
+		if (++new_active == IPIPE_TRACE_PATHS)
+			new_active = 0;
+		tp = &trace_paths[cpu_id][new_active];
+	} while ((new_active == max_path[cpu_id]) ||
+	         (new_active == frozen_path[cpu_id]) ||
+	         tp->dump_lock);
+
+	return new_active;
+}
+
+static notrace void
+__ipipe_migrate_pre_trace(struct ipipe_trace_path *new_tp,
+                          struct ipipe_trace_path *old_tp, int old_pos)
+{
+	int i;
+
+	new_tp->trace_pos = pre_trace+1;
+
+	for (i = new_tp->trace_pos; i > 0; i--)
+		memcpy(&new_tp->point[WRAP_POINT_NO(new_tp->trace_pos-i)],
+		       &old_tp->point[WRAP_POINT_NO(old_pos-i)],
+		       sizeof(struct ipipe_trace_point));
+
+	/* mark the end (i.e. the point before point[0]) invalid */
+	new_tp->point[IPIPE_TRACE_POINTS-1].eip = 0;
+}
+
+static notrace struct ipipe_trace_path *
+__ipipe_trace_end(int cpu_id, struct ipipe_trace_path *tp, int pos)
+{
+	struct ipipe_trace_path *old_tp = tp;
+	long active = active_path[cpu_id];
+	unsigned long long length;
+
+	/* do we have a new worst case? */
+	length = tp->point[tp->end].timestamp -
+	         tp->point[tp->begin].timestamp;
+	if (length > (trace_paths[cpu_id][max_path[cpu_id]]).length) {
+		/* we need protection here against other cpus trying
+		   to start a proc dump */
+		spin_lock_hw(&global_path_lock);
+
+		/* active path holds new worst case */
+		tp->length = length;
+		max_path[cpu_id] = active;
+
+		/* find next unused trace path */
+		active = __ipipe_get_free_trace_path(active, cpu_id);
+
+		spin_unlock_hw(&global_path_lock);
+
+		tp = &trace_paths[cpu_id][active];
+
+		/* migrate last entries for pre-tracing */
+		__ipipe_migrate_pre_trace(tp, old_tp, pos);
+	}
+
+	return tp;
+}
+
+static notrace struct ipipe_trace_path *
+__ipipe_trace_freeze(int cpu_id, struct ipipe_trace_path *tp, int pos)
+{
+	struct ipipe_trace_path *old_tp = tp;
+	long active = active_path[cpu_id];
+	int i;
+
+	/* frozen paths have no core (begin=end) */
+	tp->begin = tp->end;
+
+	/* we need protection here against other cpus trying
+	 * to set their frozen path or to start a proc dump */
+	spin_lock_hw(&global_path_lock);
+
+	frozen_path[cpu_id] = active;
+
+	/* find next unused trace path */
+	active = __ipipe_get_free_trace_path(active, cpu_id);
+
+	/* check if this is the first frozen path */
+	for_each_online_cpu(i) {
+		if ((i != cpu_id) &&
+		    (trace_paths[i][frozen_path[i]].end >= 0))
+			tp->end = -1;
+	}
+
+	spin_unlock_hw(&global_path_lock);
+
+	tp = &trace_paths[cpu_id][active];
+
+	/* migrate last entries for pre-tracing */
+	__ipipe_migrate_pre_trace(tp, old_tp, pos);
+
+	return tp;
+}
+
+void notrace
+__ipipe_trace(enum ipipe_trace_type type, unsigned long eip,
+              unsigned long parent_eip, unsigned long v)
+{
+	struct ipipe_trace_path *tp, *old_tp;
+	int pos, next_pos, begin;
+	struct ipipe_trace_point *point;
+	unsigned long flags;
+	int cpu_id;
+
+	local_irq_save_hw_notrace(flags);
+
+	cpu_id = ipipe_processor_id();
+restart:
+	tp = old_tp = &trace_paths[cpu_id][active_path[cpu_id]];
+
+	/* here starts a race window with NMIs - catched below */
+
+	/* check for NMI recursion */
+	if (unlikely(tp->flags & IPIPE_TFLG_NMI_LOCK)) {
+		tp->flags |= IPIPE_TFLG_NMI_HIT;
+
+		/* first freeze request from NMI context? */
+		if ((type == IPIPE_TRACE_FREEZE) &&
+		    !(tp->flags & IPIPE_TFLG_NMI_FREEZE_REQ)) {
+			/* save arguments and mark deferred freezing */
+			tp->flags |= IPIPE_TFLG_NMI_FREEZE_REQ;
+			tp->nmi_saved_eip = eip;
+			tp->nmi_saved_parent_eip = parent_eip;
+			tp->nmi_saved_v = v;
+		}
+		return; /* no need for restoring flags inside IRQ */
+	}
+
+	/* clear NMI events and set lock (atomically per cpu) */
+	tp->flags = (tp->flags & ~(IPIPE_TFLG_NMI_HIT |
+	                           IPIPE_TFLG_NMI_FREEZE_REQ))
+	                       | IPIPE_TFLG_NMI_LOCK;
+
+	/* check active_path again - some nasty NMI may have switched
+	 * it meanwhile */
+	if (unlikely(tp != &trace_paths[cpu_id][active_path[cpu_id]])) {
+		/* release lock on wrong path and restart */
+		tp->flags &= ~IPIPE_TFLG_NMI_LOCK;
+
+		/* there is no chance that the NMI got deferred
+		 * => no need to check for pending freeze requests */
+		goto restart;
+	}
+
+	/* get the point buffer */
+	pos = tp->trace_pos;
+	point = &tp->point[pos];
+
+	/* store all trace point data */
+	point->type = type;
+	point->flags = local_test_iflag_hw(flags) ? 0 : IPIPE_TFLG_HWIRQ_OFF;
+	point->eip = eip;
+	point->parent_eip = parent_eip;
+	point->v = v;
+	ipipe_read_tsc(point->timestamp);
+
+	__ipipe_store_domain_states(point, cpu_id);
+
+	/* forward to next point buffer */
+	next_pos = WRAP_POINT_NO(pos+1);
+	tp->trace_pos = next_pos;
+
+	/* only mark beginning if we haven't started yet */
+	begin = tp->begin;
+	if (unlikely(type == IPIPE_TRACE_BEGIN) && (begin < 0))
+		tp->begin = pos;
+
+	/* end of critical path, start post-trace if not already started */
+	if (unlikely(type == IPIPE_TRACE_END) &&
+	    (begin >= 0) && !tp->post_trace)
+		tp->post_trace = post_trace + 1;
+
+	/* freeze only if the slot is free and we are not already freezing */
+	if (unlikely(type == IPIPE_TRACE_FREEZE) &&
+	    (trace_paths[cpu_id][frozen_path[cpu_id]].begin < 0) &&
+	    !(tp->flags & IPIPE_TFLG_FREEZING)) {
+		tp->post_trace = post_trace + 1;
+		tp->flags |= IPIPE_TFLG_FREEZING;
+	}
+
+	/* enforce end of trace in case of overflow */
+	if (unlikely(WRAP_POINT_NO(next_pos + 1) == begin)) {
+		tp->end = pos;
+		goto enforce_end;
+	}
+
+	/* stop tracing this path if we are in post-trace and
+	 *  a) that phase is over now or
+	 *  b) a new TRACE_BEGIN came in but we are not freezing this path */
+	if (unlikely((tp->post_trace > 0) && ((--tp->post_trace == 0) ||
+	             ((type == IPIPE_TRACE_BEGIN) &&
+	              !(tp->flags & IPIPE_TFLG_FREEZING))))) {
+		/* store the path's end (i.e. excluding post-trace) */
+		tp->end = WRAP_POINT_NO(pos - post_trace + tp->post_trace);
+
+enforce_end:
+		if (tp->flags & IPIPE_TFLG_FREEZING)
+			tp = __ipipe_trace_freeze(cpu_id, tp, pos);
+		else
+			tp = __ipipe_trace_end(cpu_id, tp, pos);
+
+		/* reset the active path, maybe already start a new one */
+		tp->begin = (type == IPIPE_TRACE_BEGIN) ?
+			WRAP_POINT_NO(tp->trace_pos - 1) : -1;
+		tp->end = -1;
+		tp->post_trace = 0;
+		tp->flags = 0;
+
+		/* update active_path not earlier to avoid races with NMIs */
+		active_path[cpu_id] = tp - trace_paths[cpu_id];
+	}
+
+	/* we still have old_tp and point,
+	 * let's reset NMI lock and check for catches */
+	old_tp->flags &= ~IPIPE_TFLG_NMI_LOCK;
+	if (unlikely(old_tp->flags & IPIPE_TFLG_NMI_HIT)) {
+		/* well, this late tagging may not immediately be visible for
+		 * other cpus already dumping this path - a minor issue */
+		point->flags |= IPIPE_TFLG_NMI_HIT;
+
+		/* handle deferred freezing from NMI context */
+		if (old_tp->flags & IPIPE_TFLG_NMI_FREEZE_REQ)
+			__ipipe_trace(IPIPE_TRACE_FREEZE, old_tp->nmi_saved_eip,
+			              old_tp->nmi_saved_parent_eip,
+			              old_tp->nmi_saved_v);
+	}
+
+	local_irq_restore_hw_notrace(flags);
+}
+
+static unsigned long __ipipe_global_path_lock(void)
+{
+	unsigned long flags;
+	int cpu_id;
+	struct ipipe_trace_path *tp;
+
+	spin_lock_irqsave_hw(&global_path_lock, flags);
+
+	cpu_id = ipipe_processor_id();
+restart:
+	tp = &trace_paths[cpu_id][active_path[cpu_id]];
+
+	/* here is small race window with NMIs - catched below */
+
+	/* clear NMI events and set lock (atomically per cpu) */
+	tp->flags = (tp->flags & ~(IPIPE_TFLG_NMI_HIT |
+	                           IPIPE_TFLG_NMI_FREEZE_REQ))
+	                       | IPIPE_TFLG_NMI_LOCK;
+
+	/* check active_path again - some nasty NMI may have switched
+	 * it meanwhile */
+	if (tp != &trace_paths[cpu_id][active_path[cpu_id]]) {
+		/* release lock on wrong path and restart */
+		tp->flags &= ~IPIPE_TFLG_NMI_LOCK;
+
+		/* there is no chance that the NMI got deferred
+		 * => no need to check for pending freeze requests */
+		goto restart;
+	}
+
+	return flags;
+}
+
+static void __ipipe_global_path_unlock(unsigned long flags)
+{
+	int cpu_id;
+	struct ipipe_trace_path *tp;
+
+	/* release spinlock first - it's not involved in the NMI issue */
+	spin_unlock_hw(&global_path_lock);
+
+	cpu_id = ipipe_processor_id();
+	tp = &trace_paths[cpu_id][active_path[cpu_id]];
+
+	tp->flags &= ~IPIPE_TFLG_NMI_LOCK;
+
+	/* handle deferred freezing from NMI context */
+	if (tp->flags & IPIPE_TFLG_NMI_FREEZE_REQ)
+		__ipipe_trace(IPIPE_TRACE_FREEZE, tp->nmi_saved_eip,
+		              tp->nmi_saved_parent_eip, tp->nmi_saved_v);
+
+	local_irq_restore_hw(flags);
+}
+
+void notrace ipipe_trace_begin(unsigned long v)
+{
+	if (!ipipe_trace_enable)
+		return;
+	__ipipe_trace(IPIPE_TRACE_BEGIN, __BUILTIN_RETURN_ADDRESS0,
+	              __BUILTIN_RETURN_ADDRESS1, v);
+}
+EXPORT_SYMBOL(ipipe_trace_begin);
+
+void notrace ipipe_trace_end(unsigned long v)
+{
+	if (!ipipe_trace_enable)
+		return;
+	__ipipe_trace(IPIPE_TRACE_END, __BUILTIN_RETURN_ADDRESS0,
+	              __BUILTIN_RETURN_ADDRESS1, v);
+}
+EXPORT_SYMBOL(ipipe_trace_end);
+
+void notrace ipipe_trace_freeze(unsigned long v)
+{
+	if (!ipipe_trace_enable)
+		return;
+	__ipipe_trace(IPIPE_TRACE_FREEZE, __BUILTIN_RETURN_ADDRESS0,
+	              __BUILTIN_RETURN_ADDRESS1, v);
+}
+EXPORT_SYMBOL(ipipe_trace_freeze);
+
+void notrace ipipe_trace_special(unsigned char id, unsigned long v)
+{
+	if (!ipipe_trace_enable)
+		return;
+	__ipipe_trace(IPIPE_TRACE_SPECIAL | (id << IPIPE_TYPE_BITS),
+	              __BUILTIN_RETURN_ADDRESS0,
+	              __BUILTIN_RETURN_ADDRESS1, v);
+}
+EXPORT_SYMBOL(ipipe_trace_special);
+
+void notrace ipipe_trace_pid(pid_t pid, short prio)
+{
+	if (!ipipe_trace_enable)
+		return;
+	__ipipe_trace(IPIPE_TRACE_PID | (prio << IPIPE_TYPE_BITS),
+	              __BUILTIN_RETURN_ADDRESS0,
+	              __BUILTIN_RETURN_ADDRESS1, pid);
+}
+EXPORT_SYMBOL(ipipe_trace_pid);
+
+int ipipe_trace_max_reset(void)
+{
+	int cpu_id;
+	unsigned long flags;
+	struct ipipe_trace_path *path;
+	int ret = 0;
+
+	flags = __ipipe_global_path_lock();
+
+	for_each_cpu(cpu_id) {
+		path = &trace_paths[cpu_id][max_path[cpu_id]];
+
+		if (path->dump_lock) {
+			ret = -EBUSY;
+			break;
+		}
+
+		path->begin     = -1;
+		path->end       = -1;
+		path->trace_pos = 0;
+		path->length    = 0;
+	}
+
+	__ipipe_global_path_unlock(flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(ipipe_trace_max_reset);
+
+int ipipe_trace_frozen_reset(void)
+{
+	int cpu_id;
+	unsigned long flags;
+	struct ipipe_trace_path *path;
+	int ret = 0;
+
+	flags = __ipipe_global_path_lock();
+
+	for_each_cpu(cpu_id) {
+		path = &trace_paths[cpu_id][frozen_path[cpu_id]];
+
+		if (path->dump_lock) {
+			ret = -EBUSY;
+			break;
+		}
+
+		path->begin = -1;
+		path->end = -1;
+		path->trace_pos = 0;
+		path->length    = 0;
+	}
+
+	__ipipe_global_path_unlock(flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(ipipe_trace_frozen_reset);
+
+void ipipe_trace_panic_freeze(void)
+{
+	unsigned long flags;
+	int cpu_id;
+
+	ipipe_trace_enable = 0;
+	local_irq_save_hw_notrace(flags);
+
+	cpu_id = ipipe_processor_id();
+
+	panic_path = &trace_paths[cpu_id][active_path[cpu_id]];
+
+	local_irq_restore_hw(flags);
+}
+EXPORT_SYMBOL(ipipe_trace_panic_freeze);
+
+static void
+__ipipe_get_task_info(char *task_info, struct ipipe_trace_point *point,
+                      int trylock)
+{
+	struct task_struct *task = NULL;
+	char buf[8];
+	int i;
+	int locked = 1;
+
+	if (trylock && !read_trylock(&tasklist_lock))
+		locked = 0;
+	else
+		read_lock(&tasklist_lock);
+
+	if (locked)
+		task = find_task_by_pid((pid_t)point->v);
+
+	if (task)
+		strncpy(task_info, task->comm, 11);
+	else
+		strcpy(task_info, "-<?>-");
+
+	if (locked)
+		read_unlock(&tasklist_lock);
+
+	for (i = strlen(task_info); i < 11; i++)
+		task_info[i] = ' ';
+
+	sprintf(buf, " %d ", point->type >> IPIPE_TYPE_BITS);
+	strcpy(task_info + (11 - strlen(buf)), buf);
+}
+
+void ipipe_trace_panic_dump(void)
+{
+	int cnt = back_trace;
+	int start, pos;
+	char task_info[12];
+
+	printk("I-pipe tracer log (%d points):\n", cnt);
+
+	start = pos = WRAP_POINT_NO(panic_path->trace_pos-1);
+
+	while (cnt-- > 0) {
+		struct ipipe_trace_point *point = &panic_path->point[pos];
+		long time;
+		char buf[16];
+
+		if (!point->eip)
+			printk("-<invalid>-\n");
+		else {
+			__ipipe_trace_point_type(buf, point);
+			printk(buf);
+
+			switch (point->type & IPIPE_TYPE_MASK) {
+				case IPIPE_TRACE_FUNC:
+					printk("           ");
+					break;
+
+				case IPIPE_TRACE_PID:
+					__ipipe_get_task_info(task_info,
+					                      point, 1);
+					printk(task_info);
+					break;
+
+				default:
+					printk("0x%08lx ", point->v);
+			}
+
+			time = __ipipe_signed_tsc2us(point->timestamp -
+				panic_path->point[start].timestamp);
+			printk(" %5ld ", time);
+
+			__ipipe_print_symname(NULL, point->eip);
+			printk(" (");
+			__ipipe_print_symname(NULL, point->parent_eip);
+			printk(")\n");
+		}
+		pos = WRAP_POINT_NO(pos - 1);
+	}
+}
+EXPORT_SYMBOL(ipipe_trace_panic_dump);
+
+
+/* --- /proc output --- */
+
+static notrace int __ipipe_in_critical_trpath(long point_no)
+{
+	return ((WRAP_POINT_NO(point_no-print_path->begin) <
+	         WRAP_POINT_NO(print_path->end-print_path->begin)) ||
+	        ((print_path->end == print_path->begin) &&
+	         (WRAP_POINT_NO(point_no-print_path->end) >
+	          print_post_trace)));
+}
+
+static long __ipipe_signed_tsc2us(long long tsc)
+{
+        unsigned long long abs_tsc;
+        long us;
+
+	/* ipipe_tsc2us works on unsigned => handle sign separately */
+        abs_tsc = (tsc >= 0) ? tsc : -tsc;
+        us = ipipe_tsc2us(abs_tsc);
+        if (tsc < 0)
+                return -us;
+        else
+                return us;
+}
+
+static void
+__ipipe_trace_point_type(char *buf, struct ipipe_trace_point *point)
+{
+	switch (point->type & IPIPE_TYPE_MASK) {
+		case IPIPE_TRACE_FUNC:
+			strcpy(buf, "func    ");
+			break;
+
+		case IPIPE_TRACE_BEGIN:
+			strcpy(buf, "begin   ");
+			break;
+
+		case IPIPE_TRACE_END:
+			strcpy(buf, "end     ");
+			break;
+
+		case IPIPE_TRACE_FREEZE:
+			strcpy(buf, "freeze  ");
+			break;
+
+		case IPIPE_TRACE_SPECIAL:
+			sprintf(buf, "(0x%02x)  ",
+				point->type >> IPIPE_TYPE_BITS);
+			break;
+
+		case IPIPE_TRACE_PID:
+			sprintf(buf, "[%5d] ", (pid_t)point->v);
+			break;
+	}
+}
+
+static void
+__ipipe_print_pathmark(struct seq_file *m, struct ipipe_trace_point *point)
+{
+	char mark = ' ';
+	int point_no = point - print_path->point;
+	int i;
+
+	if (print_path->end == point_no)
+		mark = '<';
+	else if (print_path->begin == point_no)
+		mark = '>';
+	else if (__ipipe_in_critical_trpath(point_no))
+		mark = ':';
+	seq_printf(m, "%c%c", mark,
+	           (point->flags & IPIPE_TFLG_HWIRQ_OFF) ? '|' : ' ');
+
+	if (!verbose_trace)
+		return;
+
+	for (i = IPIPE_TFLG_DOMSTATE_BITS; i >= 0; i--)
+		seq_printf(m, "%c",
+			(IPIPE_TFLG_CURRENT_DOMAIN(point) == i) ?
+			    (IPIPE_TFLG_DOMAIN_STALLED(point, i) ?
+				'#' : '+') :
+			(IPIPE_TFLG_DOMAIN_STALLED(point, i) ? '*' : ' '));
+}
+
+static void
+__ipipe_print_delay(struct seq_file *m, struct ipipe_trace_point *point)
+{
+	unsigned long delay = 0;
+	int next;
+	char *mark = "  ";
+
+	next = WRAP_POINT_NO(point+1 - print_path->point);
+
+	if (next != print_path->trace_pos)
+		delay = ipipe_tsc2ns(print_path->point[next].timestamp -
+		                     point->timestamp);
+
+	if (__ipipe_in_critical_trpath(point - print_path->point)) {
+		if (delay > IPIPE_DELAY_WARN)
+			mark = "! ";
+		else if (delay > IPIPE_DELAY_NOTE)
+			mark = "+ ";
+	}
+	seq_puts(m, mark);
+
+	if (verbose_trace)
+		seq_printf(m, "%3lu.%03lu%c ", delay/1000, delay%1000,
+		           (point->flags & IPIPE_TFLG_NMI_HIT) ? 'N' : ' ');
+	else
+		seq_puts(m, " ");
+}
+
+static void __ipipe_print_symname(struct seq_file *m, unsigned long eip)
+{
+	char namebuf[KSYM_NAME_LEN+1];
+	unsigned long size, offset;
+	const char *sym_name;
+	char *modname;
+
+	sym_name = kallsyms_lookup(eip, &size, &offset, &modname, namebuf);
+
+	/* printing to /proc? */
+	if (m) {
+		if (sym_name) {
+			if (verbose_trace) {
+				seq_printf(m, "%s+0x%lx", sym_name, offset);
+				if (modname)
+					seq_printf(m, " [%s]", modname);
+			} else
+				seq_puts(m, sym_name);
+		} else
+			seq_printf(m, "<%08lx>", eip);
+	} else {
+		/* panic dump */
+		if (sym_name) {
+			printk("%s+0x%lx", sym_name, offset);
+			if (modname)
+				printk(" [%s]", modname);
+		}
+	}
+}
+
+#if defined(CONFIG_XENO_OPT_DEBUG) || defined(CONFIG_DEBUG_PREEMPT)
+static void __ipipe_print_dbgwarning(struct seq_file *m)
+{
+	seq_puts(m, "\n******** WARNING ********\n"
+		"The following debugging options will increase the observed "
+		"latencies:\n"
+#ifdef CONFIG_XENO_OPT_DEBUG
+		" o CONFIG_XENO_OPT_DEBUG\n"
+#endif /* CONFIG_XENO_OPT_DEBUG */
+#ifdef CONFIG_XENO_OPT_DEBUG_QUEUES
+		" o CONFIG_XENO_OPT_DEBUG_QUEUES (very costly)\n"
+#endif /* CONFIG_XENO_OPT_DEBUG */
+#ifdef CONFIG_DEBUG_PREEMPT
+		" o CONFIG_DEBUG_PREEMPT\n"
+#endif /* CONFIG_DEBUG_PREEMPT */
+		"\n");
+}
+#else /* !WARN_ON_DEBUGGING_LATENCIES */
+# define __ipipe_print_dbgwarning(m)
+#endif /* WARN_ON_DEBUGGING_LATENCIES */
+
+static void __ipipe_print_headline(struct seq_file *m)
+{
+	if (verbose_trace) {
+		const char *name[4] = { [0 ... 3] = "<unused>" };
+		struct list_head *pos;
+		int i = 0;
+
+		list_for_each_prev(pos, &__ipipe_pipeline) {
+			struct ipipe_domain *ipd =
+				list_entry(pos, struct ipipe_domain, p_link);
+
+			name[i] = ipd->name;
+			if (++i > 3)
+				break;
+		}
+
+		seq_printf(m,
+		           " +----- Hard IRQs ('|': locked)\n"
+		           " |+---- %s\n"
+		           " ||+--- %s\n"
+		           " |||+-- %s\n"
+		           " ||||+- %s%s\n"
+		           " |||||                        +---------- "
+		               "Delay flag ('+': > %d us, '!': > %d us)\n"
+		           " |||||                        |        +- "
+		               "NMI noise ('N')\n"
+		           " |||||                        |        |\n"
+		           "      Type    User Val.   Time    Delay  Function "
+		               "(Parent)\n",
+		           name[3], name[2], name[1], name[0],
+		           name[0] ? " ('*': domain stalled, '+': current, "
+		               "'#': current+stalled)" : "",
+		           IPIPE_DELAY_NOTE/1000, IPIPE_DELAY_WARN/1000);
+	} else
+		seq_printf(m,
+		           " +--------------- Hard IRQs ('|': locked)\n"
+		           " |             +- Delay flag "
+		               "('+': > %d us, '!': > %d us)\n"
+		           " |             |\n"
+		           "  Type     Time   Function (Parent)\n",
+		           IPIPE_DELAY_NOTE/1000, IPIPE_DELAY_WARN/1000);
+}
+
+static void *__ipipe_max_prtrace_start(struct seq_file *m, loff_t *pos)
+{
+	loff_t n = *pos;
+
+	down(&out_mutex);
+
+	if (!n) {
+		struct ipipe_trace_path *path;
+		unsigned long length_usecs;
+		int points, i;
+		unsigned long flags;
+
+		/* protect against max_path/frozen_path updates while we
+		 * haven't locked our target path, also avoid recursively
+		 * taking global_path_lock from NMI context */
+		flags = __ipipe_global_path_lock();
+
+		/* find the longest of all per-cpu paths */
+		print_path = NULL;
+		for_each_online_cpu(i) {
+			path = &trace_paths[i][max_path[i]];
+			if ((print_path == NULL) ||
+			    (path->length > print_path->length))
+				print_path = path;
+		}
+		print_path->dump_lock = 1;
+
+		__ipipe_global_path_unlock(flags);
+
+		/* does this path actually contain data? */
+		if (print_path->end == print_path->begin)
+			return NULL;
+
+		/* number of points inside the critical path */
+		points = WRAP_POINT_NO(print_path->end-print_path->begin+1);
+
+		/* pre- and post-tracing length, post-trace length was frozen
+		   in __ipipe_trace, pre-trace may have to be reduced due to
+		   buffer overrun */
+		print_pre_trace  = pre_trace;
+		print_post_trace = WRAP_POINT_NO(print_path->trace_pos -
+		                                 print_path->end - 1);
+		if (points+pre_trace+print_post_trace > IPIPE_TRACE_POINTS - 1)
+			print_pre_trace = IPIPE_TRACE_POINTS - 1 - points -
+				print_post_trace;
+
+		length_usecs = ipipe_tsc2us(print_path->length);
+		seq_printf(m, "I-pipe worst-case tracing service on %s/ipipe-%s\n"
+			"------------------------------------------------------------\n",
+			UTS_RELEASE, IPIPE_ARCH_STRING);
+		__ipipe_print_dbgwarning(m);
+		seq_printf(m, "Begin: %lld cycles, Trace Points: %d (-%d/+%d), "
+			"Length: %lu us\n\n",
+			print_path->point[print_path->begin].timestamp,
+			points, print_pre_trace, print_post_trace, length_usecs);
+		__ipipe_print_headline(m);
+	}
+
+	/* check if we are inside the trace range */
+	if (n >= WRAP_POINT_NO(print_path->end - print_path->begin + 1 +
+	                       print_pre_trace + print_post_trace))
+		return NULL;
+
+	/* return the next point to be shown */
+	return &print_path->point[WRAP_POINT_NO(print_path->begin -
+	                                        print_pre_trace + n)];
+}
+
+static void *__ipipe_prtrace_next(struct seq_file *m, void *p, loff_t *pos)
+{
+	loff_t n = ++*pos;
+
+	/* check if we are inside the trace range with the next entry */
+	if (n >= WRAP_POINT_NO(print_path->end - print_path->begin + 1 +
+	                       print_pre_trace + print_post_trace))
+		return NULL;
+
+	/* return the next point to be shown */
+	return &print_path->point[WRAP_POINT_NO(print_path->begin -
+	                                        print_pre_trace + *pos)];
+}
+
+static void __ipipe_prtrace_stop(struct seq_file *m, void *p)
+{
+	if (print_path)
+		print_path->dump_lock = 0;
+	up(&out_mutex);
+}
+
+static int __ipipe_prtrace_show(struct seq_file *m, void *p)
+{
+	long time;
+	struct ipipe_trace_point *point = p;
+	char buf[16];
+
+	if (!point->eip) {
+		seq_puts(m, "-<invalid>-\n");
+		return 0;
+	}
+
+	__ipipe_print_pathmark(m, point);
+	__ipipe_trace_point_type(buf, point);
+	seq_puts(m, buf);
+	if (verbose_trace)
+		switch (point->type & IPIPE_TYPE_MASK) {
+			case IPIPE_TRACE_FUNC:
+				seq_puts(m, "           ");
+				break;
+
+			case IPIPE_TRACE_PID:
+				__ipipe_get_task_info(buf, point, 0);
+				seq_puts(m, buf);
+				break;
+
+			default:
+				seq_printf(m, "0x%08lx ", point->v);
+		}
+
+	time = __ipipe_signed_tsc2us(point->timestamp -
+		print_path->point[print_path->begin].timestamp);
+	seq_printf(m, "%5ld", time);
+
+	__ipipe_print_delay(m, point);
+	__ipipe_print_symname(m, point->eip);
+	seq_puts(m, " (");
+	__ipipe_print_symname(m, point->parent_eip);
+	seq_puts(m, ")\n");
+
+	return 0;
+}
+
+static struct seq_operations __ipipe_max_ptrace_ops = {
+	.start = __ipipe_max_prtrace_start,
+	.next  = __ipipe_prtrace_next,
+	.stop  = __ipipe_prtrace_stop,
+	.show  = __ipipe_prtrace_show
+};
+
+static int __ipipe_max_prtrace_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &__ipipe_max_ptrace_ops);
+}
+
+static ssize_t
+__ipipe_max_reset(struct file *file, const char __user *pbuffer,
+                  size_t count, loff_t *data)
+{
+	down(&out_mutex);
+	ipipe_trace_max_reset();
+	up(&out_mutex);
+
+	return count;
+}
+
+struct file_operations __ipipe_max_prtrace_fops = {
+	.open       = __ipipe_max_prtrace_open,
+	.read       = seq_read,
+	.write      = __ipipe_max_reset,
+	.llseek     = seq_lseek,
+	.release    = seq_release,
+};
+
+static void *__ipipe_frozen_prtrace_start(struct seq_file *m, loff_t *pos)
+{	
+	loff_t n = *pos;
+
+	down(&out_mutex);
+
+	if (!n) {
+		struct ipipe_trace_path *path;
+		int i;
+		unsigned long flags;
+
+		/* protect against max_path/frozen_path updates while we
+		 * haven't locked our target path, also avoid recursively
+		 * taking global_path_lock from NMI context */
+		flags = __ipipe_global_path_lock();
+
+		/* find the first of all per-cpu frozen paths */
+		print_path = NULL;
+		for_each_online_cpu(i) {
+			path = &trace_paths[i][frozen_path[i]];
+			if (path->end >= 0)
+				print_path = path;
+		}
+		if (print_path)
+			print_path->dump_lock = 1;
+
+		__ipipe_global_path_unlock(flags);
+
+		if (!print_path)
+			return NULL;
+
+		/* back- and post-tracing length, post-trace length was frozen
+		   in __ipipe_trace, back-trace may have to be reduced due to
+		   buffer overrun */
+		print_pre_trace  = back_trace-1; /* substract freeze point */
+		print_post_trace = WRAP_POINT_NO(print_path->trace_pos -
+		                                 print_path->end - 1);
+		if (1+pre_trace+print_post_trace > IPIPE_TRACE_POINTS - 1)
+			print_pre_trace = IPIPE_TRACE_POINTS - 2 -
+				print_post_trace;
+
+		seq_printf(m, "I-pipe frozen back-tracing service on %s/ipipe-%s\n"
+			"------------------------------------------------------"
+			"------\n",
+			UTS_RELEASE, IPIPE_ARCH_STRING);
+		__ipipe_print_dbgwarning(m);
+		seq_printf(m, "Freeze: %lld cycles, Trace Points: %d (+%d)\n\n",
+			print_path->point[print_path->begin].timestamp,
+			print_pre_trace+1, print_post_trace);
+		__ipipe_print_headline(m);
+	}
+
+	/* check if we are inside the trace range */
+	if (n >= print_pre_trace + 1 + print_post_trace)
+		return NULL;
+
+	/* return the next point to be shown */
+	return &print_path->point[WRAP_POINT_NO(print_path->begin-
+	                                        print_pre_trace+n)];
+}
+
+static struct seq_operations __ipipe_frozen_ptrace_ops = {
+	.start = __ipipe_frozen_prtrace_start,
+	.next  = __ipipe_prtrace_next,
+	.stop  = __ipipe_prtrace_stop,
+	.show  = __ipipe_prtrace_show
+};
+
+static int __ipipe_frozen_prtrace_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &__ipipe_frozen_ptrace_ops);
+}
+
+static ssize_t
+__ipipe_frozen_ctrl(struct file *file, const char __user *pbuffer,
+                    size_t count, loff_t *data)
+{
+	char *end, buf[16];
+	int val;
+	int n;
+
+	n = (count > sizeof(buf) - 1) ? sizeof(buf) - 1 : count;
+
+	if (copy_from_user(buf, pbuffer, n))
+		return -EFAULT;
+
+	buf[n] = '\0';
+	val = simple_strtol(buf, &end, 0);
+
+	if (((*end != '\0') && !isspace(*end)) || (val < 0))
+		return -EINVAL;
+
+	down(&out_mutex);
+	ipipe_trace_frozen_reset();
+	if (val > 0)
+		ipipe_trace_freeze(-1);
+	up(&out_mutex);
+
+	return count;
+}
+
+struct file_operations __ipipe_frozen_prtrace_fops = {
+	.open       = __ipipe_frozen_prtrace_open,
+	.read       = seq_read,
+	.write      = __ipipe_frozen_ctrl,
+	.llseek     = seq_lseek,
+	.release    = seq_release,
+};
+
+static int __ipipe_rd_proc_val(char *page, char **start, off_t off,
+                               int count, int *eof, void *data)
+{
+	int len;
+
+	len = sprintf(page, "%u\n", *(int *)data);
+	len -= off;
+	if (len <= off + count)
+		*eof = 1;
+	*start = page + off;
+	if (len > count)
+		len = count;
+	if (len < 0)
+		len = 0;
+
+	return len;
+}
+
+static int __ipipe_wr_proc_val(struct file *file, const char __user *buffer,
+                               unsigned long count, void *data)
+{
+	char *end, buf[16];
+	int val;
+	int n;
+
+	n = (count > sizeof(buf) - 1) ? sizeof(buf) - 1 : count;
+
+	if (copy_from_user(buf, buffer, n))
+		return -EFAULT;
+
+	buf[n] = '\0';
+	val = simple_strtol(buf, &end, 0);
+
+	if (((*end != '\0') && !isspace(*end)) || (val < 0))
+		return -EINVAL;
+
+	down(&out_mutex);
+	*(int *)data = val;
+	up(&out_mutex);
+
+	return count;
+}
+
+extern struct proc_dir_entry *ipipe_proc_root;
+
+static void __init
+__ipipe_create_trace_proc_val(struct proc_dir_entry *trace_dir,
+                              const char *name, int *value_ptr)
+{
+	struct proc_dir_entry *entry;
+
+	entry = create_proc_entry(name, 0644, trace_dir);
+	if (entry) {
+		entry->data = value_ptr;
+		entry->read_proc = __ipipe_rd_proc_val;
+		entry->write_proc = __ipipe_wr_proc_val;
+		entry->owner = THIS_MODULE;
+	}
+}
+
+void __init __ipipe_init_tracer(void)
+{
+	struct proc_dir_entry *trace_dir;
+	struct proc_dir_entry *entry;
+#ifdef CONFIG_IPIPE_TRACE_VMALLOC
+	int cpu, path;
+
+	for (cpu = 0; cpu < NR_CPUS; cpu++) {
+		trace_paths[cpu] = vmalloc(
+			sizeof(struct ipipe_trace_path) * IPIPE_TRACE_PATHS);
+		if (!trace_paths) {
+			printk(KERN_ERR "I-pipe: "
+			       "insufficient memory for trace buffer.\n");
+			return;
+		}
+		memset(trace_paths[cpu], 0,
+			sizeof(struct ipipe_trace_path) * IPIPE_TRACE_PATHS);
+		for (path = 0; path < IPIPE_TRACE_PATHS; path++) {
+			trace_paths[cpu][path].begin = -1;
+			trace_paths[cpu][path].end   = -1;
+		}
+	}
+#endif /* CONFIG_IPIPE_TRACE_VMALLOC */
+	ipipe_trace_enable = CONFIG_IPIPE_TRACE_ENABLE_VALUE;
+
+	trace_dir = create_proc_entry("trace", S_IFDIR, ipipe_proc_root);
+
+	entry = create_proc_entry("max", 0644, trace_dir);
+	if (entry)
+		entry->proc_fops = &__ipipe_max_prtrace_fops;
+
+	entry = create_proc_entry("frozen", 0644, trace_dir);
+	if (entry)
+		entry->proc_fops = &__ipipe_frozen_prtrace_fops;
+
+	__ipipe_create_trace_proc_val(trace_dir, "pre_trace_points",
+	                              &pre_trace);
+	__ipipe_create_trace_proc_val(trace_dir, "post_trace_points",
+	                              &post_trace);
+	__ipipe_create_trace_proc_val(trace_dir, "back_trace_points",
+	                              &back_trace);
+	__ipipe_create_trace_proc_val(trace_dir, "verbose",
+	                              &verbose_trace);
+	__ipipe_create_trace_proc_val(trace_dir, "enable",
+	                              &ipipe_trace_enable);
+}
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/kernel/irq/handle.c ipipe-2.6.14-imx21/kernel/irq/handle.c
--- linux-2.6.14/kernel/irq/handle.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/kernel/irq/handle.c	2008-02-21 22:09:03.000000000 +0100
@@ -81,6 +81,17 @@ fastcall int handle_IRQ_event(unsigned i
 {
 	int ret, retval = 0, status = 0;
 
+#ifdef CONFIG_IPIPE
+	/*
+	 * If processing a timer tick, pass the original regs as
+	 * collected during preemption and not our phony - always
+	 * kernel-originated - frame, so that we don't wreck the
+	 * profiling code.
+	 */
+	if (__ipipe_tick_irq == irq)
+		regs = __ipipe_tick_regs + smp_processor_id();
+#endif /* CONFIG_IPIPE */
+
 	if (!(action->flags & SA_INTERRUPT))
 		local_irq_enable();
 
@@ -117,14 +128,18 @@ fastcall unsigned int __do_IRQ(unsigned 
 		/*
 		 * No locking required for CPU-local interrupts:
 		 */
+#ifndef CONFIG_IPIPE
 		desc->handler->ack(irq);
+#endif /* CONFIG_IPIPE */
 		action_ret = handle_IRQ_event(irq, regs, desc->action);
 		desc->handler->end(irq);
 		return 1;
 	}
 
 	spin_lock(&desc->lock);
+#ifndef CONFIG_IPIPE
 	desc->handler->ack(irq);
+#endif /* CONFIG_IPIPE */
 	/*
 	 * REPLAY is when Linux resends an IRQ that was dropped earlier
 	 * WAITING is used by probe to mark irqs that are being tested
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/kernel/printk.c ipipe-2.6.14-imx21/kernel/printk.c
--- linux-2.6.14/kernel/printk.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/kernel/printk.c	2008-02-21 22:09:03.000000000 +0100
@@ -507,6 +507,78 @@ __attribute__((weak)) unsigned long long
  * is inspected when the actual printing occurs.
  */
 
+#ifdef CONFIG_IPIPE
+
+static ipipe_spinlock_t __ipipe_printk_lock = IPIPE_SPIN_LOCK_UNLOCKED;
+
+static int __ipipe_printk_fill;
+
+static char __ipipe_printk_buf[__LOG_BUF_LEN];
+
+void __ipipe_flush_printk (unsigned virq, void *cookie)
+{
+	char *p = __ipipe_printk_buf;
+	int len, lmax, out = 0;
+	unsigned long flags;
+
+	goto start;
+
+	do {
+		spin_unlock_irqrestore_hw(&__ipipe_printk_lock,flags);
+ start:
+		lmax = __ipipe_printk_fill;
+		while (out < lmax) {
+			len = strlen(p) + 1;
+			printk("%s",p);
+			p += len;
+			out += len;
+		}
+		spin_lock_irqsave_hw(&__ipipe_printk_lock,flags);
+	}
+	while (__ipipe_printk_fill != lmax);
+
+	__ipipe_printk_fill = 0;
+
+	spin_unlock_irqrestore_hw(&__ipipe_printk_lock,flags);
+}
+
+asmlinkage int printk(const char *fmt, ...)
+{
+	int r, fbytes, oldcount;
+    	unsigned long flags;
+	va_list args;
+
+	va_start(args, fmt);
+
+	if (ipipe_current_domain == ipipe_root_domain ||
+	    test_bit(IPIPE_SPRINTK_FLAG,&ipipe_current_domain->flags) ||
+	    oops_in_progress) {
+		r = vprintk(fmt, args);
+		goto out;
+	}
+
+	spin_lock_irqsave_hw(&__ipipe_printk_lock,flags);
+
+	oldcount = __ipipe_printk_fill;
+	fbytes = __LOG_BUF_LEN - oldcount;
+
+	if (fbytes > 1)	{
+		r = vscnprintf(__ipipe_printk_buf + __ipipe_printk_fill,
+			       fbytes, fmt, args) + 1; /* account for the null byte */
+		__ipipe_printk_fill += r;
+	} else
+		r = 0;
+
+	spin_unlock_irqrestore_hw(&__ipipe_printk_lock,flags);
+
+	if (oldcount == 0)
+		ipipe_trigger_irq(__ipipe_printk_virq);
+out: 
+	va_end(args);
+
+	return r;
+}
+#else /* !CONFIG_IPIPE */
 asmlinkage int printk(const char *fmt, ...)
 {
 	va_list args;
@@ -518,6 +590,7 @@ asmlinkage int printk(const char *fmt, .
 
 	return r;
 }
+#endif /* CONFIG_IPIPE */
 
 /* cpu currently holding logbuf_lock */
 static volatile unsigned int printk_cpu = UINT_MAX;
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/kernel/sched.c ipipe-2.6.14-imx21/kernel/sched.c
--- linux-2.6.14/kernel/sched.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/kernel/sched.c	2008-02-21 22:09:03.000000000 +0100
@@ -1154,7 +1154,7 @@ static int try_to_wake_up(task_t *p, uns
 
 	rq = task_rq_lock(p, &flags);
 	old_state = p->state;
-	if (!(old_state & state))
+	if (!(old_state & state) || (old_state & TASK_NOWAKEUP))
 		goto out;
 
 	if (p->array)
@@ -1556,6 +1556,8 @@ asmlinkage void schedule_tail(task_t *pr
 #endif
 	if (current->set_child_tid)
 		put_user(current->pid, current->set_child_tid);
+
+	ipipe_init_notify(current);
 }
 
 /*
@@ -2855,13 +2857,17 @@ asmlinkage void __sched schedule(void)
 	unsigned long run_time;
 	int cpu, idx, new_prio;
 
+#ifdef CONFIG_IPIPE
+	if (unlikely(!ipipe_root_domain_p))
+		return;
+#endif /* CONFIG_IPIPE */
 	/*
 	 * Test if we are atomic.  Since do_exit() needs to call into
 	 * schedule() atomically, we ignore that path for now.
 	 * Otherwise, whine if we are scheduling when we should not be.
 	 */
 	if (likely(!current->exit_state)) {
-		if (unlikely(in_atomic())) {
+		if (unlikely(!(current->state & TASK_ATOMICSWITCH) && in_atomic())) {
 			printk(KERN_ERR "scheduling while atomic: "
 				"%s/0x%08x/%d\n",
 				current->comm, preempt_count(), current->pid);
@@ -2870,8 +2876,13 @@ asmlinkage void __sched schedule(void)
 	}
 	profile_hit(SCHED_PROFILING, __builtin_return_address(0));
 
+	if (unlikely(current->state & TASK_ATOMICSWITCH)) {
+		current->state &= ~TASK_ATOMICSWITCH;
+		goto need_resched_nodisable;
+	}
 need_resched:
 	preempt_disable();
+need_resched_nodisable:
 	prev = current;
 	release_kernel_lock(prev);
 need_resched_nonpreemptible:
@@ -3010,6 +3021,8 @@ switch_tasks:
 		prepare_task_switch(rq, next);
 		prev = context_switch(rq, prev, next);
 		barrier();
+ 		if (task_hijacked(prev))
+ 		    return;
 		/*
 		 * this_rq must be evaluated again because prev may have moved
 		 * CPUs since it called schedule(), thus the 'rq' on its stack
@@ -3023,7 +3036,7 @@ switch_tasks:
 	if (unlikely(reacquire_kernel_lock(prev) < 0))
 		goto need_resched_nonpreemptible;
 	preempt_enable_no_resched();
-	if (unlikely(test_thread_flag(TIF_NEED_RESCHED)))
+	if (unlikely(test_thread_flag(TIF_NEED_RESCHED) && ipipe_root_domain_p))
 		goto need_resched;
 }
 
@@ -3042,6 +3055,11 @@ asmlinkage void __sched preempt_schedule
 	struct task_struct *task = current;
 	int saved_lock_depth;
 #endif
+#ifdef CONFIG_IPIPE
+	/* Do not reschedule over non-Linux domains. */
+	if (unlikely(!ipipe_root_domain_p))
+		return;
+#endif /* CONFIG_IPIPE */
 	/*
 	 * If there is a non-zero preempt_count or interrupts are disabled,
 	 * we do not want to preempt the current task.  Just return..
@@ -3670,6 +3688,7 @@ recheck:
 		deactivate_task(p, rq);
 	oldprio = p->prio;
 	__setscheduler(p, policy, param->sched_priority);
+	ipipe_setsched_notify(p);
 	if (array) {
 		__activate_task(p, rq);
 		/*
@@ -5647,3 +5666,50 @@ void set_curr_task(int cpu, task_t *p)
 }
 
 #endif
+
+#ifdef CONFIG_IPIPE
+
+int ipipe_setscheduler_root (struct task_struct *p, int policy, int prio)
+{
+	prio_array_t *array;
+	unsigned long flags;
+	runqueue_t *rq;
+	int oldprio;
+
+	rq = task_rq_lock(p, &flags);
+	array = p->array;
+	if (array)
+		deactivate_task(p, rq);
+	oldprio = p->prio;
+	__setscheduler(p, policy, prio);
+	if (array) {
+		__activate_task(p, rq);
+		if (task_running(rq, p)) {
+			if (p->prio > oldprio)
+				resched_task(rq->curr);
+		} else if (TASK_PREEMPTS_CURR(p, rq))
+			resched_task(rq->curr);
+	}
+	task_rq_unlock(rq, &flags);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(ipipe_setscheduler_root);
+
+int ipipe_reenter_root (struct task_struct *prev, int policy, int prio)
+{
+	finish_task_switch(this_rq(), prev);
+	if (reacquire_kernel_lock(current) < 0)
+		;
+	preempt_enable_no_resched();
+
+	if (current->policy != policy || current->rt_priority != prio)
+		return ipipe_setscheduler_root(current,policy,prio);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(ipipe_reenter_root);
+
+#endif /* CONFIG_IPIPE */
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/kernel/signal.c ipipe-2.6.14-imx21/kernel/signal.c
--- linux-2.6.14/kernel/signal.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/kernel/signal.c	2008-02-21 22:09:03.000000000 +0100
@@ -601,6 +601,7 @@ void signal_wake_up(struct task_struct *
 	unsigned int mask;
 
 	set_tsk_thread_flag(t, TIF_SIGPENDING);
+	ipipe_sigwake_notify(t); /* TIF_SIGPENDING must be set first. */
 
 	/*
 	 * For SIGKILL, we want to wake it up in the stopped/traced case.
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/lib/Kconfig.debug ipipe-2.6.14-imx21/lib/Kconfig.debug
--- linux-2.6.14/lib/Kconfig.debug	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/lib/Kconfig.debug	2008-02-21 22:09:03.000000000 +0100
@@ -9,6 +9,8 @@ config PRINTK_TIME
 	  in kernel startup.
 
 
+source "kernel/ipipe/Kconfig.debug"
+
 config DEBUG_KERNEL
 	bool "Kernel debugging"
 	help
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/lib/smp_processor_id.c ipipe-2.6.14-imx21/lib/smp_processor_id.c
--- linux-2.6.14/lib/smp_processor_id.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/lib/smp_processor_id.c	2008-02-21 22:09:03.000000000 +0100
@@ -12,6 +12,11 @@ unsigned int debug_smp_processor_id(void
 	int this_cpu = raw_smp_processor_id();
 	cpumask_t this_mask;
 
+#ifdef CONFIG_IPIPE
+ 	if (ipipe_current_domain != ipipe_root_domain)
+	    return this_cpu;
+#endif /* CONFIG_IPIPE */
+
 	if (likely(preempt_count))
 		goto out;
 
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/lib/spinlock_debug.c ipipe-2.6.14-imx21/lib/spinlock_debug.c
--- linux-2.6.14/lib/spinlock_debug.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/lib/spinlock_debug.c	2008-02-21 22:09:03.000000000 +0100
@@ -10,6 +10,7 @@
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
+#include <linux/module.h>
 
 static void spin_bug(spinlock_t *lock, const char *msg)
 {
@@ -93,6 +94,8 @@ void _raw_spin_lock(spinlock_t *lock)
 	debug_spin_lock_after(lock);
 }
 
+EXPORT_SYMBOL(_raw_spin_lock);
+
 int _raw_spin_trylock(spinlock_t *lock)
 {
 	int ret = __raw_spin_trylock(&lock->raw_lock);
@@ -108,12 +111,16 @@ int _raw_spin_trylock(spinlock_t *lock)
 	return ret;
 }
 
+EXPORT_SYMBOL(_raw_spin_trylock);
+
 void _raw_spin_unlock(spinlock_t *lock)
 {
 	debug_spin_unlock(lock);
 	__raw_spin_unlock(&lock->raw_lock);
 }
 
+EXPORT_SYMBOL(_raw_spin_unlock);
+
 static void rwlock_bug(rwlock_t *lock, const char *msg)
 {
 	static long print_once = 1;
@@ -162,6 +169,8 @@ void _raw_read_lock(rwlock_t *lock)
 		__read_lock_debug(lock);
 }
 
+EXPORT_SYMBOL(_raw_read_lock);
+
 int _raw_read_trylock(rwlock_t *lock)
 {
 	int ret = __raw_read_trylock(&lock->raw_lock);
@@ -175,12 +184,16 @@ int _raw_read_trylock(rwlock_t *lock)
 	return ret;
 }
 
+EXPORT_SYMBOL(_raw_read_trylock);
+
 void _raw_read_unlock(rwlock_t *lock)
 {
 	RWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, "bad magic");
 	__raw_read_unlock(&lock->raw_lock);
 }
 
+EXPORT_SYMBOL(_raw_read_unlock);
+
 static inline void debug_write_lock_before(rwlock_t *lock)
 {
 	RWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, "bad magic");
@@ -235,6 +248,8 @@ void _raw_write_lock(rwlock_t *lock)
 	debug_write_lock_after(lock);
 }
 
+EXPORT_SYMBOL(_raw_write_lock);
+
 int _raw_write_trylock(rwlock_t *lock)
 {
 	int ret = __raw_write_trylock(&lock->raw_lock);
@@ -250,8 +265,12 @@ int _raw_write_trylock(rwlock_t *lock)
 	return ret;
 }
 
+EXPORT_SYMBOL(_raw_write_trylock);
+
 void _raw_write_unlock(rwlock_t *lock)
 {
 	debug_write_unlock(lock);
 	__raw_write_unlock(&lock->raw_lock);
 }
+
+EXPORT_SYMBOL(_raw_write_unlock);
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/mm/memory.c ipipe-2.6.14-imx21/mm/memory.c
--- linux-2.6.14/mm/memory.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/mm/memory.c	2008-02-21 22:09:03.000000000 +0100
@@ -48,6 +48,7 @@
 #include <linux/rmap.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/vmalloc.h>
 
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
diff -Naurdp -x '*~' -x '*.orig' -x '*.rej' linux-2.6.14/mm/vmalloc.c ipipe-2.6.14-imx21/mm/vmalloc.c
--- linux-2.6.14/mm/vmalloc.c	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/mm/vmalloc.c	2008-02-21 22:09:03.000000000 +0100
@@ -18,6 +18,7 @@
 
 #include <asm/uaccess.h>
 #include <asm/tlbflush.h>
+#include <asm/pgalloc.h>
 
 
 DEFINE_RWLOCK(vmlist_lock);
@@ -148,10 +149,14 @@ int map_vm_area(struct vm_struct *area, 
 	pgd = pgd_offset_k(addr);
 	spin_lock(&init_mm.page_table_lock);
 	do {
+		pgd_t oldpgd;
+		memcpy(&oldpgd,pgd,sizeof(pgd_t));
 		next = pgd_addr_end(addr, end);
 		err = vmap_pud_range(pgd, addr, next, prot, pages);
 		if (err)
 			break;
+		if (pgd_val(oldpgd) != pgd_val(*pgd))
+			set_pgdir(addr, *pgd);
 	} while (pgd++, addr = next, addr != end);
 	spin_unlock(&init_mm.page_table_lock);
 	flush_cache_vmap((unsigned long) area->addr, end);
