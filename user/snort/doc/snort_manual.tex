% $Id$
% 
% BUILDING HTML VERSION:
% latex2html -info 0 -local_icons -show_section_numbers -link +2 -split +2 -noaddress snort_manual.tex
%
% BUILDING PDF VERSION:
% pdflatex snort_manual.tex

\documentclass[english]{report}
%\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{geometry}
\usepackage{longtable}
\geometry{verbose,letterpaper,tmargin=1in,bmargin=.5in,lmargin=1in,rmargin=1in}
\IfFileExists{url.sty}{\usepackage{url}}
                      {\newcommand{\url}{\texttt}}



% \makeatletter

\newcounter{slistnum}
\newcounter{subslistnum}
\newcounter{subsublistnum}

\newenvironment{slist}
{ \begin{list}{ {\bf \arabic{slistnum}.} }{\usecounter{slistnum} } }
{ \end{list} }

\newenvironment{subslist}
{ \begin{list} { {\bf \arabic{slistnum}-\Alph{subslistnum}. } }
        {\usecounter{subslistnum} }   }
{ \end{list} }

\newenvironment{subsubslist} {
    \begin{list}{ 
        {\bf \arabic{slistnum}-\arabic{subslistnum}-\arabic{subsublistnum}. } 
    }{
        \usecounter{subsubslistnum} 
    }   
}{
    \end{list}
}

\newsavebox{\savepar}
\newenvironment{note}{
\samepage
    \vspace{10pt}{\textsf{
        {\hspace{7pt}\Huge{$\triangle$\hspace{-12.5pt}{\Large{$^!$}}}}\hspace{5pt}
        {\Large{NOTE}}
    }
    }
   \begin{center}
    \par\vspace{-17pt}

    \begin{lrbox}{\savepar}
    \begin{minipage}[r]{6in}
}
{
    \end{minipage}
    \end{lrbox}
    \fbox{
        \usebox{
            \savepar
        }
    }
    \par\vskip10pt
    \end{center}
}

\usepackage{babel}

% \makeatother

\addtolength{\parindent}{-5mm}
\addtolength{\parskip}{2mm}

%\renewcommand\floatpagefraction{.9}
%\renewcommand\topfraction{.9}
%\renewcommand\bottomfraction{.9}
%\renewcommand\textfraction{.1}   
%\setcounter{totalnumber}{50}
%\setcounter{topnumber}{50}
%\setcounter{bottomnumber}{50}

\begin{document}

\title{Snort\texttrademark  Users Manual\\  2.3.3 }

\author{The Snort Project}

\maketitle

\newpage

Copyright \copyright 1998-2003 Martin Roesch

Copyright \copyright 2001-2003 Chris Green

Copyright \copyright 2003-2005 Sourcefire, Inc.

\tableofcontents{}


\chapter{Snort Overview}

This manual is based on \emph{Writing Snort Rules} by Martin Roesch and
further work from Chris Green $<$cmg@snort.org$>$.  It is now maintained by Brian
Caswell $<$bmc@snort.org$>$ and Jeremy Hewlett $<$jh@snort.org$>$.  If you have a
better way to say something or find that something in the documentation is outdated, drop
us a line and we will update it.  If you would like to submit patches for this
document, you can find the latest version of the documentation in \LaTeX\ 
format in the Snort CVS repository at \verb!/doc/snort_manual.tex!.  Small documentation updates are 
the easiest way to help out the Snort Project.

\section{Getting Started}

Snort really isn't very hard to use, but there are a lot of command line
options to play with, and it's not always obvious which ones go together well.
This file aims to make using Snort easier for new users.

Before we proceed, there are a few basic concepts you should understand about
Snort. Snort can be configured to run in three modes:
\begin{itemize}
\item {\em Sniffer mode,} which simply reads the packets off of the network and displays them 
for you in a continuous stream on the console (screen). 
\item {\em Packet Logger mode,} which logs the packets to disk. 
\item {\em Network Intrusion Detection System (NIDS) mode,} the most complex and configurable configuration,
which allows Snort to analyze network traffic for matches against a user-defined
rule set and performs several actions based upon what it sees.
\item {\em Inline Mode,} which obtains packets from iptables instead of from libpcap and then
causes iptables to drop or pass packets based on Snort rules that use inline-specific rule types.
\end{itemize}

\section{Sniffer Mode}

First, let's start with the basics. If you just want to print out
the TCP/IP packet headers to the screen (i.e. sniffer mode), try this:

\begin{verbatim}
./snort -v
\end{verbatim}
This command will run Snort and just show the IP and TCP/UDP/ICMP
headers, nothing else. If you want to see the application data in
transit, try the following:

\begin{verbatim}
./snort -vd
\end{verbatim}
This instructs Snort to display the packet data as well as the headers.
If you want an even more descriptive display, showing the data link
layer headers, do this:

\begin{verbatim}
./snort -vde
\end{verbatim}
(As an aside, these switches may be divided up or smashed together
in any combination. The last command could also be typed out as:

\begin{verbatim}
./snort -d -v -e
\end{verbatim}
and it would do the same thing.)


\section{Packet Logger Mode}

OK, all of these commands are pretty cool, but if you want to record
the packets to the disk, you need to specify a logging directory and
Snort will automatically know to go into packet logger mode:

\begin{verbatim}
./snort -dev -l ./log
\end{verbatim}
Of course, this assumes you have a directory named \verb!log!
in the current directory. If you don't, Snort will exit with an error
message. When Snort runs in this mode, it collects every packet it
sees and places it in a directory hierarchy based upon the IP address
of one of the hosts in the datagram.

If you just specify a plain -l switch, you may
notice that Snort sometimes uses the address of the remote computer
as the directory in which it places packets and sometimes it uses
the local host address. In order to log relative to the home network,
you need to tell Snort which network is the home network:

\begin{verbatim}
./snort -dev -l ./log -h 192.168.1.0/24
\end{verbatim}
This rule tells Snort that you want to print out the data link and
TCP/IP headers as well as application data into the directory \verb!./log!,
and you want to log the packets relative to the 192.168.1.0 class
C network. All incoming packets will be recorded into subdirectories
of the log directory, with the directory names being based on the
address of the remote (non-192.168.1) host. 

\begin{note}
Note that if both the source and destination hosts are on the home 
network, they are logged to a directory with a name based on the higher 
of the two port numbers or, in the case of a tie, the source address.
\end{note}

If you're on a high speed network or you want to log the packets into
a more compact form for later analysis, you should consider logging
in binary mode. Binary mode logs the packets in
tcpdump format to a single binary file in the
logging directory:

\begin{verbatim}
./snort -l ./log -b
\end{verbatim}
Note the command line changes here. We don't need to specify a home
network any longer because binary mode logs everything into a single
file, which eliminates the need to tell it how to format the output
directory structure. Additionally, you don't need to run in verbose
mode or specify the -d or -e switches because in binary mode the entire
packet is logged, not just sections of it. All you really need to do
to place Snort into logger mode is to specify a logging
directory at the command line using the -l switch---the -b binary logging
switch merely provides a modifier that tells Snort to log the packets in
something other than the default output format of plain ASCII text.

Once the packets have been logged to the binary file, you can read
the packets back out of the file with any sniffer that supports the
tcpdump binary format (such as tcpdump or Ethereal). Snort can also
read the packets back by using the -r switch, which puts it into playback
mode. Packets from any tcpdump formatted file can be processed through
Snort in any of its run modes. For example, if you wanted to run a
binary log file through Snort in sniffer mode to dump the packets
to the screen, you can try something like this:

\begin{verbatim}
./snort -dv -r packet.log
\end{verbatim}
You can manipulate the data in the file in a number of ways through
Snort's packet logging and intrusion detection modes, as well as with
the BPF interface that's available from the command line. For example,
if you only wanted to see the ICMP packets from the log file, simply
specify a BPF filter at the command line and Snort will only see
the ICMP packets in the file:

\begin{verbatim}
./snort -dvr packet.log icmp 
\end{verbatim}
For more info on how to use the BPF interface, read the Snort and
tcpdump man pages.

\section{Network Intrusion Detection Mode}

To enable Network Intrusion Detection (NIDS) mode so that you don't
record every single packet sent down the wire, try this:

\begin{verbatim}
./snort -dev -l ./log -h 192.168.1.0/24 -c snort.conf
\end{verbatim}
where snort.conf is the name of your rules file. This will apply the
rules configured in the \verb!snort.conf! file to each packet to decide if an action
based upon the rule type in the file should be taken. If you don't
specify an output directory for the program, it will default to \verb!/var/log/snort!.

One thing to note about the last command line is that if Snort is
going to be used in a long term way as an IDS, the -v
switch should be left off the command line for the sake of speed.
The screen is a slow place to write data to, and packets can be dropped
while writing to the display.

It's also not necessary to record the data link headers for most applications,
so you can usually omit the -e switch, too.

\begin{verbatim}
./snort -d -h 192.168.1.0/24 -l ./log -c snort.conf
\end{verbatim}
This will configure Snort to run in its most basic NIDS form, logging
packets that trigger rules specified in the snort.conf in plain ASCII 
to disk using a hierarchical directory structure (just like packet logger mode). 


\subsection{NIDS Mode Output Options}

There are a number of ways to configure the output of Snort in NIDS
mode. The default logging and alerting mechanisms are to log in decoded
ASCII format and use full alerts. The full alert
mechanism prints out the alert message in addition to the full packet
headers. There are several other alert output modes available at the
command line, as well as two logging facilities.

Alert modes are somewhat more complex. There are seven alert modes available
at the command line: full, fast, socket, syslog, console, cmg, and
none. Six of these modes are accessed with the -A command line switch.
These options are:

\begin{tabular}{| l | p{5.4in} |}
\hline
{\bf Option} & {\bf Description}\\
\hline
\hline
{\tt -A fast} & Fast alert mode. Writes the alert in a simple format with a timestamp, alert message, source
and destination IPs/ports.\\
\hline
{\tt -A full} & Full alert mode. This is the default alert mode and will be used automatically if you do not specify a mode.\\
\hline
{\tt -A unsock} & Sends alerts to a UNIX socket that another program can listen on.\\
\hline
{\tt -A none} & Turns off alerting.\\
\hline
{\tt -A console} & Sends ``fast-style'' alerts to the console (screen).\\
\hline
{\tt -A cmg} & Generates ``cmg style'' alerts.\\
\hline
\end{tabular}

Packets can be logged to their default decoded ASCII format or to
a binary log file via the -b command line switch. To disable
packet logging altogether, use the -N command line switch.

For output modes available through the configuration file, see Section
\ref{output config example}. 

\begin{note}
Command line logging options override any output options specified 
in the configuration file. This allows debugging of configuration 
issues quickly via the command line.
\end{note}

To send alerts to syslog, use the -s switch. The default facilities
for the syslog alerting mechanism are LOG\_AUTHPRIV and LOG\_ALERT.
If you want to configure other facilities for syslog output, use the
output plugin directives in the rules files. See Section \ref{alert syslog lable}
for more details on configuring syslog output.

For example, use the following command line to log to default (decoded ASCII) facility and send alerts to syslog: 

\begin{verbatim}
./snort -c snort.conf -l ./log -h 192.168.1.0/24 -s
\end{verbatim}

As another example, use the following command line to log to the default facility in /var/log/snort and send alerts to a
fast alert file: 

\begin{verbatim}
./snort -c snort.conf -A fast -h 192.168.1.0/24
\end{verbatim}

\subsection{Understanding Standard Alert Output}

When Snort generates an alert message, it will usually look like the following:
 
 \begin{verbatim}	 
  [**] [116:56:1] (snort_decoder): T/TCP Detected [**]
 \end{verbatim}
  	 
  The first number is the Generator ID, this tells the user what
  component of Snort generated this alert. For a list of GIDs, please read
  etc/generators in the Snort source. In this case, we know that this event
  came from the ``decode'' (116) component of Snort.
  	 
  The second number is the Snort ID (sometimes referred to as
  Signature ID). For a list of preprocessor SIDs, please see
  etc/gen-msg.map.  Rule-based SIDs are written directly into the rules
  with the "sid" option. In this case, ``56'' represents a T/TCP event.
  	 
  The third number is the revision ID. This number is primarily
  used when writing signatures, as each rendition of the rule should
  increment this number with the ``rev'' option.



\subsection{High Performance Configuration}

If you want Snort to go \emph{fast} (like keep up with a 1000 Mbps connection),
you need to use unified logging and a unified log reader such as
\emph{barnyard}.  This allows Snort to log alerts in a binary form as fast as
possible while another program performs the slow actions, such as writing to a
database.

If you want a text file that's easily parsable, but still somewhat fast, try
using binary logging with the ``fast'' output mechanism. 

This will log packets in tcpdump format and produce minimal alerts. For
example:

\begin{center}
\begin{verbatim}
./snort -b -A fast -c snort.conf
\end{verbatim}
\end{center}

\subsection{Changing Alert Order}

The default way in which Snort applies its rules to packets may not be
appropriate for all installations.  The Alert rules are applied first, then the
Pass rules, and finally, Log rules are applied. This sequence is somewhat
counterintuitive, but it's a more foolproof method than allowing a user to
write a hundred alert rules that are then disabled by an errant pass rule.  For
more information on rule types, see Section \ref{rules action section}.

If you know what you're doing, you can use the -o switch to change the default
rule application behavior to apply Pass rules, then Alert rules, then Log
rules:
\begin{center}
\begin{verbatim}
./snort -d -h 192.168.1.0/24 -l ./log -c snort.conf -o
\end{verbatim}
\end{center}


\section{Inline Mode\label{Snort Inline}}

Snort 2.3.0 RC1 integrated the intrusion prevention system (IPS) capability of
snort\_inline into the official Snort project. Snort\_inline obtains packets
from iptables instead of libpcap and then uses new rule types to help iptables
pass or drop packets based on Snort rules.  

In order for snort\_inline to work properly, you must download and compile the
iptables code to include ``make install-devel''
(\url{http://www.iptables.org}).  This will install the \texttt{libipq} library
that allows snort\_inline to interface with iptables.  Also, you must build and
install LibNet, which is available from \url{http://www.packetfactory.net}.

There are three rule types you can use when running Snort with snort\_inline:

\begin{itemize}
\item \textbf{drop} - The drop rule type will tell iptables to drop the packet and log it 
       via usual Snort means.
\item \textbf{reject} - The reject rule type will tell iptables to drop the packet, log it 
         via usual Snort means, and send a TCP reset if the protocol is 
         TCP or an icmp port unreachable if the protocol is UDP.
\item \textbf{sdrop} - The sdrop rule type will tell iptables to drop the packet.  Nothing
        is logged.
\end{itemize}

\begin{note}
You can also replace sections of the packet payload when using snort\_inline.
See Section \ref{ReplaceInline} for more information.
\end{note}

When using a \texttt{reject} rule, there are two options you can use to send
TCP resets:
\begin{itemize}

\item You can use a RAW socket (the default behavior for snort\_inline), in which case
you must have an interface that has an IP address assigned to it. If there is not an
interface with an IP address assigned with access to the source of the packet,
the packet will be logged and the reset packet will never make it onto the 
network.

\item You can also now perform resets via a physical device when using iptables.
We take the indev name from ip\_queue and use this as the interface on which
to send resets. We no longer need an IP loaded on the bridge, and can remain
pretty stealthy as the config layer2\_resets in snort\_inline.conf takes a source
MAC address which we substitue for the MAC of the bridge. For example:
\begin{verbatim}
config layer2resets
\end{verbatim}
tells snort\_inline to use layer2 resets and uses the MAC address of the bridge 
as the source MAC in the packet, and:
\begin{verbatim}
config layer2resets: 00:06:76:DD:5F:E3  
\end{verbatim}
will tell snort\_inline to use layer2 resets and uses the source MAC of 
00:06:76:DD:5F:E3 in the reset packet.
 

\end{itemize}

\subsection{Snort Inline Rule Application Order\label{InlineRuleOrder}}

The current rule application order is: 
\begin{verbatim}
	->activation->dynamic->drop->sdrop->reject->alert->pass->log
\end{verbatim}
This will ensure that a drop rule has precedence over an alert or log rule.
You can use the -o flag to the rule application order to:
\begin{verbatim}
	->activation->dynamic->pass->drop->sdrop->reject->alert->log
\end{verbatim}

\subsection{New STREAM4 Options for Use with Snort Inline\label{Stream4Inline}}

When using \texttt{snort\_inline}, you can use two additional stream4 options:

\begin{itemize}
\item \texttt{inline\_state} (no arguments)
   
   This option causes Snort to drop TCP packets that are not associated with 
    an existing TCP session, and is not a valid TCP initiator.

\item \texttt{midstream\_drop\_alerts} (no arguments)
   
   By default, when running in inline mode, Snort will silently drop any
    packets that were picked up in midstream and would have caused an alert
    to be generated, if not for the 'flow: established' option.  This is to
    mitigate stick/snot type attacks when the user hasn't enabled 
    inline\_state.  If you want to see the alerts that are silently
    dropped, enable this keyword.  Note that by enabling this keyword,
    you have opened yourself up to stick/snot-type attacks.

\end{itemize}

For more information about Stream4, see Section \ref{stream 4 section}.

\subsection{Replacing Packets with Snort Inline\label{ReplaceInline}}

Additionally, Jed Haile's content replace code allows you to modify packets
before they leave the network.  For example:

\begin{verbatim}
alert tcp any any <> any 80 (msg: "tcp replace"; content:"GET"; replace:"BET";)
alert udp any any <> any 53 (msg: "udp replace"; \
    content: "yahoo"; replace: "xxxxx";)
\end{verbatim}

These rules will comb tcp port 80 traffic looking for GET, and udp port 53
traffic looking for yahoo.  Once they are found, they are replaced with BET and
xxxxx, respectively.  The only catch is that the replace must be the same
length as the content.


\subsection{Installing Snort Inline\label{InlineInstall}}
To install Snort inline, use the following command:
\begin{verbatim}
./configure --enable-inline
make
make install
\end{verbatim} 


\subsection{Running Snort Inline}

First, you need to ensure that the ip\_queue module is loaded.  Then,
you need to send traffic to snort\_inline using the QUEUE target.  For
example,
\begin{verbatim}
iptables -A OUTPUT -p tcp --dport 80 -j QUEUE
\end{verbatim}
sends all TCP traffic leaving the firewall going to port 80 to the QUEUE
target.  This is what sends the packet from kernel space to user space 
(\texttt{snort\_inline}).  A quick way to get all outbound traffic going to the
QUEUE is to use the rc.firewall script created and maintained by the 
Honeynet Project (\url{http://www.honeynet.org/papers/honeynet/tools/})
This script is well-documented and allows you to direct packets
to \texttt{snort\_inline} by simply changing the QUEUE variable to yes.

Finally, start snort\_inline.

\begin{verbatim}
snort_inline -QDc ../etc/drop.conf -l /var/log/snort
\end{verbatim}

You can use the following command line options:
\begin{itemize}
\item \texttt{-Q} - Gets packets from iptables.
\item \texttt{-D} - Runs \texttt{snort\_inline} in daemon mode.  The process ID is stored
                    at /var/run/snort\_inline.pid
\item \texttt{-c} - Reads the following configuration file.
\item \texttt{-l} - Logs to the following directory.

\end{itemize}

Ideally, snort\_inline will be run using only its own drop.rules.  If
you want to use Snort for just alerting, a separate process should be
running with its own ruleset.

\subsection{Using the Honeynet Snort Inline Toolkit}

The Honeynet Snort Inline Toolkit is a statically compiled \texttt{snort\_inline} 
binary put together by the
Honeynet Project for the Linux operating system.  It comes with a set
of drop.rules, the \texttt{snort\_inline} binary, a snort-inline rotation shell
script, and a good README.  It can be found at:

\url{http://www.honeynet.org/papers/honeynet/tools/}

\subsection{Troubleshooting Snort Inline}

If you run snort\_inline and see something like this:
\begin{verbatim}
Initializing Output Plugins!
Reading from iptables
Log directory = /var/log/snort
Initializing Inline mode
InlineInit: : Failed to send netlink message: Connection refused
\end{verbatim}
More than likely, the ip\_queue module is not loaded or ip\_queue 
support is not compiled into your kernel.  Either recompile
your kernel to support ip\_queue, or load the module.

The ip\_queue module is loaded by executing:
\begin{verbatim}
insmod ip_queue
\end{verbatim}
Also, if you want to ensure snort\_inline is getting packets, you can 
start it in the following manner:
\begin{verbatim}
snort_inline -Qvc <configuration file>
\end{verbatim}
This will display the header of every packet that snort\_inline sees. 

\section{Miscellaneous}

If you want to run Snort in daemon mode, you can add -D switch to any
combination described in the previous sections. Please notice that if you want to be able to restart Snort
by sending a SIGHUP signal to the daemon, you {\em must} specify the full path to the Snort
binary when you start it, for example:

\begin{center}
\begin{verbatim}
/usr/local/bin/snort -d -h 192.168.1.0/24 \
    -l /var/log/snortlogs -c /usr/local/etc/snort.conf -s -D
\end{verbatim}
\end{center}

Relative paths are not supported due to security concerns.

If you need to post packet logs to public mailing lists, you might
want to use the -O switch. This switch obfuscates your IP addresses in
packet printouts. This is handy if you don't want people on the mailing
list to know the IP addresses involved. You can also combine the -O switch with
the -h switch to only obfuscate the IP addresses of hosts on the home network.
This is useful if you don't care who sees the address of the attacking host.
For example, you could use the following command to read the packets from a log 
file and dump them to the screen, obfuscating only the addresses from the 
192.168.1.0/24 class C network:

\begin{center}
\begin{verbatim}
./snort -d -v -r snort.log -O -h 192.168.1.0/24
\end{verbatim}
\end{center}


\section{More Information}

Chapter \ref{Configuring Snort} contains much information about many
configuration options available in the configuration file.  The Snort manual
page and the output of \texttt{snort -?} contain information that can help 
you get Snort running in several different modes.

\begin{note}
In many shells, a backslash (\textbackslash{}) is needed to escape the ?, so you may have to type 
\texttt{snort -\textbackslash{}?} instead of \texttt{snort -?} for a list of Snort command line options.
\end{note}

The Snort web page (\url{http://www.snort.org}) and the Snort User's mailing
list (\url{http://marc.theaimsgroup.com/?l=snort-users} at
\verb?snort-users@lists.sourceforge.net? provide informative announcements as
well as a venue for community discussion and support. There's a lot to Snort, so
sit back with a beverage of your choosing and read the documentation and
mailing list archives.

\newpage
\chapter{Configuring Snort \label{Configuring Snort}}

\subsection{Includes}

The {\tt include} keyword allows other rule files to be included within the rules
file indicated on the Snort command line. It works much like an \#include from
the C programming language, reading the contents of the named file and adding the contents
in the place where the include statement appears in the file.

\subsubsection{Format}
\begin{verbatim}
include: <include file path/name>
\end{verbatim}

\begin{note}
Note that there is no semicolon at the end of this line. 
\end{note}

Included files will
substitute any predefined variable values into their own variable references.
See Section (\ref{variables}) for more information on defining and
using variables in Snort rule files.

\subsection{Variables \label{variables}}

Variables may be defined in Snort. These are simple substitution variables
set with the {\tt var} keyword as shown in Figure \ref{variable definition}.

\subsubsection{Format}

\begin{verbatim}
var: <name> <value>
\end{verbatim}

\begin{figure}[!hbpt]
\begin{verbatim}
var MY_NET [192.168.1.0/24,10.1.1.0/24]
alert tcp any any -> $MY_NET any (flags:S; msg:"SYN packet";)
\end{verbatim}

\caption{Example of Variable Definition and Usage\label{variable definition}}
\end{figure}

Rule variable names can be modified in several ways. You can define
meta-variables using the \$ operator. These can be used with the variable
modifier operators {\tt ?}  and {\tt -}, as described in the following table: 

\begin{tabular}{| l | p{5in} |}
\hline
\textbf{Variable Syntax} & \textbf{Description}\\
\hline
\hline
\texttt{\$var} & Defines a meta-variable.\\
\hline
\texttt{\$(var)} & Replaces with the contents of variable \texttt{var}.\\
\hline
\texttt{\$(var:-default)} & Replaces the contents of the variable \texttt{var} with ``default'' if 
   \texttt{var} is undefined.\\
\hline
\texttt{\$(var:?message)} & Replaces with the contents of variable \texttt{var} or prints out the
error message and exits.\\
\hline
\end{tabular}


See Figure \ref{advanced variable usage} for an example of advanced variable usage in action.

\begin{figure}[!hbpt]
\begin{verbatim}
var MY_NET 192.168.1.0/24
log tcp any any -> $(MY_NET:?MY_NET is undefined!) 23
\end{verbatim}

\caption{Figure Advanced Variable Usage Example\label{advanced variable usage}}
\end{figure}

\subsection{Config}

Many configuration and command line options of Snort can be specified
in the configuration file. 

\subsubsection{Format}

\begin{center}
\begin{verbatim}
config <directive> [: <value>]
\end{verbatim}
\end{center}


\subsubsection{Directives}
\begin{center}
\begin{longtable}{| p{2in} | p{2.25in} | p{2.25in} |}
\caption{Config Directives} \\
\hline
{\bf Command} & {\bf Example} & {\bf Description}\\
\hline
\hline
\texttt{order} & \texttt{config order: pass alert log activation} & Changes the order that rules are evaluated. \\
\hline
\texttt{alertfile} & \texttt{config alertfile: alerts} & Sets the alerts output file. \\
\hline
\texttt{classification} & \texttt{config classification: misc-activity,Misc activity,3} & See Table \ref{Snort Default Classifications} for a list of
  classifications.\\
\hline
%%\texttt{decode\_arp} & \texttt{config decode\_arp} & Turns on ARP decoding (\texttt{snort -a}).  \\
%%\hline
\texttt{dump\_chars\_only} & \texttt{config dump\_chars\_only} & Turns on character dumps (\texttt{snort -C}). \\

\hline
\texttt{dump\_payload} & \texttt{config dump\_payload} & Dumps application layer (\texttt{snort -d}). \\
\hline
\texttt{decode\_data\_link} & \texttt{config decode\_data\_link} & Decodes Layer2 headers (\texttt{snort -e}). \\
\hline
\texttt{bpf\_file} & \texttt{config bpf\_file: filters.bpf} & Specifies BPF filters (\texttt{snort -F}). \\
\hline
\texttt{daemon} & \texttt{config daemon} & Forks as a daemon (\texttt{snort -D}). \\
% yeah, this should go away...
% reference\_net]Set home network (snort -h). Example: config reference\_net: 192.168.1.0/24
\hline
\texttt{interface} & \texttt{config interface: xl0} & Sets the network interface (\texttt{snort -i}). \\
\hline
\texttt{alert\_with\_interface\_name} & \texttt{config alert\_with\_interface\_name} & Appends interface name to alert (\texttt{snort -I}). \\
\hline
\texttt{logdir} & \texttt{config logdir: /var/log/snort} & Sets the logdir (\texttt{snort -l}). \\
\hline
\texttt{umask} & \texttt{config umask: 022} & Sets umask when running (\texttt{snort -m}). \\
\hline
\texttt{pkt\_count} & \texttt{config pkt\_count: 13} & Exits after N packets (\texttt{snort -n}). \\
\hline
\texttt{nolog} & \texttt{config nolog} & Disables logging. Note: Alerts will still occur. (\texttt{snort -N}). \\
\hline
\texttt{obfuscate} & \texttt{config obfuscate} & Obfuscates IP Addresses (\texttt{snort -O}). \\
\hline
\texttt{no\_promisc} & \texttt{config no\_promisc} & Disables promiscuous mode (\texttt{snort -p}). \\
\hline
\texttt{quiet} & \texttt{config quiet}& Disables banner and status reports (\texttt{snort -q}). \\
\hline
\texttt{chroot} & \texttt{config chroot: /home/snort} & Chroots to specified dir (\texttt{snort -t}). \\
\hline
\texttt{checksum\_mode} & \texttt{config checksum\_mode : all} & Types of packets 
to calculate checksums. Values: \texttt{none}, \texttt{noip}, \texttt{notcp}, 
\texttt{noicmp}, \texttt{noudp}, \texttt{ip}, \texttt{tcp}, \texttt{udp}, \texttt{icmp} or \texttt{all}. \\
\hline
\texttt{set\_gid} & \texttt{config set\_gid: 30} & Changes GID to specified GID (\texttt{snort -g}). \\
\hline
\texttt{set\_uid} & \texttt{set\_uid: snort\_user} & Sets UID to $<$id$>$ (\texttt{snort -u}). \\
\hline
\texttt{utc} & \texttt{config utc} & Uses UTC instead of local time for timestamps (\texttt{snort -U}). \\
\hline
\texttt{verbose} & \texttt{config verbose} & Uses verbose logging to STDOUT (\texttt{snort -v}). \\
\hline
\texttt{dump\_payload\_verbose} & \texttt{config dump\_payload\_verbose} & Dumps raw packet starting at link layer (\texttt{snort -X}). \\
\hline
\texttt{show\_year} & \texttt{config show\_year} & Shows year in timestamps (\texttt{snort -y}). \\
\hline
\texttt{stateful} & \texttt{config stateful} & Sets assurance mode for stream4 (est). See the stream4 reassemble configuration \ref{stream4 reassemble defaults}. \\
\hline
\texttt{min\_ttl} & \texttt{config min\_ttl:30} & Sets a Snort-wide minimum ttl to ignore all traffic. \\
\hline
\texttt{disable\_decode\_alerts} & \texttt{config disable\_decode\_alerts} & Turns off the alerts generated by the decode phase of Snort. \\
\hline
\texttt{disable\_tcpopt\_experimental\_\linebreak alerts} & \texttt{config disable\_tcpopt\_experiment\linebreak al\_alerts} & Turns off alerts generated by experimental TCP options. \\
\hline
\texttt{disable\_tcpopt\_experimental\_\linebreak alerts} & \texttt{config disable\_tcpopt\_experiment\linebreak al\_alerts} & Turns off alerts generated by experimental TCP options. \\
\hline
\texttt{disable\_tcpopt\_obsolete\_\linebreak alerts} & \texttt{config disable\_tcpopt\_obsolete\_\linebreak alerts} & Turns off alerts generated by obsolete TCP options. \\
\hline
\texttt{disable\_tcpopt\_ttcp\_alerts} & \texttt{config disable\_tcpopt\_ttcp\_alerts} & Turns off alerts generated by T/TCP options. \\
\hline
\texttt{disable\_ttcp\_alerts} & \texttt{config disable\_ttcp\_alerts} & Turns off alerts generated by T/TCP options. \\
\hline
\texttt{disable\_tcpopt\_alerts} & \texttt{config disable\_tcpopt\_alerts} & Disables option length validation alerts. \\
\hline
\texttt{disable\_ipopt\_alerts} & \texttt{config disable\_ipopt\_alerts} & Disables IP option length validation alerts. \\
\hline
\texttt{disable\_decode\_drops} & \texttt{config disable\_decode\_drops} & Disables the dropping of
bad packets identified by decoder (only applicable in inline mode).\\
\hline
\texttt{disable\_tcpopt\_experimental\_\linebreak drops} & \texttt{config disable\_tcpopt\_experi\linebreak mental\_drops} & Disables the dropping of bad packets with obsolete TCP option
        (only applicable in inline mode).\\
\hline
\texttt{disable\_ttcp\_drops} & \texttt{disable\_ttcp\_drops} & Disables the dropping of bad packets with TCP echo option
        (only applicable in inline mode).\\
\hline
\texttt{disable\_tcpopt\_drops} & \texttt{config disable\_tcpopt\_drops} & Disables the dropping of bad packets with bad/truncated TCP
        option (only applicable in inline mode).\\
\hline
\texttt{disable\_ipopt\_drops} &  \texttt{config disable\_ipopt\_drops} & Disables the dropping of bad packets with bad/truncated IP
        options (only applicable in inline mode).\\
\hline
\texttt{flowbits\_size} & \texttt{config flowbits\_size: 128} & Specifies the maximum number of flowbit tags that can be used within
        a ruleset.\\
\hline
\texttt{event\_queue} & \texttt{config event\_queue: max\_queue 512 log 100 order\_events priority} &  
Specifies conditions about Snort's event queue. You can use the following options:
\begin{itemize}
\item \texttt{max\_queue $<$integer$>$} (max events supported)
\item \texttt{log $<$integer$>$} (number of events to log) 
\item \texttt{order\_events [priority$|$content\_length]} (how to order events within the queue)\end{itemize}
See Section \ref{eventqueue} for more information and examples.\\
% XXX - NEED MORE HERE!!!
\hline
\texttt{layer2resets} & \texttt{config layer2resets: 00:06:76:DD:5F:E3} & This option is only available when running in inline mode. See Section \ref{Snort Inline}.\\
\hline
\texttt{detection} & \texttt{config detection: search-method ac no\_stream\_inserts max\_queue\_events 128} & Makes changes to the detection engine. 
The following options can be used:\begin{itemize}\item \texttt{search-method$<$ac$|$mwm$|$lowmem$>$}
\item \texttt{no\_stream\_inserts}
\item \texttt{max\_queue\_events$<$integer$>$}\end{itemize}\\
\hline
\texttt{asn1} & \texttt{config asn1:256} & Specifies the maximum number of nodes to 
track when doing ASN1 decoding. See Section \ref{asn1} for more information and examples.\\
\hline
\texttt{snaplen} & \texttt{config snaplen: 2048} & Set the snaplength of packet, same effect as 
-P $<$snaplen$>$ option.\\
\hline
\texttt{read\_bin\_file} & \texttt{config read\_bin\_file: test\_alert.pcap} & Specifies a pcap file to use 
(instead of reading from network),
        same effect as -r $<$tf$>$ option.\\
%debug Make snort print out debugging info debug \\
%no\_stream\_inserts] Do not perform detection on packets that that are going to be rebuilt 
%max\_queue\_events] Queues multiple alerts per packet and selects the most specific one (default: 5) Example: config max\_queue\_events: 5
\hline
\texttt{reference} & \texttt{config reference: myref http://myurl.com/?id=} & Adds a new reference system to Snort.  \\
\hline
\end{longtable}
\end{center}

\newpage
\section{Preprocessors}

Preprocessors were introduced in version 1.5 of Snort. They allow
the functionality of Snort to be extended by allowing users and programmers
to drop modular plugins into Snort fairly easily.
Preprocessor code is run before the detection engine is called, but
after the packet has been decoded. The packet can be modified or analyzed
in an out-of-band manner using this mechanism.

Preprocessors are loaded and configured using the {\tt preprocessor} keyword.
The format of the preprocessor directive in the Snort rules file is:

\begin{verbatim}
preprocessor <name>: <options>
\end{verbatim}

\begin{figure}[!hbpt]
\begin{verbatim}
preprocessor minfrag: 128
\end{verbatim}

\caption{\label{Preprocessor Example}Preprocessor Directive Format Example}
\end{figure}

\subsection{Portscan Detector}

The Snort Portscan preprocessor is developed by Patrick Mullen.


\subsubsection{What the Snort Portscan Preprocessor Does}

\begin{itemize}
\item Logs the start and end of portscans from a single source IP to the
standard logging facility.
\item If a log file is specified, it logs the destination IPs and ports scanned,
as well as the type of scan.
\end{itemize}
A portscan is defined as TCP connection attempts to more than {\em p} ports
in {\em t} seconds or udp packets sent to more than {\em p} ports in {\em t} seconds.
Ports can be spread across any number of destination IP addresses,
and may all be the same port if spread across multiple IPs. This version of the Portscan
preprocessor
does single $\rightarrow$ single and single $\rightarrow$ many portscans. The next full release
will do distributed portscans (multiple $\rightarrow$ single or multiple $\rightarrow$ multiple).
A portscan is also defined as a single stealth scan
packet, such as NULL, FIN, SYN-FIN, XMAS, etc. This means that from
scan-lib in the standard distribution of Snort, you should comment
out the section for stealth scan packets. The benefit is that, with the
portscan module, these alerts would only show once per scan, rather
than once for each packet. If you use the external logging feature,
you can view the portscan technique and type in the log file.

The arguments to this module are:
 
\begin{tabular}{| l | p{5in} |}
\hline
{\bf Option} & {\bf Description}\\
\hline
\hline
monitored network & The network/CIDR block to monitor for portscans.\\
\hline
number of ports & The number of ports accessed during the detection period.\\
\hline
detection period & The number of seconds to count that the port access threshold
is considered for. \\
\hline
logdir/filename & The directory/filename to place alerts in. Alerts
are also written to the standard alert file.\\
\hline
\end{tabular}

\subsubsection{Format}

\begin{verbatim}
portscan: <monitored network> <number of ports> <detection period> <logdir/filename>
\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
preprocessor portscan: 192.168.1.0/24 5 7 /var/log/portscan.log
\end{verbatim}

\caption{\label{Portscan Processor Config}Portscan Preprocessor Configuration
Example}
\end{figure}



\subsection{Portscan Ignorehosts}

Portscan Ignorehosts is another module from Patrick Mullen that modifies the 
portscan detection system's operation. If you have servers that tend to trip the
portscan detector (such as NTP, NFS, and DNS servers), you can tell
portscan to ignore TCP Syn and UDP portscans from certain hosts. The
arguments to this module are a list of IPs/CIDR blocks to be ignored.


\subsubsection{Format}

\begin{verbatim}
portscan-ignorehosts: <host list>
\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
preprocessor portscan-ignorehosts: 192.168.1.5/32 192.168.3.0/24
\end{verbatim}

\caption{\label{Portscan Ignore Hosts Example}Portscan Ignorehosts Module
Configuration Example}
\end{figure}

\subsection{sfPortscan\label{sfportscan section}}

The sfPortscan module, developed by Sourcefire, is designed to detect the 
first phase in a network attack: Reconnaissance. In the Reconnaissance phase, 
an attacker determines
what types of network protocols or services a host supports. This is
the traditional place where a portscan takes place. This phase assumes
the attacking host has no prior knowledge of what protocols or
services are supported by the target, otherwise this phase would not
be necessary.

As the attacker has no beforehand knowledge of its intended target,
most queries sent by the attacker will be negative (meaning that the
service ports are closed). In the nature of legitimate network
communications, negative responses from hosts are rare, and rarer
still are multiple negative responses within a given amount of time.
Our primary objective in detecting portscans is to detect and track
these negative responses.

One of the most common portscanning tools in use today is Nmap. Nmap
encompasses many, if not all, of the current portscanning techniques.
sfPortscan was designed to be able to detect the different types of
scans Nmap can produce.

sfPortscan will currently alert for the following types of Nmap scans:
\begin{itemize}
\item TCP Portscan
\item UDP Portscan
\item IP Portscan
\end{itemize}

These alerts are for one$\rightarrow$one portscans, which are the traditional
types of scans; one host scans multiple ports on another host. Most of
the port queries will be negative, since most hosts have relatively
few services available.

sfPortscan also alerts for the following types of decoy portscans:
\begin{itemize}
\item TCP Decoy Portscan
\item UDP Decoy Portscan
\item IP Decoy Portscan
\end{itemize}

Decoy portscans are much like the Nmap portscans described above, only the attacker has spoofed
source address inter-mixed with the real scanning address. This tactic
helps hide the true identity of the attacker.

sfPortscan alerts for the following types of distributed portscans:
\begin{itemize}
\item TCP Distributed Portscan
\item UDP Distributed Portscan
\item IP Distributed Portscan
\end{itemize}

These are many$\rightarrow$one portscans. Distributed portscans occur when
multiple hosts query one host for open services. This is used to evade
an IDS and obfuscate command and control hosts.

\begin{note}
Negative queries will be distributed among scanning hosts, so
we track this type of scan through the scanned host.
\end{note}

sfPortscan alerts for the following types of portsweeps:
\begin{itemize}
\item TCP Portsweep
\item UDP Portsweep
\item IP Portsweep
\item ICMP Portsweep
\end{itemize}

These alerts are for one$\rightarrow$many portsweeps. One host scans a single port
on multiple hosts. This usually occurs when a new exploit comes out and the
attacker is looking for a specific service. 

\begin{note}
The characteristics of a portsweep scan may not result in many
negative responses. For example, if an attacker portsweeps a web farm
for port 80, we will most likely not see many negative responses.
\end{note}

sfPortscan alerts on the following filtered portscans and portsweeps:

\begin{itemize}
\item TCP Filtered Portscan
\item UDP Filtered Portscan
\item IP Filtered Portscan

\item TCP Filtered Decoy Portscan
\item UDP Filtered Decoy Portscan
\item IP Filtered Decoy Portscan

\item TCP Filtered Portsweep
\item UDP Filtered Portsweep
\item IP Filtered Portsweep
\item ICMP Filtered Portsweep

\item TCP Filtered Distributed Portscan
\item UDP Filtered Distributed Portscan
\item IP Filtered Distributed Portscan
\end{itemize}

``Filtered'' alerts indicate that there were no network errors (ICMP
unreachables or TCP RSTs) or responses on closed ports have been
suppressed. It's also a good indicator of whether the alert is just a
very active legitimate host. Active hosts, such as NATs, can trigger
these alerts because they can send out many connection attempts within
a very small amount of time. A filtered alert may go off before
responses from the remote hosts are received.

sfPortscan only generates one alert for each host pair in question during
the time window (more on windows below). On TCP scan alerts, sfPortscan
will also display any open ports that were scanned. On TCP sweep alerts
however, sfPortscan will only track open ports after the alert has been
triggered. Open port events are not individual alerts, but tags based
off the orginal scan alert.

\subsubsection{sfPortscan Configuration\label{sfportscan configuration}}

You may want to use the following line in your snort.conf to disable evasion alerts 
within stream4 because some
scan packets can cause these alerts to be generated:

\begin{verbatim}
  preprocessor stream4: disable_evasion_alerts
\end{verbatim}

Use of the Flow preprocessor is required for sfPortscan. Flow gives
portscan direction in the case of connectionless protocols like ICMP
and UDP. You should enable the Flow preprocessor in your snort.conf by 
using the following:

\begin{verbatim}
  preprocessor flow: stats_interval 0 hash 2
\end{verbatim}

The parameters you can use to configure the portscan module are:

\begin{slist}
\item \textbf{proto $<$protocol$>$}

  Available options:
  \begin{itemize}
    \item	tcp 
	\item udp 
	\item icmp 
	\item ip\_proto 
	\item all 
   \end{itemize}

\item \textbf{scan\_type $<$scan\_type$>$}

  Available options: 
   \begin{itemize}
	\item portscan 
	\item portsweep 
	\item decoy\_portscan 
	\item distributed\_portscan 
	\item all
	\end{itemize}

\item \textbf{sense\_level $<$level$>$}

  Available options:
  \begin{itemize}
	\item low - ``Low'' alerts are only generated on error packets sent from the
  target host, and because of the nature of error responses, this
  setting should see very few false postives. However, this setting
  will never trigger a Filtered Scan alert because of a lack of error
  responses. This setting is based on a static time window of 60
  seconds, afterwhich this window is reset.
	\item medium - ``Medium'' alerts track Connection Counts, and so will generate
  Filtered Scan alerts. This setting may false positive on active
  hosts (NATs, proxies, DNS caches, etc), so the user may need to
  deploy the use of Ignore directives to properly tune this directive.
	\item high - ``High'' alerts continuously track hosts on a network using a time
  window to evaluate portscan statistics for that host. A "High"
  setting will catch some slow scans because of the continuous
  monitoring, but is very sensitive to active hosts. This most
  definitely will require the user to tune sfPortscan.
  \end{itemize}

\item \textbf{watch\_ip $<$ip1,ip2/cidr$>$ }

  Defines what IPs or networks to watch. IPs or networks not falling
  into this range are ignored.

\item \textbf{ignore\_scanners $<$ip\_list$>$ }

  Ignores the source of scan alerts.

\item \textbf{ignore\_scanned $<$ip\_list$>$ }

  Ignores the destination of scan alerts

\item \textbf{logfile $<$file$>$ } 

  This option will output portscan events to the file specified. If
  <file> does not contain a leading slash, this file will be placed in
  the Snort config dir.
\end{slist}

\subsubsection{Format}

\begin{verbatim}
preprocessor sfportscan: proto <protocols> \
scan_type <portscan|portsweep|decoy_portscan|distributed_portscan|all>\
sense_level <low|medium|high> watch_ip <IP or IP/CIDR> ignore_scanners <IP list>\
ignore_scanned <IP list> logfile <path and filename>
\end{verbatim}

\begin{figure}[!hbpt]
\begin{verbatim}
	preprocessor flow: stats_interval 0 hash 2
	preprocessor sfportscan: proto { all } \
    scan_type { all } \
    sense_level { low }
\end{verbatim}
\caption{sfPortscan Preprocessor Configuration \label{sfPortscan Example}}
\end{figure}


\subsubsection{sfPortscan Alert Output\label{sfportscan alert output}}

Unified Output

In order to get all the portscan information logged with the alert, snort
generates a pseudo-packet and uses the payload portion to store the additional
portscan information of priority count, connection count, IP count, port count,
IP range, and port range.  The characteristics of the packet are:

Src/Dst MAC Addr == MACDAD
IP Protocol == 255
IP TTL == 0

Other than that, the packet looks like the IP portion of the packet that caused
the portscan alert to be generated.  This includes any IP options, etc.  The
payload and payload size of the packet is equal to the length of the additional
portscan information that is logged.  The size tends to be around 100 - 200
bytes.

Open port alerts differ from the other portscan alerts, because open port alerts
utilize the tagged packet output system.  This means that if an output system
that doesn't print tagged packets is used, then the user won't see open port
alerts.  The open port information is stored in the IP payload and
contains the port that is open.

The sfPortscan alert output was designed to work with unified packet logging, so
it is possible to extend favorite snort GUIs to display portscan alerts and the
additional information in the IP payload using the above packet characteristics.

Log File Output

Logfile output is displayed in the following format, and explained further
below:

\begin{verbatim}
	Time: 09/08-15:07:31.603880
	event_id: 2
	192.168.169.3 -> 192.168.169.5 (portscan) TCP Filtered Portscan
	Priority Count: 0
	Connection Count: 200
	IP Count: 2
	Scanner IP Range: 192.168.169.3:192.168.169.4
	Port/Proto Count: 200
	Port/Proto Range: 20:47557
\end{verbatim}

If there are open ports on the target, an additional tagged packet(s) will be
appended:

\begin{verbatim}
	Time: 09/08-15:07:31.603881
	event_ref: 2
	192.168.169.3 -> 192.168.169.5 (portscan) Open Port
	Open Port: 38458
\end{verbatim}

\begin{slist}
  \item \textbf{Event\_id/Event\_ref}

     These fields are used to link an alert with the corresponding 
     Open Port tagged packet

  \item \textbf{Priority Count}

     Priority Count keeps track of bad responses (resets,
     unreachables). The higher the Priority Count, the more bad
     responses have been received.

  \item \textbf{Connection Count}
     
     Connection Count lists how many connections are active on the
     hosts (src or dst). This is accurate for connection-based
     protocols, and is more of an estimate for others. Whether or not a
     portscan was filtered is determined here. High connection count and
     low priority count would indicate filtered (no response received
     from target).

  \item \textbf{IP Count}

     IP Count keeps track of the last IP to contact a host, and
     increments the count if the next IP is different. For one-to-one
     scans, this is a low number. For active hosts this number will
     be high regardless, and one-to-one scans may appear as a
     distributed scan.

  \item \textbf{Scanned/Scanner IP Range}

     This field changes depending on the type of alert. Portsweeps
     (one-to-many) scans display the scanned IP range; Portscans
     (one-to-one) display the scanner IP. 

 \item \textbf{Port Count}

     Port Count keeps track of the last port contacted and increments
     this number when that changes. We use this count (along with IP
     Count) to determine the difference between one-to-one portscans
     and one-to-one decoys.
\end{slist}

\subsubsection{Tuning sfPortscan\label{tuning sfportscan}}

The most important aspect in detecting portscans is tuning the detection engine
for your network(s).  Here are some tuning tips:

\begin{slist}

\item \textbf{Use the watch\_ip, ignore\_scanners, and ignore\_scanned options.}
  
     It's important to correctly set these options.  The watch\_ip option is easy
     to understand.  The analyst should set this option to the list of Cidr 
     blocks and IPs that they want to watch.  If no watch\_ip is defined, 
     sfPortscan will watch all network traffic.
     
     The ignore\_scanners and ignore\_scanned options come into play in weeding
     out legitimate hosts that are very active on your network.  Some of the
     most common examples are NAT IPs, DNS cache servers, syslog servers, and
     nfs servers.  sfPortscan may not generate false positives for these types
     of hosts, but be aware when first tuning sfPortscan for these IPs. 
     Depending on the type of alert that the host generates, the analyst will
     know which to ignore it as.  If the host is generating portsweep events,
     then add it to the ignore\_scanners option.  If the host is generating
     portscan alerts (and is the host that is being scanned), add it to the
     ignore\_scanned option.
  
\item \textbf{Filtered scan alerts are much more prone to false positives.}
  
     When determining false positives, the alert type is very important.  Most of
     the false positives that sfPortscan may generate are of the filtered scan
     alert type.  So be much more suspicious of filtered portscans.  Many times
     this just indicates that a host was very active during the time period in
     question.  If the host continually generates these types of alerts, add it
     to the ignore\_scanners list or use a lower sensitivity level.
     
\item \textbf{Make use of the Priority Count, Connection Count, IP Count, Port Count, IP
     range, and Port range to determine false positives.}
     
     The portscan alert details are vital in determining the scope of a portscan
     and also the confidence of the portscan.  In the future, we hope to
     automate much of this analysis in assigning a scope level and confidence
     level, but for now the user must manually do this.  The easiest way to
     determine false positives is through simple ratio estimations.  The
     following is a list of ratios to estimate and the associated values that
     indicate a legimite scan and not a false positive.
     
     \textbf{Connection Count / IP Count:}  This ratio indicates an estimated average of
     connections per IP.  For portscans, this ratio should be high, the higher
     the better.  For portsweeps, this ratio should be low.
     
     \textbf{Port Count / IP Count:}  This ratio indicates an estimated average of ports
     connected to per IP.  For portscans, this ratio should be high and
     indicates that the scanned host's ports were connected to by fewer IPs. 
     For portsweeps, this ratio should be low, indicating that the scanning host
     connected to few ports but on many hosts.
     
     \textbf{Connection Count / Port Count:}  This ratio indicates an estimated average
     of connections per port.  For portscans, this ratio should be low.  This
     indicates that each connection was to a different port.  For portsweeps,
     this ratio should be high.  This indicates that there were many connections
     to the same port.
     
     The reason that Priority Count is not included, is because the priority
     count is included in the connection count and the above comparisons take
     that into consideration.  The Priority Count play an important role in
     tuning because the higher the priority count the more likely it is a real
     portscan or portsweep (unless the host is firewalled).
     
\item \textbf{If all else fails, lower the sensitivity level.}
     
     If none of these other tuning techniques work or the analyst doesn't have
     the time for tuning, lower the sensitivity level.  You get the best
     protection the higher the sensitivity level, but it's also important that
     the portscan detection engine generates alerts that the analyst will find
     informative.  The low sensitivity level only generates alerts based on
     error responses.  These responses indicate a portscan and the alerts
     generated by the low sensitivity level are highly accurate and require the
     least tuning.  The low sensitivity level does not catch filtered scans,
     since these are more prone to false positives.
\end{slist}

\subsection{Frag2\label{Frag2 Section}}

Frag2 is a new IP defragmentation preprocessor introduced in Snort 1.8 and is 
designed to replace the Defrag preprocessor.
This defragmenter is designed to be memory efficient and use the same
memory management routines that are in use in other parts of Snort. 

Frag2 has configurable memory usage and fragment timeout options.
Given no arguments, Frag2 uses the default memory limit of 4194304
bytes (4\textsc{mb}) and a timeout period of 60 seconds. The timeout
period is used to determine a length of time after which an unassembled fragment
should be discarded.

In Snort 1.8.7, several options were added to help catch the use of
evasion techniques, such as fragroute. 


\subsubsection{Format}

\begin{verbatim}
preprocessor frag2: [memcap <xxx>], [timeout <xx>], [min_ttl <xx>], \
                    [detect_state_problems], [ttl_limit <xx>] 
\end{verbatim}
\begin{tabular}{| l | p{5in} |}
\hline
\textbf{Option} & \textbf{Description}\\
\hline
\hline
\texttt{timeout~<seconds>} & Amount of time to keep an inactive stream in
the state table; sessions that are flushed will automatically be picked
up again if more activity is seen. The default value is 30 seconds.\\
\hline
\texttt{memcap~<bytes>} & Number of bytes to set the memory cap at; if this
limit is exceeded, Frag2 will aggressively prune inactive reassemblers. The
default value is 4\textsc{mb}.\\
\hline
\texttt{detect\_state\_problems} & Turns on alerts for events such as overlapping
fragments.\\
\hline
\texttt{min\_ttl} & Sets the minimum ttl that Frag2 will accept.\\
\hline
\texttt{ttl\_limit} & Sets the delta value that will set off an evasion alert
(initial fragment ttl +/- ttl limit). \\
\hline
\end{tabular}
%
\begin{figure}[!hbpt]
\begin{verbatim}
preprocessor frag2: memcap 16777216, timeout 30
\end{verbatim}

\caption{Frag2 Preprocessor Configuration \label{Frag2 Example}}
\end{figure}

\subsection{Stream4\label{stream 4 section}}

The Stream4 module provides TCP stream reassembly and stateful analysis
capabilities to Snort. Robust stream reassembly capabilities allow
Snort to ignore ``stateless'' attacks (which include the types of attacks
that Stick and Snot produce).
Stream4 also gives large scale users the ability to track more than
256 simultaneous TCP streams. Stream4 should be able to scale to handle
32,768 simultaneous TCP connections in its default configuration.

Stream4 contains two configurable modules, the Stream4 preprocessor
and the associated Stream4 reassemble plugin. The stream4\_reassemble
options are listed below. 

\begin{note}
Additional options can be used if Snort is running in inline mode. See Section
\ref{Stream4Inline} for more information.
\end{note}


\subsubsection{Stream4 Format}

\begin{verbatim}
preprocessor stream4: [noinspect], [keepstats], [timeout <seconds>], \
            [memcap <bytes>], [detect_scans], [detect_state_problems], \
            [enforce_state], [disable_evasion_alerts], [ttl_limit <count>]
\end{verbatim}
\begin{tabular}{| l | p{5in} |}
\hline
\textbf{Option} & \textbf{Description}\\
\hline 
\hline 
\texttt{noinspect} & Disables stateful inspection.\\
\hline
\texttt{keepstats} & Records session summary information in $<$logdir$>$/session.log.\\
\hline
\texttt{timeout~<seconds>} & Amount of time to keep an inactive stream in
the state table; sessions that are flushed will automatically be picked
up again if more activity is seen. The default value is 30 seconds.\\
\hline
\texttt{memcap~<bytes>} & Number of bytes to set the memory cap at; if this
limit is exceeded stream4 will aggressively prune inactive sessions.
The default value is 8\textsc{mb}.\\
\hline
\texttt{detect\_scans} & Turns on alerts for portscan events.\\
\hline
\texttt{detect\_state\_problems} & Turns on alerts for stream events of note,
such as evasive RST packets, data on the SYN packet, and out of window
sequence numbers.\\
\hline
\texttt{enforce\_state} & Enforces statefulness so that sessions aren't picked up mid-stream.\\
\hline
\texttt{disable\_evasion\_alerts} & Turns off alerts for events such as TCP
overlap.\\
\hline
\texttt{ttl\_limit} & Sets the delta value that will set off an evasion alert.\\
\hline
\end{tabular}

\subsubsection{Stream4\_reassemble Format}

\begin{verbatim}
preprocessor stream4_reassemble: [clientonly], [serveronly],\
                                 [noalerts], [ports <portlist>]
\end{verbatim}
\begin{tabular}{| l | p{5in} |}
\hline
\textbf{Option} & \textbf{Description}\\
\hline
\hline
\texttt{clientonly} & Provides reassembly for the client side of a connection
only.\\
\hline
\texttt{serveronly} & Provides reassembly for the server side of a connection
only.\\
\hline
\texttt{noalerts} & Won't alert on events that may be insertion or evasion
attacks.\\
\hline
\texttt{ports <portlist>} & Provides reassembly for a whitespace-separated list of ports. 
By default, reassembly is performed for ports 21, 23, 25, 53, 
80, 110, 111, 143, and 513. To perform reassembly for all ports, use \texttt{all} 
as the port list.\\
\hline
\end{tabular}

\subsubsection{Notes}

Just setting the Stream4 and Stream4\_reassemble directives without
arguments in the snort.conf file will set them up in their default
configurations shown in Table \ref{Stream4 Defaults} and Table \ref{stream4 reassemble defaults}.

Stream4 introduces a new command line switch: -z.
On TCP traffic, if the -z switch is specified, Snort will only alert
on streams that have been established via a three way handshake or
streams where cooperative bidirectional activity has been observed
(i.e., where some traffic went one way and something other than a RST
or FIN was seen going back to the originator). With -z
turned on, Snort completely ignores TCP-based Stick/Snot attacks.

%
\begin{table}[!hbpt]

\caption{Stream4 Defaults\label{Stream4 Defaults}}

\begin{center}\begin{tabular}{| l | l |}
\hline 
\textbf{Option} &
\textbf{Default}\\
\hline
\hline 
session timeout (\texttt{timeout}) & 30 seconds\\
\hline 
session memory cap (\texttt{memcap}) & 8388608 bytes\\
\hline 
stateful inspection (\texttt{noinspect}) & active (\texttt{noinspect} disabled)\\
\hline 
stream stats (\texttt{keepstats}) & inactive\\
\hline 
state problem alerts (\texttt{detect\_state\_problems}) & inactive (\texttt{detect\_state\_problems} disabled)\\
\hline
portscan alerts (\texttt{disable\_evasion\_alerts})  & inactive (\texttt{disable\_evasion\_alerts} enabled)\\
\hline
\end{tabular}
\end{center}
\end{table}


%
\begin{table}[!hbpt]

\caption{Stream4\_reassemble Defaults\label{stream4 reassemble defaults}}

\begin{center}\begin{tabular}{| c | c |}
\hline 
\textbf{Option} &
\textbf{Default}\\
\hline
\hline 
reassemble client (\texttt{clientonly})&
active\\
\hline 
reassemble server (\texttt{serveronly})&
inactive\\
\hline 
reassemble ports (\texttt{ports})&
21 23 25 53 80 143 110 111 513 1433\\
\hline 
reassembly alerts (\texttt{noalerts})&
active (\texttt{noalerts} disabled)\\
\hline
\end{tabular}\end{center}
\end{table}


\subsection{Flow\label{sub:flow}}

The Flow tracking module is meant to start unifying the state keeping
mechanisms of Snort into a single place. As of Snort 2.1.0, only a portscan
detector is implemented, but in the long term,  many of the stateful subsystems
of Snort will be migrated over to becoming flow plugins. With the introduction
of flow, this effectively makes the conversation preprocessor
obsolete.

An IPv4 flow is unique when the IP protocol (\texttt{ip\_proto}), source IP (\texttt{sip}),
source port (\texttt{sport}), destination IP (\texttt{dip}), and destination port (\texttt{dport}) are the
same.  The \texttt{dport} and \texttt{sport} are 0 unless the protocol is TCP or UDP.

\subsubsection{Format}
\begin{verbatim}
preprocessor flow: [memcap <bytes>], [rows <count>], \
                   [stats_interval <seconds>], [hash <1|2>]
\end{verbatim}

\begin{table}[hbpt]{}
\caption{Flow Options}
\begin{minipage}[hbpt]{6in}
\begin{center}\begin{tabular}{| l | l |}
\hline 
\textbf{Option} & \textbf{Description}\\
\hline
\hline
\texttt{memcap} &
Number of bytes to allocate.\\
\hline 
\texttt{rows} & Number of rows for the flow hash table. \footnote[1]{This number can be increased, at the cost of using more memory, to enhance performance. Increasing rows provide a larger hash table.}\\
\hline 
\texttt{stats\_interval} &
Interval (in seconds) to dump statistics to STDOUT. Set this to 0 to disable.\\
\hline 
\texttt{hash} & Hashing method to use.\footnote[2]{1 - hash by byte, 2 - hash by integer (faster, not as much of a chance to become diverse).  The hash table has a pseudo-random salt picked to make algorithmic complexity attacks much more difficult.}   \\
\hline
\end{tabular}
\end{center}
\end{minipage}
\end{table}

\subsubsection{Example Configuration}

\begin{verbatim}
preprocessor flow: stats_interval 0 hash 2
\end{verbatim}




\subsection{Flow-Portscan\label{sub:flow-portscan}}

\begin{note}
The Flow-Portscan preprocessor was deprecated in Snort 2.3 RC1, in
favor of sfPortscan.
\end{note}

This module is designed to detect portscans based off flow creation in the
flow preprocessors.  The goal is to catch one$\rightarrow$many hosts and one$\rightarrow$many ports
scans.

The Flow preprocessor to portscan recognizer is taken from experience with
spp\_conversation/portscan2 by Jason Larsen \& Jed Haile and IPAudit by Jon
Rifkin.

This subsystem became a bit more complicated than originally intended, but it
does a good job of mitigating false positives from devices such as Squid
proxies.  The new design is also a lot more memory-consistent than Portscan1 or
2.  It also ignores single port SYN floods as they are a DOS, not a portscan.

Memory requirements should be way down from Portscan2 architecture though, but
there's slightly less information saved off.  The new architecture operates
similarly to a ring buffer---when a scanner has not been active in a long time,
it's only reclaimed when there is no more memory to use.

All of the prior methods for portscan detection in Snort are deprecated and
will be removed in the near future.  If you have custom code against
Conversation or one of the Portscan preprocessors, consider making it a module
in Flow or Portscan.

The Flow preprocessor must first be enabled for Flow-Portscan to
function properly.

The basic components of Flow-Portscan are:
\begin{slist}
\item \textbf{Scoreboards}

Scoreboards contain information about timescales for a single IP address.  There are two scoreboards, one for talkers (nodes that are active on your network) and one for scanners (nodes that have talked to a previously unknown port in your server-watch-net).
 
\item \textbf{Uniqueness Tracker}

The uniqueness tracker determines whether this connection should count as something "new" for a particular IP.  It verifies that a connection is a new type of connection for a source IP by disregarding the source port.  Any change in \texttt{sip}, \texttt{dip}, \texttt{ip\_proto}, and \texttt{dport} indicates a new unique connection and will be processed further for the server statistics table and scoring.  This keeps things like a web page with 15 images from rapidly increasing point scores with lots of accesses to the same web server.
\item \textbf{Server Statistics Tracker}

The server statistics tracker tracks flows destined to the "server-watchnet" and keeps "hitcounts" on the number of times a particular service has been requested with unique requests since Snort has started.  This hitcount is tracked by \texttt{dip}, \texttt{dport}, and \texttt{protocol}.
\end{slist}

If a service is very popular, connections can be ignored for scoring by
comparing the hitcount to the ``server-ignore-limit.'' If there are more requests
to this service than the server-ignore-limit, then flow-portscan will
completely ignore this service.  Similarly, the ``server-scanner-limit'' controls
if a request to a service counts as scanner points or as talker points.

If a request to a service is not in the server-watchnet, it will count as
talker points. If no server-watchnet is defined, all alerts will be talker
alerts.


\paragraph{Execution Path of Flow-Portscan}


\begin{slist}
\item Flow-Portscan receives a new flow message from the flow module.
\item The uniqueness tracker determines if the message is a new type of flow by
looking for changes in \texttt{sip}, \texttt{dip}, \texttt{ip\_proto}, and \texttt{dport}.  
If this is not unique,
and the tcp flags are normal, Flow-Portscan exits.
\item If this connection is to a destination IP in the server-watchnet:
\begin{itemize}
	\item During the ``server-learning-time,'' it increments the hitcounts for service
popularity. 

	\item If it's not during the ``server-learning-time,'' it just obtains the stored hitcount.  If the hitcount is
      greater than the server-ignore-limit, Flow-Portscan exits.  If the hitcount is less than the
      server-scanner-limit, it marks the incremented points as scanner points.
\end{itemize}
\item A connection is marked as either a talker or a scanner by step 3.

There are 4 time scales; 2 each for the IP scanner and IP talker.

The fixed timescales detect \emph{n} events in \emph{m} seconds.  This is the typical type of
portscan alert.

The sliding timescales adjust the "score reset point" on each event after the
first.  This adjusts the side of the window we're detecting portscan events in
by taking

\begin{verbatim} 
end = end + ((end - start) * sliding-scale-factor)
\end{verbatim}

Each time scale has its own point tally that is incremented per new flow.
Each set of points only touches either the talker-fixed-score and talker-sliding-score or the scanner-fixed-score and scanner-sliding-score

\item Evaluate the score against individual thresholds, either talker or
scanner. 

\begin{verbatim}
if(fixed_limit <= fixed_score)
generate_alert()
\end{verbatim}
\end{slist}

\subsubsection{Format}
\begin{verbatim}
preprocessor flow-portscan: [scoreboard-memcap-talker <bytes>] \
                            [scoreboard-rows-talker <count>] \ 
                            [scoreboard-rows-scanner <count>] \
                            [scoreboard-memcap-scanner <bytes>] \
                            [scanner-fixed-threshold <integer>] \
                            [scanner-sliding-threshold <integer>] \
                            [scanner-fixed-window <integer>] \
                            [scanner-sliding-window <integer>] \
                            [scanner-sliding-scale-factor <float>] \
                            [talker-fixed-threshold <integer>] \
                            [talker-sliding-threshold <integer>] \
                            [talker-fixed-window <integer>] \
                            [talker-sliding-window <integer>] \
                            [talker-sliding-scale-factor <float>] \
                            [unique-memcap <bytes>] \
                            [unique-rows <integer>] \
                            [server-memcap <bytes>] \
                            [server-rows <integer>] \
                            [server-watchnet <ip list in Snort notation>] \
                            [src-ignore-net <ip list in Snort notation>] \
                            [dst-ignore-net <ip list in Snort notation>] \
                            [tcp-penalties <on|off>] \
                            [server-learning-time <seconds>] \
                            [server-ignore-limit <hit count>] \
                            [server-scanner-limit <hit count>] \
                            [alert-mode <once|all>] \
                            [output-mode <msg|pktkludge>] \
                            [base-score <integer>] \
                            [dumpall <1>]    

\end{verbatim}


\begin{slist}
\item \texttt{scoreboard-rows-talker} (Default value: 100000)

Number of rows to use for the talker table. 

\item \texttt{scoreboard-rows-scanner} (Default value: 250000)

Number of rows to use for the scanner table. 

\item \texttt{unique-rows} (Default value: 1000000)

Number of rows to allocate for the uniqueness tracker.   

\item \texttt{server-rows} (Default value: 65536)

Number of rows to allocate for server learning. 

A general note about rows: higher row counts will take more memory away
from the memory caps for a specific subsystem.  In Snort output,
this is referred to as ``overhead bytes'' and the percentage of overhead
encountered will be shown.  Higher row counts provide a larger hash
table to minimize collisions, with a faster overall processing time
at the expense of memory.  The hash tables themselves use a pseudorandom
hardening salt that is picked at initialization time.

\item \texttt{scoreboard-memcap-talker} (Default value: 25165824)

Number of bytes to use for the talker table. 
 
\item \texttt{scoreboard-memcap-scanner} (Default value: 6291456)

Number of bytes to use for the scanner table. 

\item \texttt{unique-memcap} (Default value: 25165824)

Number of bytes to allocate to the uniqueness tracker. The more memory given,
the less connections to a busy server will appear as a scan target on a
popular service. 

\item \texttt{server-memcap} (Default value: 2097152)

Number of bytes to allocate for server learning. 

\item \texttt{scanner-fixed-threshold} (Default value: 15)

Number of points that a scanner must accumulate in the scanner-fixed-window
time range.  Set to 0 to disable this type of alert. 

\item \texttt{talker-fixed-threshold} (Default value: 15)

Number of points that a scanner must accumulate in talker-fixed-window time
range. Set to 0 to disable this type of alert. 

\item \texttt{scanner-sliding-threshold} (Default Value 40)

Number of points that a scanner must accumulate in scanner-sliding-window time
range. set to 0 to disable this type of alert.

\item \texttt{talker-sliding-threshold} (Default Value: 30)

Number of points that a scanner must accumulate in talker-sliding-window time
range. Set to 0 to disable this type of alert. 

\item \texttt{scanner-fixed-window} (Default Value: 15)

Number of seconds Flow-Portscan runs before resetting the fixed scanner score. 

\item \texttt{talker-fixed-window} (Default Value: 30)

Number of seconds Flow-Portscan runs before resetting the fixed talker score. 

\item \texttt{scanner-sliding-window} (Default Value: 20)

Number of seconds Flow-Portscan runs before resetting the sliding scanner score. 

\item \texttt{talker-sliding-window} (Default Value: 30)

Number of seconds Flow-Portscan runs before resetting the sliding talker score. 

\item \texttt{scanner-sliding-scale-factor} (Default Value: 0.5)

How much to increase the sliding window by each time we get a new sliding
scanner entry.  Its current size + ($<$scale factor$>$ * current\_size). 

\item \texttt{talker-sliding-scale-factor} (Default Value: 0.5)

How much to increase the sliding window by each time we get a new sliding
talker entry.  Its current size + ($<$scale factor$>$ * current\_size).  

\item \texttt{src-ignore-net}

The IP list of which source IPs to ignore.

\item \texttt{dst-ignore-net}  

The IP list of which destination IPs to ignore.

\item \texttt{tcp-penalties} (Default Value: on)

If this is enabled, when a new tcp flow enters the portscan detection set,
Flow-Portscan checks the TCP flags for non-standard session initiators and assigns penalty
points for odd combinations such as SYN+FIN. 

\item \texttt{Flag Mapping}

\begin{table}[!hbpt]
\caption{Flag Mapping}
\begin{center}\begin{tabular}{|c|c|}
\hline 
SYN or SYN+ECN bits &
base\_score (defaults to 1 point) \\
\hline 
SYN+FIN+TH\_ACK and anything else & 5 points \\
\hline 
SYN+FIN and anything else without ACK & 3 points \\
\hline 
anything else & 2 points \\
\hline
\end{tabular}\end{center}
\end{table}


\item \texttt{server-watchnet} 

The IP list of which machines to learn services on.  Busy servers should be
placed here to help the portscan detector learn what services are requested on
the network.

\item \texttt{server-learning-time} (Default Value: 28800)

Number of seconds Flow-Portscan should keep increment hitcounts of services on IPs in the
server-watchnet.  

This does not validate that the service is connected correctly. It is
possible that, while learning, someone floods the table with unique connections,
causing something to become a service that you do not wish to be a service.
It's generally assumed that the learning time will occur at a time where
traffic is ``typical.'' Future versions of Snort should allow this state to be
saved and modifiable.  If this caveat is a concern in your environment, do not
set a server watchnet and rely only on talker scores.

\item \texttt{server-ignore-limit} (Default Value: 500)

Number of requests a port on an IP in the server-watchnet must see
before it is ignored for the purposes of portscans. 

\item \texttt{server-scanner-limit} (Default Value: 500)

Number of requests a port on an IP in the server-watchnet must see before it is
is treated as a talker rather than a scanner.  This is the minimum number of
requests that must be seen during the server-learning-time for the flow to be
treated as a talker connection rather than as a scanner connection.  

\item \texttt{alert-mode}

\begin{table}[!hbpt]
\caption{Alert Modes}
\begin{center}\begin{tabular}{|c|p{5in}|}
\hline 
\texttt{once} & 
Alert only on the first time Flow-Portscan sees a scan entry hit.  This dramatically reduces clutter because the scan alert in the first place tells one to look for other event types. Default Value: once.
\\
\hline 
\texttt{all} & Alert each time the score increases beyond a threshold. \\
\hline
\end{tabular}\end{center}
\end{table}

\item \texttt{output-mode} (Default Value: msg)

\begin{table}[!hbpt]
\caption{Output Modes}
\begin{center}\begin{tabular}{|c|c|}
\hline 
\texttt{msg} & Outputs a variable text message with the scores included.  \\
\hline
\texttt{pktkludge} & Generates a fake packet and uses the logging output system. \\
\hline
\end{tabular}\end{center}
\end{table}

\item \texttt{dumpall}
When Snort is exiting, dump the entire contents of the server table,
the uniqueness tracker table, and the scoreboard entries.  This is
useful if you suspect an underlying bug in the algorithms used or if
you would just like to see what it has learned. Set this to "1" to
enable.
            
\item \texttt{base-score} (Default Value: 1)
Default score for a new connection. This is probably only useful for
debugging.

\end{slist}

\subsubsection{Example Configuration}

\begin{verbatim}
preprocessor flow-portscan: server-watchnet [10.0.0.0/8] \
                            unique-memcap 5000000 \
                            unique-rows 50000 \
                            tcp-penalties on \
                            server-scanner-limit 50 \
                            alert-mode all \
                            output-mode msg \
                            server-learning-time 3600
\end{verbatim}



\subsection{Telnet Decode\label{sub:telnet-decode}}

The telnet\_decode preprocessor allows Snort to normalize Telnet control
protocol characters from the session data. In Snort 1.9.0 and above,
it accepts a list of ports to run on as arguments. Also in 1.9.0,
it normalizes into a separate data buffer from the packet itself so
that the raw data may be logged or examined with the \texttt{rawbytes} content
modifier\ref{sub:rawbytes}.

By default, telnet\_decode runs against traffic on ports 21, 23, 25, and 119.

\subsubsection{Format}

\begin{verbatim}
preprocessor telnet_decode: <ports> 
\end{verbatim}

\subsection{RPC Decode\label{sub:rpc-decoder}}

The rpc\_decode preprocessor normalizes RPC multiple fragmented
records into a single un-fragmented record.  It does this by
normalizing the packet into the packet buffer.  If stream4 is
enabled, it will only process client-side traffic.  By default, it runs against
traffic on ports 111 and 32771.

\begin{table}[!hbpt]

\caption{RPC Decoder Options\label{rpc options}}

\begin{center}\begin{tabular}{| l | l |}
\hline 
\textbf{Option}&
\textbf{Description}\\
\hline
\hline 
\texttt{alert\_fragments}&
Alert on any fragmented RPC record.\\
\hline 
\texttt{no\_alert\_multiple\_requests}&
Don't alert when there are multiple records in one packet.\\
\hline 
\texttt{no\_alert\_large\_fragments}&
Don't alert when the sum of fragmented records exceeds one packet.\\
\hline 
\texttt{no\_alert\_incomplete}&
Don't alert when a single fragment record exceeds the size of one
packet.\\
\hline
\end{tabular}\end{center}
\end{table}

\subsubsection{Format}

\begin{verbatim}
preprocessor rpc_decode: <ports> [ alert_fragments ] \
   [no_alert_multiple_requests] [no_alert_large_fragments] \
   [no_alert_incomplete]
\end{verbatim}

\subsection{Performance Monitor\label{sub:perfmonitor}}

This preprocessor measures Snort's real-time and theoretical maximum
performance.  Whenever this preprocessor is turned on, it should have an output
mode enabled, either ``console'' which prints statistics to the console window or
``file'' with a file name, where statistics get printed to the specified file
name. By default, Snort's real-time statistics are processed. This includes:

\begin{itemize}
\item packets received
\item packets dropped
\item \% packets dropped
\item packets received
\item kpackets per second
\item average bytes per packets
\item mbits per second (wire)
\item mbits per second (rebuilt) [this is the average mbits that Snort injects after rebuilding packets]
\item mbits per second (total)
\item pattern matching percent [the average percent of data received that Snort processes in pattern matching]
\item cpu usage (user time) (system time) (idle time)
\item alerts per second
\item syn packets per second
\item syn/ack packet per second
\item new sessions per second
\item deleted sessions per second
\item total sessions
\item max sessions during time interval
\item stream flushes per second
\item stream faults per second
\item stream timeouts
\item frag completes per second
\item frag inserts per second
\item frag deletes per second
\item frag flushes per second
\item frag timeouts
\item frag faults
\end{itemize}

The following options can be used with the Performance Monitor:

\begin{itemize}
\item \texttt{flow} - Prints out statistics about the type
of traffic and protocol distributions that Snort is seeing. This option can
produce large amounts of output.

\item \texttt{events} - Turns on event reporting.  This prints out statistics as
to the number of signatures that were matched by the setwise pattern matcher 
(\textit{non-qualified events}) and the number of those matches that were 
verified with the signature flags (\textit{qualified events}).
This shows the user if there
is a problem with the ruleset that they are running.

\item \texttt{max} - Turns on the theoretical maximum performance that Snort
calculates given the processor speed and current performance.  This is only
valid for uniprocessor machines, since many operating systems don't keep
accurate kernel statistics for multiple CPUs.  

\item \texttt{console} - Prints statistics at the console, this is enabled by default.  

\item \texttt{file} - Prints statistics in a comma-delimited format to the file
that is specified.  Not all statistics are output to this file.  You may also
use \texttt{snortfile} which will output into your defined Snort log directory.  

\item \texttt{pktcnt} - Adjusts the number of packets to process before checking for
the time sample.  This boosts performance, since checking the time sample
reduces Snort's performance.  By default, this is 10000.  

\item \texttt{time} - Represents the number of seconds between intervals.

\item \texttt{accumulate} or \texttt{reset} - Defines what type of drop statistics
are kept by the operating system. By default, \texttt{accumulate} is used.

\end{itemize}
\subsubsection{Examples}

\begin{verbatim}
preprocessor perfmonitor: time 30 events flow file stats.profile max \
    console pktcnt 10000 
preprocessor perfmonitor: time 300 file /var/tmp/snortstat pktcnt 10000
\end{verbatim}

\subsection{HTTP Inspect \label{sub:http-inspect}}

HTTPInspect is a generic HTTP decoder for user applications.  Given a data
buffer, HTTPInspect will decode the buffer, find HTTP fields, and normalize the
fields.  HTTPInspect works on both client requests and server responses.

The current version of HTTPInspect only handles stateless processing.  This
means that HTTPInspect looks for HTTP fields on a packet-by-packet basis, and
will be fooled if packets are not reassembled.  This works fine when there is
another module handling the reassembly, but there are limitations in analyzing
the protocol.  Future versions will have a stateful processing mode which will
hook into various reassembly modules.

HTTPInspect has a very ``rich'' user configuration.  Users can configure
individual HTTP servers with a variety of options, which should allow the user
to emulate any type of web server. Within HTTPInspect, there are two areas of
configuration: global and server.

\subsubsection{Global Configuration}

The global configuration deals with configuration options that determine the
global functioning of HTTPInspect.  The following example gives the generic
global configuration format:

\subsubsection{Format}
\begin{verbatim}
preprocessor http_inspect: global \
                           iis_unicode_map <map_filename> \
                           codemap <integer> \
                           [detect_anomalous_servers] \
                           [proxy_alert]
\end{verbatim}

You can only have a single global configuration, you'll get an error if you try
otherwise.

\paragraph{Configuration}
\begin{slist}
\item \texttt{iis\_unicode\_map $<$map\_filename$>$ [codemap $<$integer$>$]}

This is the global iis\_unicode\_map file.  The iis\_unicode\_map is a required
configuration parameter.  The map file can reside in the same directory as
snort.conf or specified via a fully-qualified path to the map file.

The iis\_unicode\_map file is a Unicode codepoint map which tells HTTPInspect
which codepage to use when decoding Unicode characters.  For US servers, the
codemap is usually 1252.

A Microsoft US Unicode codepoint map is provided in the snort source \emph{etc}
directory by default.  It is called \emph{unicode.map} and should be used if no
other codepoint map is available.  A tool is supplied with Snort to generate
custom Unicode maps--ms\_unicode\_generator.c, which is available at
\url{http://www.snort.org/dl/contrib/}.

\begin{note}
Remember that this configuration is for the global IIS Unicode map---individual
servers can reference their own IIS Unicode map.
\end{note}

\item \texttt{detect\_anomalous\_servers}

This global configuration option enables generic HTTP server traffic
inspection on non-HTTP configured ports, and alerts if HTTP traffic is seen.
Don't turn this on if you don't have a default server configuration that
encompasses all of the HTTP server ports that your users might access.  In the
future, we want to limit this to specific networks so it's more useful, but
for right now, this inspects all network traffic.

\item \texttt{proxy\_alert}

This enables global alerting on HTTP server proxy usage.  By configuring
HTTPInspect servers and enabling \texttt{allow\_proxy\_use}, you will only receive proxy
use alerts for web users that aren't using the configured proxies or are using
a rogue proxy server.

Please note that if users aren't required to configure web proxy use, then
you may get a lot of proxy alerts.  So, please only use this feature with
traditional proxy environments. Blind firewall proxies don't count.

\end{slist}
\subsubsection{Example Global Configuration}

\begin{verbatim}
preprocessor http_inspect: global iis_unicode_map unicode.map 1252
\end{verbatim}

\subsubsection{Server Configuration}
There are two types of server configurations: default and by IP address.

\paragraph{Default}

This configuration supplies the default server configuration for any server
that is not individually configured.  Most of your web servers will most likely
end up using the default configuration.

\subsubsection{Example Default Configuration}
\begin{verbatim}
preprocessor http_inspect_server: server default profile all ports { 80 }
\end{verbatim}

\paragraph{Configuration by IP Address}
This format is very similar to ``default,'' the only difference being that
specific IPs can be configured.

\subsubsection{Example IP Configuration}
\begin{verbatim}
preprocessor http_inspect_server: server 10.1.1.1 profile all ports { 80 }
\end{verbatim}

\subsubsection{Server Configuration Options}

Important: Some configuration options have an argument of `yes' or `no'.  This
argument specifies whether the user wants the configuration option to generate
an httpinspect alert or not.  the `yes/no' argument does not specify whether
the configuration option itself is on or off, only the alerting functionality.
in other words, whether set to `yes' or 'no', HTTP normalization will still
occur, and rules based off HTTP traffic will still trigger.

\begin{slist}
\item \texttt{profile $<$all$|$apache$|$iis$>$}

Users can configure HTTPInspect by using pre-defined HTTP server profiles.
Profiles allow the user to easily configure the preprocessor for a certain
type of server, but are not required for proper operation. 

There are three profiles available: all, apache, and iis.

\begin{subslist}

\item \texttt{all}

The ``\texttt{all}'' profile is meant to normalize the URI using most of the common tricks
available.  We alert on the more serious forms of evasions.  This is a great
profile for detecting all types of attacks, regardless of the HTTP server.
``\texttt{profile all}'' sets the configuration options described in Table \ref{profile_all_options}.

\begin{table}[!bthp]
\caption{Options for the ``all'' Profile\label{profile_all_options}}
\begin{center}\begin{tabular}{| l | p{3.5in} |}
\hline
\textbf{Option} & \textbf{Setting} \\
\hline
\hline
flow\_depth & 300 \\
\hline
chunk encoding & alert on chunks larger than 500000 bytes \\
\hline
iis\_unicode\_map & codepoint map in the global configuration \\
\hline
ascii decoding & on, alert off \\
\hline
%looking for null bytes in url & on, alert on \\
%\hline
multiple slash & on, alert off \\
\hline
directory normalization & on, alert off \\
\hline
apache whitespace & on, alert off \\
\hline
double decoding & on, alert on \\
\hline
\%u decoding & on, alert on \\
\hline
bare byte decoding & on, alert on \\
\hline
iis unicode codepoints & on, alert on \\
\hline
iis backslash & on, alert off \\
\hline
iis delimiter & on, alert off \\
\hline
webroot & on, alert on\\
\hline
non\_strict URL parsing & on\\
\hline
\end{tabular}\end{center}
\end{table}


\item \texttt{apache} 

The ``\texttt{apache}'' profile is used for Apache web servers.  This differs from the
``iis'' profile by only accepting UTF-8 standard Unicode encoding and not
accepting backslashes as legitimate slashes, like IIS does.  Apache also
accepts tabs as whitespace.  ``\texttt{profile apache}'' sets the configuration
options described in Table \ref{profile_apache_options}.

\begin{table}[!hbpt]
\caption{Options for the ``apache'' Profile\label{profile_apache_options}}
\begin{center}\begin{tabular}{| l | p{3.5in} |}
\hline
\textbf{Option} & \textbf{Setting}\\
\hline
\hline
flow\_depth & 300 \\
\hline
chunk encoding & alert on chunks larger than 500000 bytes \\
\hline
ascii decoding & on, alert off \\
%\hline
%looking for null bytes in url & on, alert on \\
\hline
multiple slash & on, alert off \\
\hline
directory normalization & on, alert off \\
\hline
webroot & on, alert on\\
\hline
apache whitespace & on, alert on \\
\hline
utf\_8 encoding & on, alert off \\
\hline
non\_strict url parsing & on \\
\hline
\end{tabular}\end{center}
\end{table}

\item \texttt{iis}

The ``\texttt{iis}'' profile mimics IIS servers.  So that means we use IIS Unicode
codemaps for each server, \%u encoding, bare-byte encoding, double decoding,
backslashes, etc. ``\texttt{profile iis}'' sets the configuration options described in
Table \ref{profile_iis_options}.

\begin{table}[!hbpt]
\caption{Options for the ``iis'' Profile\label{profile_iis_options}}
\begin{center}\begin{tabular}{| l | p{3.5in} |}
\hline
\textbf{Option} & \textbf{Setting}\\
\hline
\hline
flow\_depth & 300 \\
\hline
chunk encoding & alert on chunks larger than 500000 bytes\\
\hline
iis\_unicode\_map & codepoint map in the global configuration \\
\hline
ascii decoding & on, alert off \\
\hline
multiple slash & on, alert off \\
\hline
directory normalization & on, alert off \\
\hline
webroot & on, alert on\\
\hline
double decoding & on, alert on \\
\hline
\%u decoding & on, alert on \\
\hline
bare byte decoding & on, alert on \\
\hline
iis unicode codepoints & on, alert on \\
\hline
iis backslash & on, alert off \\
\hline
iis delimiter & on, alert on \\
\hline
apache whitespace & on, alert on \\
\hline
non\_strict URL parsing & on\\
\hline
\end{tabular}\end{center}
\end{table}

The default options used by HTTP Inspect do not use a profile and are described 
in Table \ref{default_HTTP_Inspect_options}.

\begin{table}[!hbpt]
\caption{Default HTTP Inspect Options\label{default_HTTP_Inspect_options}}
\begin{center}\begin{tabular}{| l | p{3.5in} |}
\hline
\textbf{Option} & \textbf{Setting}\\
\hline
\hline
port & 80\\
\hline
flow\_depth & 300 \\
\hline
chunk encoding & alert on chunks larger than 500000 bytes\\
\hline
ascii decoding & on, alert off \\
\hline
utf\_8 encoding & on, alert off\\
\hline
multiple slash & on, alert off \\
\hline
directory normalization & on, alert off \\
\hline
webroot & on, alert on\\
\hline
iis backslash & on, alert off \\
\hline
apache whitespace & on, alert off \\
\hline
iis delimiter & on, alert off \\
\hline
non\_strict URL parsing & on\\
\hline
\end{tabular}\end{center}
\end{table}
\clearpage
Profiles must be specified as the first server option and cannot be combined
with any other options except:
\begin{itemize}
\item \texttt{ports}
\item \texttt{iis\_unicode\_map}
\item \texttt{allow\_proxy\_use}
\item \texttt{flow\_depth}
\item \texttt{no\_alerts}
\item \texttt{inspect\_uri\_only}
\item \texttt{oversize\_dir\_length} 
\end{itemize}
These options must be specified after the `profile' option.
\end{subslist}

\subsubsection{Example}
\begin{verbatim}
preprocessor http_inspect_server: server 1.1.1.1 profile all ports { 80 3128 }
\end{verbatim}
                             
\item \texttt{ports $\{ <$port$> [<$port$> <...>] \}$}

This is how the user configures which ports to decode on the HTTP server.
Encrypted traffic (SSL) cannot be decoded, so adding port 443 will only
yield encoding false positives.

\item \texttt{iis\_unicode\_map $<$map\_filename$>$ codemap $<$integer$>$}

The IIS Unicode map is generated by the program ms\_unicode\_generator.c.  This
program is located on the Snort.org web site at \url{http://www.snort.org/dl/contrib/}
directory.  Executing this program
generates a Unicode map for the system that it was run on.  So, to get the
specific Unicode mappings for an IIS web server, you run this program on that
server and use that Unicode map in this configuration.

When using this option, the user needs to specify the file that contains the
IIS Unicode map and also specify the Unicode map to use.  For US servers, this
is usually 1252.  But the ms\_unicode\_generator program tells you which codemap
to use for you server, it's the ANSI code page.  You can select the correct code
page by looking at the available code pages that the ms\_unicode\_generator
outputs.

\item \texttt{flow\_depth $<$integer$>$}

This specifies the amount of server response payload to inspect.  This option
significantly increases IDS performance because we are ignoring a large part of
the network traffic (HTTP server response payloads).  A small percentage of
Snort rules are targeted at this traffic and a small flow\_depth value may
cause false negatives in some of these rules.  Most of these rules target
either the HTTP header, or the content that is likely to be in the first
hundred or so bytes of non-header data.  Headers are usually under 300 bytes
long, but your mileage may vary.

This value can be set from 0 to 1460, with a value of 0 inspecting all HTTP
server payloads (note that this will likely slow down IDS performance).  Values
above 0 tell http\_inspect the number of bytes to inspect in the first packet
of the server response.

\item \texttt{ascii $<$yes$|$no$>$}

The \texttt{ascii} decode option tells us whether to decode encoded ASCII chars, a.k.a
\%2f = /, \%2e = ., etc.  It is normal to see ASCII encoding usage in URLs, so it
is recommended that you disable HTTPInspect alerting for this option.

\item \texttt{utf\_8 $<$yes$|$no$>$}

The \texttt{utf-8} decode option tells HTTPInspect to decode standard UTF-8 Unicode
sequences that are in the URI.  This abides by the Unicode standard and only
uses \% encoding.  Apache uses this standard, so for any Apache servers, make
sure you have this option turned on.  As for alerting, you may be interested in
knowing when you have a UTF-8 encoded URI, but this will be prone to false
positives as legitimate web clients use this type of encoding.  When \texttt{utf\_8} is
enabled, ASCII decoding is also enabled to enforce correct functioning.  

\item \texttt{u\_encode $<$yes$|$no$>$}

This option emulates the IIS \%u encoding scheme.  How the \%u encoding scheme
works is as follows:  the encoding scheme is started by a \%u followed by 4
characters, like \%uxxxx.  The xxxx is a hex-encoded value that correlates to an IIS
Unicode codepoint.  This value can most definitely be ASCII.  An ASCII character is
encoded like \%u002f = /, \%u002e = ., etc.  If no iis\_unicode\_map is specified
before or after this option, the default codemap is used.

You should alert on \%u encodings, because we are not aware of any legitimate
clients that use this encoding.  So it is most likely someone trying to be
covert.

\item \texttt{bare\_byte $<$yes$|$no$>$}

Bare byte encoding is an IIS trick that uses non-ASCII characters as valid values when
decoding UTF-8 values.  This is not in the HTTP standard, as all non-ASCII
values have to be encoded with a \%.  Bare byte encoding allows the user to
emulate an IIS server and interpret non-standard encodings correctly.

The alert on this decoding should be enabled, because there are no legitimate
clients that encode UTF-8 this way since it is non-standard.

\item \texttt{base36 $<$yes$|$no$>$}

This is an option to decode base36 encoded chars.  This option is based off of
info from 
\url{http://www.yk.rim.or.jp/~shikap/patch/spp\_http\_decode.patch}.

If \%u encoding is enabled, this option will not work.  You have to use the
base36 option with the utf\_8 option.  Don't use the \%u option, because base36
won't work.  When base36 is enabled, ASCII encoding is also enabled to enforce correct
behavior.

\item \texttt{iis\_unicode $<$yes$|$no$>$}

The \texttt{iis\_unicode} option turns on the Unicode codepoint mapping.  If there is no
iis\_unicode\_map option specified with the server config, \texttt{iis\_unicode} uses the
default codemap.  The \texttt{iis\_unicode} option handles the mapping of non-ASCII
codepoints that the IIS server accepts and decodes normal UTF-8 request.

You should alert on the \texttt{iis\_unicode option}, because it is seen mainly in
attacks and evasion attempts.  When \texttt{iis\_unicode} is enabled, ASCII and
UTF-8 decoding are also enabled to enforce correct decoding.  To alert on UTF-8 decoding, you
 must enable also enable \texttt{utf\_8 yes}. 

\item \texttt{double\_decode $<$yes$|$no$>$}
The \texttt{double\_decode} option is once again IIS-specific and emulates IIS
functionality.  How this works is that IIS does two passes through the request
URI, doing decodes in each one.  In the first pass, it seems that all types of
iis encoding is done: utf-8 unicode, ascii, bare byte, and \%u.  In the second
pass, the following encodings are done:  ascii, bare byte, and \%u.  We leave out
utf-8 because I think how this works is that the \% encoded utf-8 is decoded to
the Unicode byte in the first pass, and then UTF-8 is decoded in the second stage.
Anyway, this is really complex and adds tons of different encodings for one
character.  When double\_decode is enabled, so ASCII is also enabled to enforce correct decoding.

\item \texttt{non\_rfc\_char $\{ <$byte$> [<$byte ...$>] \}$}

This option lets users receive an alert if certain non-RFC chars are used in a
request URI.  For instance, a user may not want to see null bytes in the
request URI and we can alert on that.  Please use this option with
care, because you could configure it to say, alert on all `/' or something like
that.  It's flexible, so be careful.

\item \texttt{multi\_slash $<$yes$|$no$>$}

This option normalizes multiple slashes in a row, so something like:
``foo/////////bar'' get normalized to ``foo/bar.''

If you want an alert when multiple slashes are seen, then configure with a \texttt{yes},
otherwise, use \texttt{no}.

\item \texttt{iis\_backslash $<$yes$|$no$>$}

Normalizes backslashes to slashes.  This is again an IIS emulation.  So a
request URI of ``/foo$\backslash$bar'' gets normalized to ``/foo/bar.''

\item \texttt{directory $<$yes$|$no$>$}

This option normalizes directory traversals and self-referential directories.

The directory:
\begin{verbatim} /foo/fake\_dir/../bar \end{verbatim}
gets normalized to:
\begin{verbatim} /foo/bar \end{verbatim}

The directory:
\begin{verbatim} /foo/./bar \end{verbatim}
gets normalized to:
\begin{verbatim} /foo/bar \end{verbatim}

If you want to configure an alert, specify ``yes'', otherwise, specify ``no.''
This alert may give false positives, since some web sites refer to files using
directory traversals.

\item \texttt{apache\_whitespace $<$yes$|$no$>$}

This option deals with the non-RFC standard of using tab for a space delimiter.  Apache
uses this, so if the emulated web server is Apache, enable this
option.  Alerts on this option may be interesting, but may also be false
positive prone.

\item \texttt{iis\_delimiter $<$yes$|$no$>$}

This started out being IIS-specific, but Apache takes this non-standard
delimiter was well.  Since this is common, we always take this as standard
since the most popular web servers accept it.  But you can still get an alert
on this option.

\item \texttt{chunk\_length $<$non-zero positive integer$>$}

This option is an anomaly detector for abnormally large chunk sizes.  This
picks up the Apache chunk encoding exploits, and may also alert on HTTP
tunneling that uses chunk encoding.

\item \texttt{no\_pipeline\_req}

This option turns HTTP pipeline decoding off, and is a performance enhancement
if needed.  By default, pipeline requests are inspected for attacks, but when
this option is enabled, pipeline requests are not decoded and analyzed per
HTTP protocol field.  It is only inspected with the generic pattern
matching.

\item \texttt{non\_strict}

This option turns on non-strict URI parsing for the broken way in which Apache
servers will decode a URI.  Only use this option on servers that will accept
URIs like this: "get /index.html alsjdfk alsj lj aj  la jsj s$\backslash$n".  The
non\_strict option assumes the URI is between the first and second space even if
there is no valid HTTP identifier after the second space.

\item \texttt{allow\_proxy\_use}

By specifying this keyword, the user is allowing proxy use on this server.
This means that no alert will be generated if the proxy\_alert global keyword
has been used.  If the proxy\_alert keyword is not enabled, then this option
does nothing.  The allow\_proxy\_use keyword is just a way to suppress
unauthorized proxy use for an authorized server.  

\item \texttt{no\_alerts}

This option turns off all alerts that are generated by the HTTPInspect
preprocessor module.  This has no effect on HTTP rules in the ruleset.  No
argument is specified.

\item \texttt{oversize\_dir\_length $<$non-zero positive integer$>$}

This option takes a non-zero positive integer as an argument.  The argument
specifies the max char directory length for URL directory.  If a url directory
is larger than this argument size, an alert is generated. A good argument
value is 300 characters.  This should limit the alerts to IDS evasion type attacks,
like whisker -i 4.

\item \texttt{inspect\_uri\_only}

This is a performance optimization.  When enabled, only the URI portion of HTTP
requests will be inspected for attacks.  As this field usually contains 90-95\%
of the web attacks, you'll catch most of the attacks.  So if you need extra
performance, enable this optimization.  It's important to note that if
this option is used without any uricontent rules, then no inspection will take
place.  This is obvious since the URI is only inspected with uricontent rules,
and if there are none available, then there is nothing to inspect.

For example, if we have the following rule set:

\begin{verbatim}
alert tcp any any -> any 80 ( msg:"content"; content: "foo"; )
\end{verbatim}

and the we inspect the following URI:
\begin{verbatim}
get /foo.htm http/1.0\r\n\r\n
\end{verbatim}

No alert will be generated when `inspect\_uri\_only' is enabled.  The
`inspect\_uri\_only' configuration turns off all forms of detection except
uricontent inspection.

\item webroot

This option generates an alert when a directory traversal traverses past
the web server root directory.  This generates much fewer false positives than
the directory option, because it doesn't alert on directory traversals that
stay within the web server directory structure.  It only alerts when the
directory traversals go past the web server root directory, which
is associated with certain web attacks.

\end{slist}

\subsubsection{Examples}

\begin{verbatim}
preprocessor http_inspect_server: server 10.1.1.1 \
                        ports { 80 3128 8080 } \
                        flow_depth 0 \
                        ascii no \
                        double_decode yes \
                        non_rfc_char { 0x00 } \
                        chunk_length 500000 \
                        non_strict \
                        no_alerts

preprocessor http_inspect_server: server default \ 
                        ports  { 80 3128 }  \
                        non_strict \
                        non_rfc_char  { 0x00 }  \
                        flow_depth 300  \
                        apache_whitespace yes \
                        directory no \
                        iis_backslash no \
                        u_encode yes \
                        ascii no \
                        chunk_length 500000 \
                        bare_byte yes \
                        double_decode yes \
                        iis_unicode yes \ 
                        iis_delimiter yes \
                        multi_slash no

preprocessor http_inspect_server: server default \
                        profile all \
                        ports { 80 8080 }
\end{verbatim}

\subsection{ASN.1 Detection\label{asn1}}


The asn.1 detection plugin decodes a packet or a portion of a packet, and looks
for various malicious encodings.

The general configuration of the asn.1 rule option is as follows:

\begin{verbatim}
asn1: [keyword [argument]], . . . 
\end{verbatim}

Multiple keywords can be used in an 'asn1' option and the implied logic is
boolean OR.  So if any of the arguments evaluate as true, the whole option
evaluates as true.

\subsubsection{ASN.1 Keywords\label{asn1 keywords}}


The ASN.1 keywords provide programmatic detection capabilities as well as some
more dynamic type detection.  Most of the keywords don't have arguments as the
detection is looking for non-configurable information.  If a keyword does have
an argument, the keyword is followed by a comma and the argument is the next
word.  If a keyword has multiple arguments, then a comman separates each.

\begin{slist}

\item \texttt{bitstring\_overflow}


The \texttt{bitstring\_overflow} option detects invalid bitstring encodings that are known to be
remotely exploitable.

\item \texttt{double\_overflow}


The double\_overflow detects a double ASCII encoding that is larger than a
standard buffer.  This is known to be an exploitable function in Microsoft, but
it is unknown at this time which services may be exploitable.

\item \texttt{oversize\_length}


This detection keyword compares ASN.1 type lengths with the supplied argument.
The syntax looks like, ``oversize\_length 500''.  This means that if an ASN.1
type is greater than 500, then this keyword is evaluated as true.  This
keyword must have one argument which specifies the length to compare against.

\item \texttt{absolute\_offset}


This is the absolute offset from the beginning of the packet.  For example, if
you wanted to decode snmp packets, you would say ``absolute\_offset, 0''.  
\texttt{absolute\_offset} has one argument---the offset value.  Offset may be
positive or negative.

\item \texttt{relative\_offset}


This is the relative offset from the last content match or byte\_test/jump. 
\texttt{relative\_offset} has one argument---the offset number.  So if you 
wanted to start decoding and ASN.1 sequence right after the content ``foo'', 
you would specify \verb!'content:"foo"; asn1: bitstring_overflow, relative_offset, 0'!.  Offset values may be positive or negative.

\end{slist}

\subsubsection{ASN.1 Examples}

The following rules use ASN.1 decoding options:

\begin{verbatim}
alert udp any any -> any 161 (msg:"Oversize SNMP Length"; \
    asn1: oversize_length, 10000, absolute_offset, 0;)
    
alert tcp any any -> any 80 (msg:"ASN1 Relative Foo"; content:"foo"; \
    asn1: bitstring_overflow, print, relative_offset, 0;)
\end{verbatim}

\subsection{X-Link2State Mini-Preprocessor\label{X-Link2State}}

This mini-preprocessor is designed to detect the X-Link2State (\url{
www.microsoft.com/technet/security/bulletin/MS05-021.mspx}) vulnerability
in Microsoft Exchange Server.

\begin{note}
The X-Link2State functionality will be rolled up into an SMTP
preprocessor in the Snort v2.5 timeframe.
\end{note}

\subsubsection{Format}
\begin{verbatim}
preprocessor xlink2state: ports { <port> [<port> <...>] } [drop]
\end{verbatim}

\subsubsection{Example Configuration}
\begin{verbatim}
preprocessor xlink2state: ports { 25 691 }
\end{verbatim}

\begin{table}[!hbpt]

\caption{X-Link2State Options\label{X-Link2State Options}}

\begin{center}\begin{tabular}{| l | l |}
\hline
\textbf{Option} & \textbf{Description}\\
\hline
\hline
ports & List of space-separated ports to inspect\\
\hline
drop & Drop this connection (Inline-mode only)\\
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage

\section{Event Thresholding}

Event thresholding can be used to reduce the number of logged alerts for noisy
rules.  This can be tuned to significantly reduce false alarms, and it can also
be used to write a newer breed of rules. Thresholding commands limit the number
of times a particular event is logged during a specified time interval. 

There are 3 types of thresholding:

\begin{itemize} 

\item \texttt{limit} 

Alerts on the 1st \textit{m} events during the time interval, then ignores events for the
rest of the time interval.

\item \texttt{threshold} 

Alerts every \textit{m} times we see this event during the time interval.

\item \texttt{both} 

Alerts once per time interval after seeing \textit{m} occurrences of the event, then
ignores any additional events during the time interval.
\end{itemize}


Thresholding commands can be included as part of a rule, or you can use
standalone threshold commands that reference the generator and SID they are
applied to. There is no functional difference between adding a threshold to a
rule, or using a separate threshold command applied to the same rule.   There
is a logical difference.  Some rules may only make sense with a threshold.
These should incorporate the threshold command into the rule.  For instance, a
rule for detecting a too many login password attempts may require more than 5
attempts.  This can be done using the `limit' type of threshold command.  It
makes sense that the threshold feature is an integral part of this rule.

In order for rule thresholds to apply properly, these rules must contain a
SID.

Only one threshold may be applied to any given generator and SID pair.  If more
than one threshold is applied to a generator and SID pair, Snort will terminate
with an error while reading the configuration information. 
                 
\subsection{Standalone Options}

This format supports 6 threshold options as described in Table \ref{standalone_options}---all are required.

\begin{table}[!htbp]
\caption{Standalone Options\label{standalone_options}}
\begin{center}\begin{tabular}{| l | p{3.5in} |}
\hline
\textbf{Option} & \textbf{Arguments}\\
\hline
\hline
\texttt{gen\_id} & $<$generator ID$>$\\
\hline
\texttt{sig\_id} & $<$Snort signature ID$>$ \\
\hline
\texttt{type} & \texttt{limit}, \texttt{threshold}, or \texttt{both} \\
\hline
\texttt{track} & \texttt{by\_src} or \texttt{by\_dst} \\
\hline
\texttt{count} & $<$number of events$>$ \\
\hline
\texttt{seconds} & $<$time period over which count is accrued$>$ \\
\hline
\end{tabular}\end{center}
\end{table}

\subsection{Standalone Format}
\begin{verbatim}
threshold gen_id <gen-id>, sig_id <sig-id>, \
    type <limit|threshold|both>, \
    track <by_src|by_dst>, count <s>, seconds <m>  
\end{verbatim}


\subsection{Rule Keyword Format}

This format supports 4 threshold options as described in Table \ref{rule_keyword_options}---all are required.

\begin{table}[!hbpt]
\caption{Rule Keyword Options\label{rule_keyword_options}}
\begin{center}\begin{tabular}{| l | p{3.5in} |}
\hline
\textbf{Option} & \textbf{Arguments}\\
\hline
\hline
\texttt{type} & \texttt{limit}, \texttt{threshold}, or \texttt{both} \\
\hline
\texttt{track} & \texttt{by\_src} or \texttt{by\_dst} \\
\hline
\texttt{count} & $<$number of events$>$ \\
\hline
\texttt{seconds} & $<$time period over which count is accrued$>$ \\
\hline
\end{tabular}\end{center}
\end{table}

\subsection{Rule Keyword Format}
\begin{verbatim}
threshold: type <limit|threshold|both>, track <by_src|by_dst>, \
     count <n>, seconds <m>;
\end{verbatim}

For either standalone or rule format, all tracking is by src or by dst ip,
ports or anything else are not tracked.

Thresholding can also be used globally, this allows you to specify a threshold
for every rule.  Standard thresholding tests are applied first to an event, if
they do not block a rule from being logged, and then the global thresholding
test is applied---thresholds in a rule will override a global threshold. Global 
thresholds do not override what's in a signature or a more specific stand-alone 
threshold.


The global threshold options are the same as the standard threshold options
with the exception of the `\texttt{sig\_id}' field.  The \texttt{sig\_id} field must be set to 0 to
indicate that this threshold command applies to all \texttt{sig\_id} values with the specified
\texttt{gen\_id}. To apply the same threshold to all \texttt{gen\_id}'s at the same time, and with
just one command specify a value of \texttt{gen\_id=0}.

The format for global threshold commands is as such:

\begin{verbatim}
threshold gen_id <gen-id>, sig_id 0, \
    type <limit|threshold|both>, \
    track <by_src|by_dst>, \
    count <n>, \
    seconds <m>  
\end{verbatim}

This applies a threshold to every event from $<$gen-id$>$.

or 

\begin{verbatim}
threshold gen_id 0 , sig_id 0, \
    type <limit|threshold|both>, \
    track <by_src|by_dst>, \
    count <n>, \
    seconds <m>
\end{verbatim}

This applies a threshold to every event from every gen-id. 

\subsection{Examples}
\subsubsection{Standalone Thresholds}

Limit logging to 1 event per 60 seconds:
\begin{verbatim}
threshold gen_id 1, sig_id 1851, \
    type limit, track by_src,  \
    count 1, seconds 60
\end{verbatim}

Limit logging to every 3rd event:
\begin{verbatim}
threshold gen_id 1, sig_id 1852,  \
    type threshold, track by_src, \
    count 3, seconds 60
\end{verbatim}

Limit logging to just 1 event per 60 seconds, but only if we exceed 30 events in 60 seconds:
\begin{verbatim}
threshold gen_id 1, sig_id 1853, \
    type both, track by_src, \
    count 30, seconds 60
\end{verbatim}

\subsubsection{Rule Thresholds}

This rule logs the first event of this SID every 60 seconds.

\begin{verbatim}
alert tcp $external_net any -> $http_servers $http_ports \
    (msg:"web-misc robots.txt access"; flow:to_server, established; \
    uricontent:"/robots.txt"; nocase; reference:nessus,10302; \
    classtype:web-application-activity; threshold: type limit, track \
    by_src, count 1 , seconds 60 ; sid:1000852; rev:1;)
\end{verbatim}
                 

This rule logs every 10th event on this SID during a 60 second interval. So if
less than 10 events occur in 60 seconds, nothing gets logged.  Once an event is
logged, a new time period starts for type=threshold.

\begin{verbatim}
alert tcp $external_net any -> $http_servers $http_ports \
    (msg:"web-misc robots.txt access"; flow:to_server, established; \
    uricontent:"/robots.txt"; nocase; reference:nessus,10302; \
    classtype:web-application-activity; threshold: type threshold, \
    track by_dst, count 10 , seconds 60 ; sid:1000852; rev:1;)
\end{verbatim}


This rule logs at most one event every 60 seconds if at least 10 events on this SID are fired.

\begin{verbatim}
alert tcp $external_net any -> $http_servers $http_ports \
    (msg:"web-misc robots.txt access"; flow:to_server, established; \
    uricontent:"/robots.txt"; nocase; reference:nessus,10302; \
    classtype:web-application-activity; threshold: type both , track \
    by_dst, count 10 , seconds 60 ; sid:1000852; rev:1;)
\end{verbatim}

\subsubsection{Global Thresholds}

Limit to logging 1 event per 60 seconds per IP triggering each rule (rule gen\_id is 1):
\begin{verbatim}
threshold gen_id 1, sig_id 0, type limit, track by_src, count 1, seconds 60
\end{verbatim}

Limit to logging 1 event per 60 seconds per IP, triggering each rule for each event generator:
\begin{verbatim}
threshold gen_id 0, sig_id 0, type limit, track by_src, count 1, seconds 60
\end{verbatim}

Events in Snort are generated in the usual way, thresholding is handled as part
of the output system. Read gen-msg.map for details on gen ids.

Users can also configure a memcap for threshold with a ``config:'' option:

\begin{verbatim}
config threshold: memcap <bytes>
\end{verbatim}

\clearpage
\section{Event Suppression}
Event suppression stops specified events from firing without removing the rule
from the rule base. Suppression uses a CIDR block notation to select specific
networks and users for suppression.  Suppression tests are performed prior to
either standard or global thresholding tests.

Suppression commands are standalone commands that reference generators, SIDs,
and IP addresses via a CIDR block. This allows a rule to be completely
suppressed, or suppressed when the causative traffic is going to or coming
from a specific IP or group of IP addresses.

You may apply multiple suppression commands to a SID.  You may also combine one
threshold command and several suppression commands to the same SID.  

\subsection{Format}

The suppress command supports either 2 or 4 options, as described in Table \ref{suppression_options}. 

\begin{table}[!hbpt]
\caption{Suppression Options\label{suppression_options}}
\begin{center}\begin{tabular}{| l | p{3.5in} | l |}
\hline
\textbf{Option} & \textbf{Argument} & \textbf{Required?}\\
\hline
\hline
\texttt{gen\_id} & $<$generator id$>$ & required\\
\hline
\texttt{sig\_id} & $<$Snort signature id$>$  & required\\
\hline
\texttt{track} & \texttt{by\_src} or \texttt{by\_dst}  & optional, requires ip\\
\hline
\texttt{ip} & ip[/mask] & optional, requires track \\
\hline
\end{tabular}\end{center}
\end{table}

\begin{verbatim}
suppress gen_id <gen-id>, sid_id <sid-id>, \
    track <by_src|by_dst>, ip <ip|mask-bits>
\end{verbatim}

\subsection{Examples}
Suppress this event completely:
\begin{verbatim}
Suppress gen_id 1, sig_id 1852:
\end{verbatim}

Suppress this event from this IP:
\begin{verbatim}
suppress gen_id 1, sig_id 1852, track by_src, ip 10.1.1.54
\end{verbatim}

Suppress this event to this CIDR block:
\begin{verbatim}
suppress gen_id 1, sig_id 1852, track by_dst, ip 10.1.1.0/24
\end{verbatim}

\clearpage
\section{Snort Multi-Event Logging (Event Queue)\label{eventqueue}}

Snort supports logging multiple events per packet/stream that are prioritized
with different insertion methods, such as max content length or event
ordering using the event queue.

The general configuration of the event queue is as follows:

\begin{verbatim}
config event_queue: [max_events [size]] [log [size]] [order_events [TYPE]]
\end{verbatim}

\subsection{Event Queue Configuration Options}

There are three configuration options to the configuration parameter
'event\_queue'.

\begin{slist}
\item \texttt{max\_queue}

This determines the maximum size of the event queue.  For example, if the
event queue has a max size of 8, only 8 events will be stored for a single
packet or stream.

The default value is 8.

\item \texttt{log}

This determines the number of events to log for a given packet or stream.
You can't log more than the max\_event number that was specified.

The default value is 3.

\item \texttt{order\_events}

This argument determines the way that the incoming events are ordered.  We
currently have two different methods:

\begin{itemize}
  \item \texttt{priority} - The highest priority (1 being the highest) events are ordered
    first.

  \item \texttt{content\_length} - Rules are ordered before decode or preprocessor alerts,
    and rules that have a longer content are ordered before rules with
    shorter contents.
\end{itemize}

The method in which events are ordered does not affect rule types such as
pass, alert, log, etc.

The default value is content\_length.
\end{slist}
\subsection{Event Queue Configuration Examples}

The default configuration:
\begin{verbatim}
config event_queue: max_queue 8 log 3 order_events content_length
\end{verbatim}

Example of a reconfigured event queue:
\begin{verbatim}
config event_queue: max_queue 10 log 3 order_events content_length
\end{verbatim}

Use the default event queue values, but change event order:
\begin{verbatim}
config event_queue: order_events priority
\end{verbatim}

Use the default event queue values but change the number of logged events:
\begin{verbatim}
config event_queue: log 2
\end{verbatim}

\section{Output Modules}

Output modules are new as of version 1.6. They allow Snort to be much
more flexible in the formatting and presentation of output to its
users. The output modules are run when the alert or logging subsystems
of Snort are called, after the preprocessors and detection engine.
The format of the directives in the rules file is very similar to
that of the preprocessors.

Multiple output plugins may be specified in the Snort configuration
file. When multiple plugins of the same type (log, alert) are specified,
they are stacked and called in sequence when an
event occurs. As with the standard logging and alerting systems, output
plugins send their data to /var/log/snort by default or to a user
directed directory (using the -l command line
switch).

Output modules are loaded at runtime by specifying the output keyword
in the rules file:

\begin{verbatim}
output <name>: <options>
\end{verbatim}

\begin{figure}[!hbpt]
\begin{verbatim}
output alert_syslog: log_auth log_alert
\end{verbatim}

\caption{\label{output config example}Output Module Configuration Example}
\end{figure}

\subsection{alert\_syslog \label{alert syslog lable}}

This module sends alerts to the syslog facility (much like the -s
command line switch). This module also allows the user to specify
the logging facility and priority within the Snort rules file, giving
users greater flexibility in logging alerts.

\subsubsection{Available Keywords}


\paragraph{Facilities}

\begin{itemize}
\item \texttt{log\_auth} 
\item \texttt{log\_authpriv} 
\item \texttt{log\_daemon}
\item \texttt{log\_local0} 
\item \texttt{log\_local1}
\item \texttt{log\_local2}
\item \texttt{log\_local3}
\item \texttt{log\_local4}
\item \texttt{log\_local5}
\item \texttt{log\_local6}
\item \texttt{log\_local7}
\item \texttt{log\_user}
\end{itemize}

\paragraph{Priorities}

\begin{itemize}
\item \texttt{log\_emerg} 
\item \texttt{log\_alert}
\item \texttt{log\_crit}
\item \texttt{log\_err}
\item \texttt{log\_warning} 
\item \texttt{log\_notice}
\item \texttt{log\_info}
\item \texttt{log\_debug}
\end{itemize}

\paragraph{Options}

\begin{itemize}
\item \texttt{log\_cons} 
\item \texttt{log\_ndelay}
\item \texttt{log\_perror}
\item \texttt{log\_pid}
\end{itemize}

\subsubsection{Format}

\begin{verbatim}
alert_syslog: <facility> <priority> <options>
\end{verbatim}


\begin{note}
As WIN32 does not run syslog servers locally by default, a hostname and port
can be passed as options.  The default host is 127.0.0.1.  The default port is
514.
\end{note}

\begin{verbatim}
output alert_syslog: [host=<hostname[:<port>],] <facility> <priority> <options>
\end{verbatim}

\begin{figure}[!hbpt]
\begin{verbatim}
output alert_syslog: 10.1.1.1:514, <facility> <priority> <options>
\end{verbatim}

\caption{Syslog Configuration Example\label{syslog example}}
\end{figure}

\subsection{alert\_fast}

This will print Snort alerts in a quick one-line format to a specified
output file. It is a faster alerting method than full alerts because
it doesn't need to print all of the packet headers to the output file


\subsubsection{Format}

\begin{verbatim}
alert_fast: <output filename>
\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
output alert_fast: alert.fast
\end{verbatim}

\caption{\label{fast alert configuration}Fast Alert Configuration}
\end{figure}



\subsection{alert\_full}

This will print Snort alert messages with full packet headers. The alerts will
be written in the default logging directory (/var/log/snort) or in
the logging directory specified at the command line.

Inside the logging directory, a directory will be created per IP.
These files will be decoded packet dumps of the packets that triggered
the alerts. The creation of these files slows Snort down considerably.
This output method is discouraged for all but the lightest traffic
situations.


\subsubsection{Format}

\begin{verbatim}
alert_full: <output filename>
\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
output alert_full: alert.full
\end{verbatim}

\caption{\label{full alert configuration}Full Alert Configuration}
\end{figure}


\subsection{alert\_unixsock}

Sets up a UNIX domain socket and sends alert reports to it. External
programs/processes can listen in on this socket and receive Snort
alert and packet data in real time. This is currently an experimental
interface.


\subsubsection{Format}

\begin{verbatim}
alert_unixsock
\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
output alert_unixsock
\end{verbatim}

\caption{\label{unixsock configuration}UNIXSock Alert Configuration}
\end{figure}



\subsection{log\_tcpdump}

The log\_tcpdump module logs packets to a tcpdump-formatted file.
This is useful for performing post-process analysis on collected
traffic with the vast number of tools that are available for examining
tcpdump-formatted files. This module only takes a single argument: the
name of the output file. Note that the file name will have the UNIX
timestamp in seconds appended the file name. This is so that data from
separate Snort runs can be kept distinct.


\subsubsection{Format}

\begin{verbatim}
log_tcpdump: <output filename>
\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
output log_tcpdump: snort.log
\end{verbatim}

\caption{\label{tcpdump output configuration}Tcpdump Output Module Configuration
Example}
\end{figure}

\subsection{database \label{database section}}

This module from Jed Pickel sends Snort data to a variety of SQL databases.
More information on installing and configuring this module can be
found on the {[}91{]}incident.org web page. The arguments to this
plugin are the name of the database to be logged to and a parameter
list. Parameters are specified with the format parameter = argument.
see Figure \ref{database output config} for example usage.


\subsubsection{Format}

\begin{verbatim}
database: <log | alert>, <database type>, <parameter list>
\end{verbatim}
The following parameters are available:

\begin{description}{}
\item [\texttt{host}] - Host to connect to. If a non-zero-length string is specified, TCP/IP communication is used. Without a host name, it will connect using a local UNIX domain socket.
\item [\texttt{port}] - Port number to connect to at the server host, or socket filename extension for UNIX-domain connections. 
\item [\texttt{dbname}] - Database name 
\item [\texttt{user}] - Database username for authentication
\item [\texttt{password}] - Password used if the database demands password authentication
\item [\texttt{sensor\_name}] - Specify your own name for this Snort sensor. If you do not specify a name, one will be generated automatically
\item [\texttt{encoding}] - Because the packet payload and option data is binary, there is no one simple and portable way to store it in a database. Blobs are not used because they are not portable across databases. So i leave the encoding option to you. You can choose from the following options. Each has its own advantages and disadvantages:

   \begin{description}{}
       \item [\texttt{hex}](default) - Represent binary data as a hex string. 

       \begin{description}{}
             \item [Storage~requirements]- 2x the size of the binary
             \item [Searchability]- very good 
             \item [Human~readability]- not readable unless you are a true geek, requires post processing
       \end{description}
       \item [\texttt{base64}] - Represent binary data as a base64 string. 

      \begin{description}{}
            \item [Storage~requirements]- $\sim$1.3x the size of the binary 
            \item [Searchability]- impossible without post processing 
            \item [Human~readability]- not readable requires post processing
      \end{description}

      \item [\texttt{ascii}] - Represent binary data as an ASCII string. This is
      the only option where you will actually lose data. Non-ASCII
      Data is represented as a `.'. If you choose this option, then data
      for IP and TCP options will still be represented as hex because
      it does not make any sense for that data to be ASCII.

\begin{description}{}
\item [Storage~requirements]- slightly larger than the binary because
some characters are escaped (\&,$<$,$>$)
\item [Searchability]- very good for searching for a text string impossible
if you want to search for binary 
\item [human~readability]- very good
\end{description}
\end{description}
\item [\texttt{detail}] - How much detailed data do you want to store? The options
are:

\begin{description}{}
\item [\texttt{full}](default) - Log all details of a packet that caused an alert
(including IP/TCP options and the payload)
\item [\texttt{fast}] - Log only a minimum amount of data. You severely limit the potential
of some analysis applications if you choose this option, but this
is still the best choice for some applications. The following fields
are logged: \texttt{timestamp}, \texttt{signature}, \texttt{source ip}, \texttt{destination ip}, \texttt{source
port}, \texttt{destination port}, \texttt{tcp flags}, and \texttt{protocol})
\end{description}
\end{description}
Furthermore, there is a logging method and database type that must
be defined. There are two logging types available, \texttt{log} and \texttt{alert}.
Setting the type to log attaches the database logging functionality
to the log facility within the program. If you set the type to log,
the plugin will be called on the log output chain. Setting the type
to alert attaches the plugin to the alert output chain within the
program.

There are five database types available in the current version of the plugin.
These are \texttt{mssql}, \texttt{mysql}, \texttt{postgresql}, \texttt{oracle}, and \texttt{odbc}.  
Set the type to match
the database you are using.

\begin{note}
The database output plugin does not have the ability to handle alerts that are
generated by using the \texttt{tag} keyword.  See section \ref{tag section} for more
details.
\end{note}

\begin{figure}[!hbpt]
\begin{verbatim}
output database: log, mysql, dbname=snort user=snort host=localhost password=xyz
\end{verbatim}

\caption{\label{database output config}Database Output Plugin Configuration}
\end{figure}



\subsection{csv}

The csv output plugin allows alert data to be written in a format
easily importable to a database. The plugin requires 2 arguments:
a full pathname to a file and the output formatting option. 

The list of formatting options is below. If the formatting option
is default, the output is in the order the formatting option is listed.

\begin{itemize}
\item \texttt{timestamp}
\item \texttt{sig\_generator}
\item \texttt{sig\_id}
\item \texttt{sig\_rev}
\item \texttt{msg}
\item \texttt{proto}
\item \texttt{src}
\item \texttt{srcport}
\item \texttt{dst}
\item \texttt{dstport}
\item \texttt{ethsrc}
\item \texttt{ethdst}
\item \texttt{ethlen}
\item \texttt{tcpflags}
\item \texttt{tcpseq}
\item \texttt{tcpack}
\item \texttt{tcplen}
\item \texttt{tcpwindow}
\item \texttt{ttl}
\item \texttt{tos}
\item \texttt{id}
\item \texttt{dgmlen}
\item \texttt{iplen}
\item \texttt{icmptype}
\item \texttt{icmpcode}
\item \texttt{icmpid}
\item \texttt{icmpseq}
\end{itemize}

\subsubsection{Format}

\begin{verbatim}
output alert_csv: <filename> <format>


\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
output alert_csv: /var/log/alert.csv default

output alert_csv: /var/log/alert.csv timestamp, msg
\end{verbatim}

\caption{CSV Output Configuration\label{csv output configuration}}
\end{figure}

\subsection{unified}

The unified output plugin is designed to be the fastest possible method of
logging Snort events.  The unified output plugin logs events in binary format, 
allowing another programs to handle complex logging mechanisms that would
otherwise diminish the performance of Snort.

The name \emph{unified} is a misnomer, as the unified output plugin creates two
different files, an \emph{alert} file, and a \emph{log} file.   The alert file
contains the high-level details of an event (eg: IPs, protocol, port, message
id).  The log file contains the detailed packet information (a packet dump with
the associated event ID).  Both file types are written in a bimary format
described in \emph{spo\_unified.h}.

\begin{note}
Files have the file creation time (in Unix Epoch format) appended to each
file when it is created.
\end{note}

\subsubsection{Format}

\begin{verbatim}
output alert_unified: <base file name> [, <limit <file size limit in MB>]
output log_unified: <base file name> [, <limit <file size limit in MB>]
\end{verbatim}


\begin{figure}[!hbpt]
\begin{verbatim}
output alert_unified: snort.alert, limit 128
output log_unified: snort.log, limit 128
\end{verbatim}
\caption{Unified Configuration Example\label{unified example}}
\end{figure}

\subsection{log null}

Sometimes it is useful to be able to create rules that will alert
to certain types of traffic but will not cause packet log entries.
In Snort 1.8.2, the log\_null plugin was introduced. This is equivalent
to using the -n command line option but it is able to work within
a ruletype.


\subsubsection{Format}

\begin{verbatim}
output log_null
\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
output log_null  # like using snort -n

ruletype info {
    type alert
    output alert_fast: info.alert
    output log_null
}
\end{verbatim}
\caption{Log Null Usage Example\label{log null usage example}}
\end{figure}
%\begin{verbatim}
%\end{verbatim}

%\chapter{Using Snort as an IDS\protect \\
%How to Write Snort Rules and Keep Your Sanity\label{using snort as an IDS}}

\clearpage
\chapter{Writing Snort Rules\protect \\
How to Write Snort Rules and Keep Your Sanity\label{Writing Snort Rules}}

\section{The Basics}

Snort uses a simple, lightweight rules description language that is flexible
and quite powerful. There are a number of simple guidelines to remember when
developing Snort rules.

Most Snort rules are written in a single line. This was required in versions
prior to 1.8. In current versions of Snort, rules may span multiple lines by
adding a backslash \textbackslash{} to the end of the line. 

Snort rules are divided into two logical sections, the rule header and the rule
options. The rule header contains the rule's action, protocol, source and
destination IP addresses and netmasks, and the source and destination ports
information. The rule option section contains alert messages and information on
which parts of the packet should be inspected to determine if the rule action
should be taken.

Figure \ref{Sample Snort Rule} illustrates a sample Snort rule.

\begin{center}
\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> 192.168.1.0/24 111 (content:"|00 01 86 a5|"; msg:"mountd access";)
\end{verbatim}

\caption{Sample Snort Rule\label{Sample Snort Rule}}
\end{figure}
\end{center}

The text up to the first parenthesis is the rule header and the section
enclosed in parenthesis contains the rule options. The words before the
colons in the rule options section are called option \emph{keywords}. 
\begin{note}
Note that the rule options section is not specifically required by any
rule, they are just used for the sake of making tighter definitions
of packets to collect or alert on (or drop, for that matter). 
\end{note}
All of the elements in that make up a rule must be true for the indicated
rule action to be taken. When taken together, the elements can be
considered to form a logical \textsc{and} statement. At the same time,
the various rules in a Snort rules library file can be considered
to form a large logical \textsc{or} statement. 


\section{Rules Headers}


\subsection{Rule Actions \label{rules action section}}

The rule header contains the information that defines the who,
where, and what of a packet, as well as what to do in the
event that a packet with all the attributes indicated in the rule
should show up. The first item in a rule is the rule action. The rule
action tells Snort what to do when it finds a packet that matches
the rule criteria. There are 5 available default actions in Snort,
alert, log, pass, activate, and dynamic. 

\begin{enumerate}
\item alert - generate an alert using the selected alert method, and then
log the packet 
\item log - log the packet 
\item pass - ignore the packet 
\item activate - alert and then turn on another dynamic rule  
\item dynamic - remain idle until activated by an activate rule , then act
as a log rule
\end{enumerate}
You can also define your own rule types and associate one or more
output plugins with them. You can then use the rule types as actions
in Snort rules.

This example will create a type that will log to just tcpdump:

\begin{verbatim}
ruletype suspicious
{
    type log 
    output log_tcpdump: suspicious.log
}
\end{verbatim}

This example will create a rule type that will log to syslog and a
MySQL database:

\begin{center}
\begin{verbatim}
ruletype redalert
{
      type alert 
      output alert_syslog: LOG_AUTH LOG_ALERT 
      output database: log, mysql, user=snort dbname=snort host=localhost 
}
\end{verbatim}
\end{center}

\subsection{Protocols}

The next field in a rule is the protocol. There are four protocols
that Snort currently analyzes for suspicious behavior -- tcp, udp,
icmp, and ip. In the future there may be more, such as ARP, IGRP,
GRE, OSPF, RIP, IPX, etc.


\subsection{IP Addresses}

The next portion of the rule header deals with the IP address and
port information for a given rule. The keyword any
may be used to define any address. Snort does not have a mechanism
to provide host name lookup for the IP address fields in the rules
file. The addresses are formed by a straight numeric IP address and
a CIDR\cite{cidrnotation} block. The CIDR block indicates the netmask
that should be applied to the rule's address and any incoming packets
that are tested against the rule. A CIDR block mask of /24 indicates
a Class C network, /16 a Class B network, and /32 indicates a specific
machine address. For example, the address/CIDR combination 192.168.1.0/24
would signify the block of addresses from 192.168.1.1 to 192.168.1.255.
Any rule that used this designation for, say, the destination address
would match on any address in that range. The CIDR designations give
us a nice short-hand way to designate large address spaces with just
a few characters.

In Figure \ref{Sample Snort Rule}, the source IP address was set
to match for any computer talking, and the destination address was
set to match on the 192.168.1.0 Class C network.

There is an operator that can be applied to IP addresses, the negation
operator. This operator tells Snort to match any IP address except
the one indicated by the listed IP address. The negation operator
is indicated with a !. For example, an easy modification
to the initial example is to make it alert on any traffic that originates
outside of the local net with the negation operator as shown in Figure
\ref{Example Negation}.

\begin{center}
\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp !192.168.1.0/24 any -> 192.168.1.0/24 111 \
     (content: "|00 01 86 a5|"; msg: "external mountd access";)
\end{verbatim}

\caption{\label{Example Negation} Example IP Address Negation Rule}
\end{figure}
\end{center}


This rule's IP addresses indicate any tcp packet with a
source IP address not originating from the internal network and a
destination address on the internal network.

You may also specify lists of IP addresses. An IP list is specified
by enclosing a comma separated list of IP addresses and CIDR blocks
within square brackets. For the time being, the IP list may not include
spaces between the addresses. See Figure \ref{IP list usage} for
an example of an IP list in action.

\begin{center}
\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp ![192.168.1.0/24,10.1.1.0/24] any -> \
     [192.168.1.0/24,10.1.1.0/24] 111 (content: "|00 01 86 a5|"; \
     msg: "external mountd access";)
\end{verbatim}

\caption{\label{IP list usage}IP Address Lists}
\end{figure}
\end{center}



\subsection{Port Numbers}

Port numbers may be specified in a number of ways, including any
ports, static port definitions, ranges, and by negation. Any
ports are a wildcard value, meaning literally any port. Static ports
are indicated by a single port number, such as 111 for portmapper,
23 for telnet, or 80 for http, etc. Port ranges are indicated with
the range operator :. The range operator may be
applied in a number of ways to take on different meanings, such as
in Figure \ref{port range examples}.

\begin{center}
\begin{figure}[!hbpt]
\begin{verbatim}
log udp any any -> 192.168.1.0/24 1:1024 log udp 
\end{verbatim}
traffic coming from any port and destination ports ranging from 1
to 1024

\begin{verbatim}
log tcp any any -> 192.168.1.0/24 :6000 
\end{verbatim}
log tcp traffic from any port going to ports less than or equal to
6000

\begin{verbatim}
log tcp any :1024 -> 192.168.1.0/24 500: 
\end{verbatim}
log tcp traffic from privileged ports less than or equal to 1024 going
to ports greater than or equal to 500


\caption{\label{port range examples}Port Range Examples}
\end{figure}
\end{center}

Port negation is indicated by using the negation operator !.
The negation operator may be applied against any of the other rule
types (except any, which would translate to none, how Zen...). For
example, if for some twisted reason you wanted to log everything except
the X Windows ports, you could do something like the rule in Figure
\ref{example port negation}.

%
\begin{figure}[!hbpt]
\begin{verbatim}
log tcp any any -> 192.168.1.0/24 !6000:6010
\end{verbatim}

\caption{\label{example port negation}Example of Port Negation}
\end{figure}

\clearpage

\subsection{The Direction Operator}

The direction operator -$>$ indicates the orientation,
or direction, of the traffic that the rule applies
to. The IP address and port numbers on the left side of the direction
operator is considered to be the traffic coming from the source host,
and the address and port information on the right side of the operator
is the destination host. There is also a bidirectional operator, which
is indicated with a $<>$ symbol. This tells Snort
to consider the address/port pairs in either the source or destination
orientation. This is handy for recording/analyzing both sides of a
conversation, such as telnet or POP3 sessions. An example of the bidirectional
operator being used to record both sides of a telnet session is shown
in Figure \ref{bidirectional operator}.

Also, note that there is no $<$- operator. In Snort
versions before 1.8.7, the direction operator did not have proper
error checking and many people used an invalid token. The reason the
$<$- does not exist is so that rules always read
consistently.

%
\begin{figure}[!hbpt]
\begin{verbatim}
log tcp !192.168.1.0/24 any <> 192.168.1.0/24 23
\end{verbatim}

\caption{\label{bidirectional operator}Snort rules using the Bidirectional
Operator}
\end{figure}



\subsection{Activate/Dynamic Rules}

\begin{note}
Activate and Dynamic rules are being phased out in favor of a combination 
of tagging (\ref{tag section}) and flowbits (\ref{flowbits}). 
\end{note}

Activate/dynamic rule pairs give Snort a powerful capability. You
can now have one rule activate another when it's action is performed
for a set number of packets. This is very useful if you want to set
Snort up to perform follow on recording when a specific rule goes
off. Activate rules act just like alert rules, except they
have a {*}required{*} option field: activates.
Dynamic rules act just like log rules, but they have a different option
field: activated\_by. Dynamic rules have a second
required field as well, count. 

Activate rules are just like alerts but also tell Snort to add a rule
when a specific network event occurs. Dynamic rules are just like
log rules except are dynamically enabled when the activate rule id
goes off. 

Put 'em together and they look like Figure \ref{activate/dynamic rule example}.

%
\begin{figure}[!hbpt]
\begin{verbatim}
activate tcp !$HOME_NET any -> $HOME_NET 143 (flags: PA; \
     content: "|E8C0FFFFFF|/bin"; activates: 1;  \
     msg: "IMAP buffer overflow!";)
dynamic tcp !$HOME_NET any -> $HOME_NET 143 (activated_by: 1; count: 50;)
\end{verbatim}

\caption{Activate/Dynamic Rule Example\label{activate/dynamic rule example}}
\end{figure}

These rules tell Snort to alert when it detects an IMAP buffer overflow
and collect the next 50 packets headed for port 143 coming from outside
\$HOME\_NET headed to \$HOME\_NET. If the buffer overflow happened
and was successful, there's a very good possibility that useful data
will be contained within the next 50 (or whatever) packets going to
that same service port on the network, so there's value in collecting
those packets for later analysis.

\newpage
\section{Rule Options}

Rule options form the heart of Snort's intrusion detection engine, combining
ease of use with power and flexibility. All Snort rule options are separated
from each other using the semicolon (;) character. Rule option keywords are
separated from their arguments with a colon (:) character. 

There are four major categories of rule options.  
\begin{description}
\item [meta-data] These options provide information about the rule but do not have any affect during detection 
\item [payload] These options all look for data inside the packet payload and can be inter-related
\item [non-payload] These options look for non-payload data
\item [post-detection] These options are rule specific triggers that happen after a rule has ``fired.''
\end{description}

\section{Meta-Data Rule Options}

\subsection{msg}

The msg rule option tells the logging and alerting engine the message to print
along with a packet dump or to an alert. It is a simple text string that
utilizes the \textbackslash{} as an escape character to indicate a discrete
character that might otherwise confuse Snort's rules parser (such as the
semi-colon ; character).

\subsubsection{Format}

\begin{verbatim}
msg: "<message text>";
\end{verbatim}

\subsection{reference}

The reference keyword allows rules to include references to external
attack identification systems. The plugin currently supports several
specific systems as well as unique URLs. This plugin is to be used
by output plugins to provide a link to additional information about
the alert produced.

Make sure to also take a look at \url{http://www.snort.org/snort-db/}
for a system that is indexing descriptions of alerts based off of
the sid (See Section \ref{keyword sid}).
\begin{table}[!hbpt]

\caption{Supported Systems \label{references systems}}

\begin{center}\begin{tabular}{|c|c|}
\hline 
System&
URL Prefix\\
\hline
\hline 
bugtraq&
http://www.securityfocus.com/bid/\\
\hline 
cve&
http://cve.mitre.org/cgi-bin/cvename.cgi?name=\\
\hline 
nessus &
http://cgi.nessus.org/plugins/dump.php3?id=\\
\hline 
arachnids&
(currently down) http://www.whitehats.com/info/IDS\\
\hline 
mcafee&
http://vil.nai.com/vil/dispVirus.asp?virus\_k=\\
\hline 
url&
http://\\
\hline
\end{tabular}\end{center}
\end{table}


\subsubsection{Format}

\begin{verbatim}
reference: <id system>,<id>; [reference: <id system>,<id>;]
\end{verbatim}

\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any 7070 (msg:"IDS411/dos-realaudio"; \
   flags:AP; content:"|fff4 fffd 06|"; reference:arachnids,IDS411;)

alert tcp any any -> any 21 (msg:"IDS287/ftp-wuftp260-venglin-linux"; \
   flags:AP; content:"|31c031db 31c9b046 cd80 31c031db|"; \
   reference:arachnids,IDS287; reference:bugtraq,1387; \
   reference:cve,CAN-2000-1574;)
\end{verbatim}

\caption{Reference Usage Examples\label{example reference rule}}
\end{figure}

\subsection{sid\label{keyword sid}}

The sid keyword is used to uniquely identify Snort rules. This information
allows output plugins to identify rules easily.  This option should be used
with the rev keyword.  (See section \ref{keyword rev})

\begin{itemize}
\item $<$100 Reserved for future use
\item 100-1,000,000 Rules included with the Snort distribution
\item $>$1,000,000 Used for local rules
\end{itemize}

The file sid-msg.map contains a mapping of alert messages to Snort rule IDs.
This information is useful when post-processing alert to map an ID to an alert
message.  

\subsubsection{Format}

\begin{verbatim}
sid: <snort rules id>;
\end{verbatim}

\subsubsection{Example}
This example is a rule with the Snort Rule ID of 1000983.
\begin{verbatim}
alert tcp any any -> any 80 (content:"BOB"; sid:1000983; rev:1;)
\end{verbatim}

\subsection{rev \label{keyword rev}}

The sid keyword is used to uniquely identify revisions of Snort rules.
Revisions, along with Snort rule id's, allow signatures and descriptions to be
refined and replaced with updated information.  This option should be used with
the sid keyword.  (See section \ref{keyword sid})

\subsubsection{Format}

\begin{verbatim}
rev: <revision integer>
\end{verbatim}

\subsubsection{Example}
This example is a rule with the Snort Rule Revision of 1.
\begin{verbatim}
alert tcp any any -> any 80 (content:"BOB"; sid:1000983; rev:1;)
\end{verbatim}

\subsection{classtype}

The classtype keyword categorizes alerts to be attack classes. By
using the and prioritized. The user can specify what priority each
type of rule classification has. Rules that have a classification
will have a default priority set. 

\subsubsection{Format}

\begin{verbatim}
classtype: <class name>;
\end{verbatim}
Rule classifications are defined in the \texttt{classification.config}
file. The config file uses the following syntax:

\begin{verbatim}
config classification:  <class name>,<class description>,<default priority>
\end{verbatim}
The standard classifications included with Snort are listed in Table
\ref{Snort Default Classifications}. The standard classifications
are ordered with 3 default priorities currently. A priority 1 is the
most severe priority level of the default rule set and 4 is the least
severe.


\begin{center}
\begin{longtable}{|p{2in}|p{2.5in}|c|}
\caption{Snort Default Classifications \label{Snort Default Classifications}} \\
\hline 
Classtype & Description & Priority \\
\hline
\hline 
attempted-admin&
Attempted Administrator Privilege Gain & high \\
\hline 
attempted-user&
Attempted User Privilege Gain & high\\
\hline 
shellcode-detect&
Executable code was detected & high\\
\hline 
successful-admin&
Successful Administrator Privilege Gain & high\\
\hline 
successful-user&
Successful User Privilege Gain & high\\
\hline 
trojan-activity&
A Network Trojan was detected & high\\
\hline 
unsuccessful-user&
Unsuccessful User Privilege Gain & high\\
\hline 
web-application-attack&
Web Application Attack & high\\
\hline
attempted-dos&
Attempted Denial of Service & medium\\
\hline 
attempted-recon&
Attempted Information Leak & medium\\
\hline 
bad-unknown&
Potentially Bad Traffic & medium\\
\hline 
denial-of-service&
Detection of a Denial of Service Attack & medium\\
\hline 
misc-attack&
Misc Attack & medium\\
\hline 
non-standard-protocol&
Detection of a non-standard protocol or event & medium\\
\hline 
rpc-portmap-decode&
Decode of an RPC Query & medium\\
\hline 
successful-dos&
Denial of Service & medium\\
\hline 
successful-recon-largescale&
Large Scale Information Leak & medium\\
\hline 
successful-recon-limited&
Information Leak & medium\\
\hline 
suspicious-filename-detect&
A suspicious filename was detected & medium\\
\hline 
suspicious-login&
An attempted login using a suspicious username was detected & medium\\
\hline 
system-call-detect&
A system call was detected & medium\\
\hline 
unusual-client-port-connection&
A client was using an unusual port & medium\\
\hline 
web-application-activity&
access to a potentially vulnerable web application & medium\\
\hline
icmp-event&
Generic ICMP event & low\\
\hline 
misc-activity&
Misc activity & low\\
\hline 
network-scan&
Detection of a Network Scan & low\\
\hline 
not-suspicious&
Not Suspicious Traffic & low\\
\hline 
protocol-command-decode&
Generic Protocol Command Decode & low\\
\hline 
string-detect&
A suspicious string was detected & low\\
\hline 
unknown&
Unknown Traffic & low\\
\hline
\end{longtable}
\end{center}


\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any 80 (msg:"EXPLOIT ntpdx overflow"; \ 
    dsize: >128; classtype:attempted-admin; priority:10 );

alert tcp any any -> any 25 (msg:"SMTP expn root"; flags:A+; \
   content:"expn root"; nocase; classtype:attempted-recon;)
\end{verbatim}
\caption{Example Classtype Rules\label{example classification rules}}
\end{figure}

\subsubsection{Warnings}

classtype uses classifications defined by the classification config option.  The classifications used by the rules provided with Snort are defined in etc/classification.config

\subsection{Priority}

The priority tag assigns a severity level to rules. A classtype rule
assigns a default priority that may be overridden with a priority
rule. For an example in conjunction with a classification rule refer
to Figure \ref{example classification rules}. For use by itself,
see Figure \ref{example priority rule}


\subsubsection{Format}

\begin{verbatim}
priority: <priority integer>;
\end{verbatim}

\begin{figure}[!hbpt]
\begin{verbatim}
alert TCP any any -> any 80 (msg: "WEB-MISC phf attempt"; flags:A+; \
      content: "/cgi-bin/phf"; priority:10;)
\end{verbatim}

\caption{Example Priority Rule\label{example priority rule}}
\end{figure}



\section{Payload Detection Rule Options}
\subsection{content\label{sub:content}}

The content keyword is one of the more important features of Snort.
It allows the user to set rules that search for specific content in
the packet payload and trigger response based on that data. Whenever
a content option pattern match is performed, the Boyer-Moore pattern
match function is called and the (rather computationally expensive)
test is performed against the packet contents. If data exactly matching
the argument data string is contained anywhere within the packet's
payload, the test is successful and the remainder of the rule option
tests are performed. Be aware that this test is case sensitive.

The option data for the content keyword is somewhat complex; it can
contain mixed text and binary data. The binary data is generally enclosed
within the pipe ($|$) character and represented
as bytecode. Bytecode represents binary data as hexadecimal numbers
and is a good shorthand method for describing complex binary data.
Figure \ref{mixed content example} contains an example of mixed text
and binary data in a Snort rule. 

Note that multiple content rules can be specified in one rule. This
allows rules to be tailored for less false positives. 

If the rule is preceded by a \texttt{!}, the alert will be triggered
on packets that do not contain this content. This is useful when writing
rules that want to alert on packets that do not match a certain pattern

\begin{note}
Also note that the following characters must be escaped inside a content
rule:

\begin{verbatim}
: ; \ "
\end{verbatim}
\end{note}


\subsubsection{Format}

\begin{verbatim}
content: [!] "<content string>";
\end{verbatim}


\subsubsection{Example}

\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any 139 (content:"|5c 00|P|00|I|00|P|00|E|00 5c|";)
\end{verbatim}
\caption{\label{mixed content example}Mixed Binary Bytecode and Text in a 'content' keyword}
\end{figure}

\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any 80 (content:!"GET";)
\end{verbatim}
\caption{\label{content negation example}Negation Example}
\end{figure}

\subsubsection{Changing content behavior}

The \texttt{content} keyword has a number of modifier keywords.  The modifier keywords change 
how the previously specified content works.  These modifier keywords are:

\begin{slist}
\item depth
\item offset
\item distance
\item within
\item nocase
\item rawbytes
\end{slist}


\subsection{nocase}

The nocase keyword allows the rule writer to specify that the Snort should look
for the specific pattern, ignoring case.  nocase modifies the previous 'content' keyword in the rule.

\subsubsection{Format}

\begin{verbatim}
nocase;
\end{verbatim}

\subsubsection{Example}
\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any 21 (msg:"FTP ROOT"; content:"USER root"; nocase;)
\end{verbatim}

\caption{\label{content nocase mod example}Content rule with nocase modifier}
\end{figure}

\subsection{rawbytes \label{sub:rawbytes}}

The rawbytes keyword allows rules to look at the raw packet data, ignoring any
decoding that was done by preprocessors.  This acts as a modifier to the
previous content \ref{sub:content} option. 

\subsubsection{format}

\begin{verbatim}
rawbytes;
\end{verbatim}

\subsubsection{Example}

This example tells the content pattern matcher to look at the raw traffic,
instead of the decoded traffic provided by the telnet decoder.
\begin{verbatim}
alert tcp any any -> any 21 (msg: "Telnet NOP"; content: "|FF F1|"; rawbytes;)
\end{verbatim}


\subsection{depth\label{sub:depth}}

The depth keyword allows the rule writer to specify how far into a packet Snort
should search for the specified pattern.  depth modifies the previous `content'
keyword in the rule.

A depth of 5 would tell Snort to only look look for the specified pattern
within the first 5 bytes of the payload.

As the depth keyword is a modifier to the previous `content' keyword, there
must be a content in the rule before `depth' is specified.

See Figure \ref{combined rule with offset and depth} for an example of a
combined content, offset, and depth search rule.

\subsubsection{Format}

\begin{verbatim}
depth: <number>;
\end{verbatim}

\subsection{offset}

The offset keyword allows the rule writer to specify where to start searching
for a pattern within a packet.  offset modifies the previous 'content' keyword
in the rule.

An offset of 5 would tell Snort to start looking for the specified pattern
after the first 5 bytes of the payload.

As this keyword is a modifier to the previous 'content' keyword, there must be
a content in the rule before 'offset' is specified.

See Figure \ref{combined rule with offset and depth} for an example of a
combined content, offset, and depth search rule.

\subsubsection{Format}

\begin{verbatim}
offset: <number>;
\end{verbatim}


\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any 80 (content: "cgi-bin/phf"; offset:4; depth:20;)
\end{verbatim}

\caption{\label{combined rule with offset and depth} Combined Content, Offset
and Depth Rule. Skip the first 4 bytes, and look for cgi-bin/phf in the next 20 bytes}
\end{figure}

\subsection{distance\label{sub:Distance}}

The distance keyword allows the rule writer to specify how far into a packet
Snort should ignore before starting to search for the specified pattern
relative to the end of the previous pattern match.  

This can be thought of as exactly the same thing as depth (See Section
\ref{sub:offset}), except it is relative to the end of the last pattern match
instead of the beginning of the packet.

\subsubsection{Format}

\begin{verbatim}
distance: <byte count>;
\end{verbatim}

\subsubsection{Example}

The rule listed in Figure \ref{fig:Distance} maps to a regular
expression of /ABCDE.\{1\}EFGH/.

\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any any (content:"ABC"; content: "DEF"; distance:1;)
\end{verbatim}
\caption{distance usage example \label{fig:Distance}}
\end{figure}



\subsection{within\label{sub:Within}}

The within keyword is a content modifier that makes sure that
at most N bytes are between pattern matches using the Content ( See
Section \ref{sub:content} ).  It's designed to be used in conjunction
with the distance (Section \ref{sub:Distance}) rule option.

The rule listed in Figure \ref{fig:Within} constrains the search to not
go past 10 bytes past the ABCDE match. 

\subsubsection{Format}

\begin{verbatim}
within: <byte count>;
\end{verbatim}

\subsubsection{Examples}

\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any any (content:"ABC"; content: "EFG"; within:10;)
\end{verbatim}
\caption{within usage example \label{fig:Within}}
\end{figure}


\subsection{uricontent}

The uricontent parameter in the Snort rule language searches the NORMALIZED
request \textsc{URI} field.  This means that if you are writing rules that include
things that are normalized, such as \%2f or directory traversals, these rules
will not alert.  The reason is that the things you are looking for are
normalized out of the URI buffer.  

For example, the URI: 
\begin{verbatim}/scripts/..%c0%af../winnt/system32/cmd.exe?/c+ver\end{verbatim}
will get normalized into:
\begin{verbatim}/winnt/system32/cmd.exe?/c+ver

Another example, the URI:
\begin{verbatim} /cgi-bin/aaaaaaaaaaaaaaaaaaaaaaaaaa/..%252fp%68f? \end{verbatim}
will get normalized into:
\begin{verbatim}/cgi-bin/phf?\end{verbatim}

When writing a uricontent rule, write the content that you want to find in the
context that the URI will be normalized.  For example, if Snort normalizes directory traversals, do not include directory traversals.  

You can write rules that look for the non-normalized content by using the content option.  (See Section \ref{sub:content})

For a description of the parameters to this function, see the content rule
options in Section \ref{sub:content}. 

This option works in conjunction with the HTTP Inspect preprocessor specified
in Section \ref{sub:http-inspect}.

\subsubsection{Format}

\begin{verbatim}
uricontent:[!]<content string>;
\end{verbatim}

\subsection{isdataat}

Verify that the payload has data at a specified location, optionally looking for data relative to the end of the previous content match.

\subsubsection{Format}

\begin{verbatim}
isdataat:<int>[,relative];
\end{verbatim}

\subsubsection{Example}
\begin{verbatim}
alert tcp any any -> any 111 (content:"PASS"; isdataat:50,relative; \ 
   content:!"|0a|"; distance:0;)
\end{verbatim}
This rule looks for the string PASS exists in the packet, then verifies there
is at least 50 bytes after the end of the string PASS, then verifies that there
is not a newline character within 50 bytes of the end of the PASS string.

\subsection{pcre \label{pcre}}
The pcre keyword allows rules to be written using perl compatible regular expressions.   
For more detail on what can be done via a pcre regular expression, check out the PCRE web site \url{http://www.pcre.org}

\subsubsection{Format}
\begin{verbatim}
pcre:[!]"(/<regex>/|m<delim><regex><delim>)[ismxAEGRUB]";
\end{verbatim}
The post-re modifiers set compile time flags for the regular expression.

\begin{longtable}{|c|p{3.5in}|}
\caption{Perl compatible modifiers} \\
\hline
i & case insensitive \\
\hline
s & include newlines in the dot metacharacter \\
\hline
m & By default, the string is treated as one big line of characters.  \^\ and \$ match at the beginning and ending of the string. When m is set, \^\ and \$  match immediately following or immediately before any newline in the buffer, as well as the very start and very end of the buffer. \\
\hline
x & whitespace  data characters in the pattern are ignored except when escaped or inside a character class \\
\hline
\end{longtable}

\begin{longtable}{|c|p{3.5in}|}
\caption{PCRE compatible modifiers} \\
\hline
A & the pattern must match only at the start of the buffer (same as \^\ ) \\
\hline
E & Set \$ to match only at the end of the subject string.  Without E, \$ also matches immediately before the final character if it is a newline (but not before any other newlines). \\
\hline
G & Inverts the "greediness" of the quantifiers so that they are not greedy by default, but become greedy if followed by "?". \\
\hline
\end{longtable}

\begin{longtable}{|c|p{3.5in}|}
\caption{Snort specific modifiers} \\
\hline
R & Match relative to the end of the last pattern match.  (Similar to distance:0;) \\
\hline
U & Match the decoded URI buffers (Similar to uricontent) \\
\hline
B & Do not use the decoded buffers (Similar to rawbytes) \\
\hline
\end{longtable}

The modifiers R and B should not be used together.

\subsubsection{Example}

This example performs a case-insensitive search for the string BLAH in the payload.

\begin{verbatim}
alert ip any any -> any any (pcre:"/BLAH/i";)
\end{verbatim}


\subsection{byte\_test\label{sub:byte_test}}

Test a byte field against a specific value (with operator).  Capable
 of testing binary values or converting representative byte strings to
their binary equivalent and testing them.

For a more detailed explanation, please read Section \ref{testing numerical values}.

\subsubsection{Format}

\begin{verbatim}
byte_test: <bytes to convert>, [!]<operator>, <value>, <offset>  \
    [,relative] [,<endian>] [,<number type>, string];
\end{verbatim}
			
	
\begin{tabular}{| l | p{5in} |}
\hline
{\bf Option} & {\bf Description}\\
\hline
\hline
\texttt{bytes\_to\_convert} & Number of bytes to pick up from the packet\\
\hline
\texttt{operator} & Operation to perform to test the value:
\begin{itemize}
\item $<$ - less than
\item $>$ - greater than
\item = - equal
\item ! - not
\item \& - bitwise AND
\item \^ - bitwise OR
\end{itemize}\\
\hline
\texttt{value} & Value to test the converted value against\\
\hline
\texttt{offset} & Number of bytes into the payload to start processing\\
\hline
\texttt{relative} & Use an offset relative to last pattern match\\
\hline
\texttt{endian} & Endian type of the number being read: 
\begin{itemize}
\item \texttt{big} - Process data as big endian (default)
\item \texttt{little} - Process data as little endian
\end{itemize}\\
\hline
\texttt{string} & Data is stored in string format in packet\\
\hline
\texttt{number type} & Type of number being read:
\begin{itemize}
\item \texttt{hex} - Converted string data is represented in hexadecimal
\item \texttt{dec} - Converted string data is represented in decimal
\item \texttt{oct} - Converted string data is represented in octal
\end{itemize}\\
\hline
\end{tabular}

Any of the operators can also include \emph{!} to check if the operator is not true.  
If \emph{!} is specified without an operator, then the operator is set to \emph{=}.

\begin{note}
Snort uses the C operators for each of these operators.  If the \emph{\&} operator is used, 
then it would be the same as using \emph{if (data \& value) \{ do\_something();\} }
\end{note}

\begin{figure}[!hbpt]
\begin{verbatim}
alert udp $EXTERNAL_NET any -> $HOME_NET any \
       (msg:"AMD procedure 7 plog overflow "; \
       content: "|00 04 93 F3|"; \
       content: "|00 00 00 07|"; distance: 4; within: 4; \
       byte_test: 4,>, 1000, 20, relative;)

alert tcp $EXTERNAL_NET any -> $HOME_NET any \
     (msg:"AMD procedure 7 plog overflow "; \
     content: "|00 04 93 F3|"; \
     content: "|00 00 00 07|"; distance: 4; within: 4; \
     byte_test: 4, >,1000, 20, relative;)

alert udp any any -> any 1234 \
     (byte_test: 4, =, 1234, 0, string, dec; \
     msg: "got 1234!";)

alert udp any any -> any 1235 \
     (byte_test: 3, =, 123, 0, string, dec; \
     msg: "got 123!";)

alert udp any any -> any 1236 \
     (byte_test: 2, =, 12, 0, string, dec; \
     msg: "got 12!";)

alert udp any any -> any 1237 \
     (byte_test: 10, =, 1234567890, 0, string, dec; \
     msg: "got 1234567890!";)

alert udp any any -> any 1238 \
     (byte_test: 8, =, 0xdeadbeef, 0, string, hex; \
     msg: "got DEADBEEF!";)
\end{verbatim}
\caption{Byte Test Usage Example \label{fig:byte_test}}
\end{figure}

\subsection{byte\_jump\label{sub:byte_jump}}

The \texttt{byte\_jump} option allows rules to be written for length encoded protocols 
trivially. By having an option that reads the length of a portion of data,
then skips that far forward in the packet, rules can be written that skip
over specific portions of length-encoded protocols and perform detection in very specific locations.

The \texttt{byte\_jump} option does this by reading some number of bytes, convert them
to their numeric representation, move that many bytes forward and set a pointer
for later detection.  This pointer is known as the detect offset end pointer, or doe\_ptr.

For a more detailed explanation, please read Section \ref{testing numerical values}.

\subsubsection{Format}

\begin{verbatim}
byte_jump: <bytes_to_convert>, <offset> \
        [,relative] [,multiplier <multiplier value>] [,big] [,little][,string]\
        [,hex] [,dec] [,oct] [,align] [,from_beginning];
\end{verbatim}

\begin{tabular}{| l | p{5in} |}
\hline
{\bf Option} & {\bf Description}\\
\hline
\hline
\texttt{bytes\_to\_convert} & Number of bytes to pick up from the packet\\
\hline
\texttt{offset} & Number of bytes into the payload to start processing\\
\hline
\texttt{relative} & Use an offset relative to last pattern match\\
\hline
\texttt{multiplier $<$value$>$} & Multiply the number of calculated bytes by
\texttt{$<$value$>$} and skip forward that number of bytes.\\
\hline
\texttt{big} & Process data as big endian (default)\\
\hline
\texttt{little} & Process data as little endian\\
\hline
\texttt{string} & Data is stored in string format in packet\\
\hline
\texttt{hex} & Converted string data is represented in hexadecimal\\
\hline
\texttt{dec} & Converted string data is represented in decimal\\
\hline
\texttt{oct} & Converted string data is represented in octal\\
\hline
\texttt{align} & Round the number of converted bytes up to the next 32-bit boundary\\
\hline
\texttt{from\_beginning} & Skip forward from the beginning of the packet payload instead of from the
current position in the packet.\\
\hline
\end{tabular}

\begin{figure}[!hbpt]
\begin{verbatim}
alert udp any any -> any 32770:34000 (content: "|00 01 86 B8|"; \
              content: "|00 00 00 01|"; distance: 4; within: 4; \
              byte_jump: 4, 12, relative, align; \
              byte_test: 4, >, 900, 20, relative; \
              msg: "statd format string buffer overflow";)
\end{verbatim}
\caption{byte jump Usage Example \label{fig:byte_jump}}
\end{figure}

\subsection{regex}

The regex keyword has been superceded by PCRE.  See Section \ref{pcre}.

\subsection{content-list}

The content-list keyword is broken and should not be used.

%The content-list keyword allows multiple content strings to be specified
%in the place of a single content option. The patterns to be searched
%for must each be on a single line of content-list file as shown in
%Figure \ref{content-list example}, but they are treated otherwise
%identically to content strings specified as an argument to a standard
%content directive. This option is the basis for the react keyword.
%
%%
%\begin{figure}[!hbpt]
%\begin{verbatim}
%# adult sites 
%"porn"
%"porn"
%"adults"
%"hard core"
%"www.pornsite.com"
%\end{verbatim}
%\caption{\label{content-list example}Content-list adults
%file example}
%\end{figure}
%
%
%\subsubsection{Format}
%
%\begin{verbatim}
%content-list: <file_name>;
%\end{verbatim}


\section{Non-payload Detection Rule Options}
\subsection{fragoffset \label{fragoffset section}}

The fragoffset keyword allows one to compare the IP fragment offset
field against a decimal value. To catch all the first fragments of
an IP session, you could use the fragbits keyword and look for the
More fragments option in conjunction with a fragoffset of 0.


\subsubsection{Format}

\begin{verbatim}
fragoffset:[<|>]<number>
\end{verbatim}

\begin{figure}[!hbpt]
\begin{verbatim}
alert ip any any -> any any \
      (msg: "First Fragment"; fragbits: M; fragoffset: 0;)
\end{verbatim}
\caption{Fragoffset Usage Example \label{fragoffset usage example}}
\end{figure}


\subsection{ttl}

The ttl keyword is used to check the IP time-to-live value.  This option
keyword was intended for use in the detection of traceroute attempts.

\subsubsection{Format}

\begin{verbatim}
ttl:[[<number>-]><=]<number>;
\end{verbatim}

\subsubsection{Example}

This example checks for a time-to-live value that is less than 3.
\begin{verbatim}
ttl:<3;
\end{verbatim}

This example checks for a time-to-live value that between 3 and 5.
\begin{verbatim}
ttl:3-5;
\end{verbatim}

\subsection{tos}

The tos keyword is used to check the IP TOS field for a specific value. 

\subsubsection{Format}

\begin{verbatim}
tos:[!]<number>;
\end{verbatim}

\subsubsection{Example}

This example looks for a tos value that is not 4
\begin{verbatim}
tos:!4;
\end{verbatim}

\subsection{id}

The id keyword is used to check the IP ID field for a specific value.  Some
tools (exploits, scanners and other odd programs) set this field specifically
for various purposes, for example, the value 31337 is very popular with some
hackers. 

\subsubsection{Format}

\begin{verbatim}
id:<number>;
\end{verbatim}

\subsubsection{Example}

This example looks for the IP ID of 31337.
\begin{verbatim}
id:31337;
\end{verbatim}

\subsection{ipopts}

The ipopts keyword is used to check if a specific IP option is present.

The following options may be checked:
\begin{description}
\item [rr] - Record route 
\item [eol] - End of list 
\item [nop] - No op 
\item [ts] - Time Stamp 
\item [sec] - IP security option 
\item [lsrr] - Loose source routing 
\item [ssrr] - Strict source routing 
\item [satid] - Stream identifier
\item [any] - any IP options are set
\end{description}

The most frequently watched for IP options are strict and loose source
routing which aren't used in any widespread internet applications.


\subsubsection{Format}

\begin{verbatim}
ipopts:<rr|eol|nop|ts|sec|lsrr|ssrr|satid|any>;
\end{verbatim}

\subsubsection{Example}
This example looks for the IP Option of Loose Source Routing.
\begin{verbatim}
ipopts:lsrr;
\end{verbatim}

\subsubsection{Warning}
Only a single ipopts keyword may be specified per rule.

\subsection{fragbits}

The \texttt{fragbits} keyword is used to check if fragmentation and reserved bits are set in the IP header.

The following bits may be checked:
\begin{description}
\item [M] - More Fragments
\item [D] - Don't Fragment
\item [R] - Reserved Bit
\end{description}

The following modifiers can be set to change the match criteria:
\begin{description}
\item [+] match on the specified bits, plus any others
\item [-] match if any of the specified bits are set
\item [!] match if the specified bits are not set
\end{description}

\subsubsection{Format}

\begin{verbatim}
fragbits:[+-*]<[MDR]>
\end{verbatim}

\subsubsection{Example}

This example checks if the More Fragments bit and the Do not Fragment bit are
set.
\begin{verbatim}
fragbits:MD+;
\end{verbatim}

\subsection{dsize}

The dsize keyword is used to test the packet payload size.  This may be used to check for abnormally sized packets.  In many cases, it is useful for detecting buffer overflows.

\subsubsection{Format}
\begin{verbatim}
dsize: [<>]<number>[<><number>];
\end{verbatim}

\subsubsection{Example}
This example looks for a dsize that is between 300 and 400 bytes.
\begin{verbatim}
dsize:300<>400;
\end{verbatim}

\subsubsection{Warning}
dsize will fail on stream rebuilt packets, regardless of the size of the
payload.

\subsection{flags}

The flags keyword is used to check if specific TCP flag bits are present.

The following bits may be checked:
\begin{description}
\item [F] - FIN (LSB in TCP Flags byte)
\item [S] - SYN 
\item [R] - RST 
\item [P] - PSH 
\item [A] - ACK 
\item [U] - URG 
\item [1] - Reserved bit 1 (MSB in TCP Flags byte)
\item [2] - Reserved bit 2 
\item [0] - No TCP Flags Set
\end{description}

The following modifiers can be set to change the match criteria:
\begin{description}
\item [+] - match on the specified bits, plus any others
\item [*] - match if any of the specified bits are set
\item [!] - match if the specified bits are not set
\end{description}

To handle writing rules for session initiation packets such as ECN where a SYN
packet is sent with the previously reserved bits 1 and 2 set, an option mask
may be specified. A rule could check for a flags value of S,12 if one wishes to
find packets with just the syn bit, regardless of the values of the reserved
bits.

\subsubsection{Format}

\begin{verbatim}
flags:[!|*|+]<FSRPAU120>[,<FSRPAU120>];
\end{verbatim}

\subsubsection{Example}

This example checks if just the SYN and the FIN bits are set, ignoring reserved
bit 1 and reserved bit 2.
\begin{verbatim}
alert tcp any any -> any any (flags:SF,12;)
\end{verbatim}

\subsection{flow\label{flow section}}

The flow rule option is used in conjunction with TCP stream reassembly
(see Section \ref{stream 4 section}). It allows rules to only apply
to certain directions of the traffic flow. 

This allows rules to only apply to clients or servers. This allows
packets related to \$HOME\_NET clients viewing web pages to be distinguished
from servers running the \$HOME\_NET.

The established keyword will replace the \texttt{flags: A+} used in
many places to show established TCP connections.

\subsubsection*{Options}

\begin{tabular}{| l | p{5in} |}
\hline
{\bf Option} & {\bf Description}\\
\hline
\hline
\texttt{to\_client} & Trigger on server responses from A to B\\
\hline
\texttt{to\_server} & Trigger on client requests from A to B\\
\hline
\texttt{from\_client} & Trigger on client requests from A to B\\
\hline
\texttt{from\_server} & Trigger on server responses from A to B\\
\hline
\texttt{established} & Trigger only on established TCP connections\\
\hline
\texttt{stateless} & Trigger regardless of the state of the stream processor
(useful for packets that are designed to cause machines to crash)\\
\hline
\texttt{no\_stream} & Do not trigger on rebuilt stream packets (useful 
for dsize and stream4)\\
\hline
\texttt{only\_stream} & Only trigger on rebuilt stream
packets\\
\hline
\end{tabular}

\subsubsection{Format}

\begin{verbatim}
flow: [(established|stateless)] 
      [,(to_client|to_server|from_client|from_server)]
      [,(no_stream|only_stream)]
\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp !$HOME_NET any -> $HOME_NET 21 (msg:"cd incoming detected"; \
    flow:from_client; content:"CWD incoming"; nocase;)

alert tcp !$HOME_NET 0 -> $HOME_NET 0 (msg: "Port 0 TCP traffic"; \
    flow:stateless;)
\end{verbatim}

\caption{Flow usage examples\label{flow usage examples}}
\end{figure}

\subsection{flowbits\label{flowbits}}

The \texttt{flowbits} rule option is used in conjunction with conversation
tracking from the Flow preprocessor (see Section\ref{sub:flow}).  It allows
rules to track states across transport protocol sessions.  The flowbits option
is most useful for TCP sessions, as it allows rules to generically track the
state of an application protocol.

There are seven keywords associated with flowbits. Most of the options need a
user-defined name for the specific state that is being checked.  This string
should be limited to any alphanumeric string including periods, dashes, and
underscores.

\begin{tabular}{| l | p{5in} |}
\hline
{\bf Option} & {\bf Description}\\
\hline
\hline
\texttt{set} & Sets the specified state for the current flow.\\
\hline
\texttt{unset} & Unsets the specified state for the current flow.\\
\hline
\texttt{toggle} & Sets the specified state if the state is unset, otherwise unsets the 
state if the state is set.\\
\hline
\texttt{isset} & Checks if the specified state is set.\\
\hline
\texttt{isnotset} & Checks if the specified state is not set.\\
\hline
\texttt{noalert} & Cause the rule to not generate an alert, regardless of the rest of the detection options.\\
\hline
\end{tabular}

\subsubsection{Format}

\begin{verbatim}
flowbits: [set|unset|toggle|isset,reset,noalert][,<STATE_NAME>];
\end{verbatim}




\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any 143 -> any any (msg:"IMAP login"; 
  content:"OK LOGIN"; flowbits:set,logged_in; 
  flowbits:noalert;)
  
alert tcp any any -> any 143 (msg:"IMAP LIST"; content:"LIST"; 
  flowbits:isset,logged_in;)
\end{verbatim}

\caption{Flowbits Usage Examples\label{flowbits usage examples}}
\end{figure}

\subsection{seq}

The seq keyword is used to check for a specific TCP sequence number.

\subsubsection{Format}
\begin{verbatim}
seq:<number>;
\end{verbatim}

\subsubsection{Example}
This example looks for a TCP sequence number of 0.

\begin{verbatim}
seq:0;
\end{verbatim}


\subsection{ack}

The ack keyword is used to check for a specific TCP acknowledge number.

\subsubsection{Format}
\begin{verbatim}
ack: <number>;
\end{verbatim}

\subsubsection{Example}
This example looks for a TCP acknowledge number of 0.
\begin{verbatim}
ack:0;
\end{verbatim}

\subsection{window}

The ack keyword is used to check for a specific TCP window size.

\subsubsection{Format}

\begin{verbatim}
window:[!]<number>;
\end{verbatim}

\subsubsection{Example}
This example looks for a TCP window size of 55808.
\begin{verbatim}
window:55808;
\end{verbatim}

\subsection{itype}

The itype keyword is used to check for a specific ICMP type value.

\subsubsection{Format}

\begin{verbatim}
itype:[<|>]<number>[<><number>];
\end{verbatim}

\subsubsection{Example}

This example looks for an ICMP type greater than 30.
\begin{verbatim}
itype:>30;
\end{verbatim}

\subsection{icode}

The itype keyword is used to check for a specific ICMP code value.

\subsubsection{Format}
\begin{verbatim}
icode: [<|>]<number>[<><number>];
\end{verbatim}

\subsubsection{Example}
This example looks for an ICMP code greater than 30.
\begin{verbatim}
code:>30;
\end{verbatim}

\subsection{icmp\_id}

The itype keyword is used to check for a specific ICMP ID value.

This is useful because some covert channel programs use static ICMP fields when
they communicate.  This particular plugin was developed to detect the
stacheldraht DDoS agent.

\subsubsection{Format}

\begin{verbatim}
icmp_id:<number>;
\end{verbatim}

\subsubsection{Example}

This example looks for an ICMP ID of 0.
\begin{verbatim}
icmp_id:0;
\end{verbatim}

\subsection{icmp\_seq}

The itype keyword is used to check for a specific ICMP sequence value.

This is useful because some covert channel programs use static ICMP fields when
they communicate.  This particular plugin was developed to detect the
stacheldraht DDoS agent.

\subsubsection{Format}

\begin{verbatim}
icmp_seq: <number>;
\end{verbatim}

\subsubsection{Example}

This example looks for an ICMP Sequence of 0.
\begin{verbatim}
icmp_seq:0;
\end{verbatim}

\subsection{rpc}

The rpc keyword is used to check for a RPC application, version, and procedure numbers in SUNRPC CALL requests.

Wildcards are valid for both version and procedure numbers by using '*';

\subsubsection{Format}

\begin{verbatim}
rpc: <application number>, [<version number>|*], [<procedure number>|*]>;
\end{verbatim}

\subsubsection{Example}

The following example looks for an RPC portmap GETPORT request.

\begin{verbatim}
alert tcp any any -> any 111 (rpc: 100000,*,3;);
\end{verbatim}

\subsubsection{Warning}

Because of the fast pattern matching engine, the RPC keyword is slower than looking for the RPC values by using normal content matching.

\subsection{ip\_proto}

The ip\_proto keyword allows checks against the IP protocol header.  For a list
of protocols that may be specified by name, see /etc/protocols. 

\subsubsection{Format}

\begin{verbatim}
ip_proto:[!><] <name or number>;
\end{verbatim}

\subsubsection{Example}
This example looks for IGMP traffic.

\begin{verbatim}
alert ip any any -> any any (ip_proto:igmp;)
\end{verbatim}

\subsection{sameip}

The sameip keyword allows rules to check if the source ip is the same as the destination IP.

\subsubsection{Format}

\begin{verbatim}
sameip;
\end{verbatim}

\subsubsection{Example}

This example looks for any traffic where the Source IP and the Destination IP is the same.

\begin{verbatim}
alert ip any any -> any any (sampeip;)
\end{verbatim}


\section{Post-Detection Rule Options}
\subsection{logto}

The logto option tells Snort to log all packets that trigger this rule to a
special output log file. This is especially handy for combining data from
things like NMAP activity, HTTP CGI scans, etc. It should be noted that this
option does not work when Snort is in binary logging mode.

\subsubsection{Format}

\begin{verbatim}
logto:"filename";
\end{verbatim}

\subsection{session}

The session keyword is built to extract user data from TCP Sessions.  There are
many cases where seeing what users are typing in telnet, rlogin, ftp, or even
web sessions is very useful. 

There are two available argument keywords for the session rule option,
printable or all. The printable keyword only prints out data that the user
would normally see or be able to type. 

The all keyword substitutes non-printable characters with their hexadecimal
equivalents. 

\subsubsection{Format}

\begin{verbatim}
session: [printable|all];
\end{verbatim}

\subsubsection{Example}
The following example logs all printable strings in a telnet packet.
\begin{verbatim}
log tcp any any <> any 23 (session:printable;)
\end{verbatim}

\subsubsection{Warnings}
Using the session keyword can slow Snort down considerably, so it should not be
used in heavy load situations. The session keyword is best suited for
post-processing binary (pcap) log files. 

\subsection{resp}

The resp keyword is used attempt to close sessions when an alert is triggered.  In Snort, this is called flexible response.

Flexible Response supports the following mechanisms for attempting to close
sessions:

\begin{tabular}{| l | p{5in} |}
\hline
{\bf Option} & {\bf Description}\\
\hline
\hline
\texttt{rst\_snd} &  Send TCP-RST packets to the sending socket\\
\hline 
\texttt{rst\_rcv} & Send TCP-RST packets to the receiving socket\\
\hline 
\texttt{rst\_all} & Send TCP\_RST packets in both directions\\
\hline 
\texttt{icmp\_net} & Send a ICMP\_NET\_UNREACH to the sender\\
\hline 
\texttt{icmp\_host} & Send a ICMP\_HOST\_UNREACH to the sender\\
\hline 
\texttt{icmp\_port} & Send a ICMP\_PORT\_UNREACH to the sender\\
\hline 
\texttt{icmp\_all} & Send all above ICMP packets to the sender\\
\hline
\end{tabular}

These options can be combined to send multiple responses to the target host.

\subsubsection{Format}

\begin{verbatim}
resp: <resp_mechanism>[,<resp_mechanism>[,<resp_mechanism>]];
\end{verbatim}

\subsubsection{Warnings}

This functionality is not built in by default.  Use the --enable-flexresp flag
to configure when building Snort to enable this functionality.

Be very careful when using Flexible Response. It is quite easy to get Snort
into an infinite loop by defining a rule such as:

\begin{verbatim}
alert tcp any any -> any any (resp:rst_all;)
\end{verbatim}

It is easy to be fooled into interfering with normal network traffic as well.

\subsubsection{Example}

The following example attempts to reset any TCP connection to port 1524.
\begin{verbatim}
alert tcp any any -> any 1524 (flags:S; resp:rst_all;)
\end{verbatim}


\subsection{React}

The react keyword based on flexible response (Flex Resp) implements flexible
reaction to traffic that matches a Snort rule. The basic reaction is blocking
interesting sites users want to access: New York Times, slashdot, or something
really important - napster and porn sites. The Flex Resp code allows Snort to
actively close offending connections and/or send a visible notice to the
browser (warn modifier available soon). The notice may include your own
comment. The following arguments (basic modifiers) are valid for this option:

\begin{itemize}
\item block - close connection and send the visible notice 
\item warn - send the visible, warning notice (will be available soon) 
\end{itemize}
The basic argument may be combined with the following arguments (additional
modifiers): 

\begin{itemize}
\item msg - include the msg option text into the blocking visible notice 
\item proxy: $<$port\_nr$>$ - use the proxy port to send the visible notice
(will be available soon)
\end{itemize}
Multiple additional arguments are separated by a comma. The react
keyword should be placed as the last one in the option list.


\subsubsection{Format}

\begin{verbatim}
react: <react_basic_modifier[, react_additional_modifier]>;
\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any <> 192.168.1.0/24 80 (content: "bad.htm"; \
    msg: "Not for children!"; react: block, msg;) 
\end{verbatim}
\caption{\label{react examples}React Usage Example}
\end{figure}

\subsubsection{Warnings}

This functionality is not built in by default.  Use the --enable-flexresp flag to configure when building Snort to enable this functionality.

Be very careful when using react.  Causing a network traffic generation loop is very easy to do with this functionality.


\subsection{tag \label{tag section}}

The tag keyword allow rules to log more than just the single packet that
triggered the rule. Once a rule is triggered, additional traffic involving the
source and/or destination host is \emph{tagged}. Tagged traffic is logged to
allow analysis of response codes and post-attack traffic.  \emph{tagged} alerts
will be sent to the same output plugins as the original alert, but it is the
responsibility of the output plugin to properly handle these special alerts.
Currently, the database output plugin, described in Section \ref{database 
section}, does not properly handle \emph{tagged} alerts.


\subsubsection{Format}

\begin{verbatim}
tag: <type>, <count>, <metric>, [direction]
\end{verbatim}

\begin{description}{}
  \item [\texttt{type}]~
     \begin{itemize}{}
     \item \texttt{session} - Log packets in the session that set off the rule 
     \item \texttt{host} - Log packets from the host that caused the tag to activate (uses {[}direction{]} modifier)
     \end{itemize}
  \item [\texttt{count}] - Count is specified as a number of units. Units are specified in the $<$metric$>$ field.
  \item [\texttt{metric}]~
  \begin{itemize}{}
      \item \texttt{packets} - Tag the host/session for $<$count$>$ packets 
      \item \texttt{seconds} - Tag the host/session for $<$count$>$ seconds
   \end{itemize}
\end{description}

Note, any packets that generate an alert will not be tagged.  For example, it may seem that the following rule will tag the first 600 seconds of any packet involving 10.1.1.1.
\begin{verbatim}
alert tcp any any <> any 10.1.1.1 (tag:host,600,seconds,src;)
\end{verbatim}

However, since the rule will fire on every packet involving 10.1.1.1, no packets will get tagged.  The \emph{flowbits} option would be useful here.

\begin{verbatim}
alert tcp any any <> any 10.1.1.1 (flowbits:isnotset,tagged; 
    flowbits:set,tagged; tag:host,600,seconds,src;)
\end{verbatim}

\subsubsection{Example}

This example logs the first 10 seconds of any telnet session.
\begin{verbatim}
alert tcp any any -> any 23 (flags:s,12; tag:session,10,seconds;)
\end{verbatim}







\newpage
\section{Writing Good Rules}

There are some general concepts to keep in mind when developing Snort
rules to maximize efficiency and speed.

\subsection{Content Matching}
The 2.0 detection engine changes the way Snort works slightly by having the
first phase be a setwise pattern match.  The longer a content option is, the
more \emph{exact} the match.  Rules without \emph{content} (or
\emph{uricontent}) slow the entire system down.

While some detection options, such as \emph{pcre} and \emph{byte\_test},
perform detection in the payload section of the packet, they do not use the
setwise pattern matching engine.  If at all possible, try and have at least one
\emph{content} option if at all possible.

\subsection{Catch the Vulnerability, Not the Exploit}

Try to write rules that target the vulnerability, instead of a specific exploit.

For example, look for a the vulnerable command with an argument that is too
large, instead of shellcode that binds a shell.

By writing rules for the vulnerability, the rule is less vulnerable to evasion
when an attacker changes the exploit slightly.

\subsection{Catch the Oddities of the Protocol in the Rule}

Many services typically send the commands in upper case letters.  FTP is a good example.  In FTP, to send the username, the client sends:

\begin{verbatim}
user username_here
\end{verbatim}

A simple rule to look for FTP root login attempts could be:

\begin{verbatim}
alert tcp any any -> any any 21 (content:"user root";)
\end{verbatim}

While it may \emph{seem} trivial to write a rule that looks for the username
root, a good rule will handle all of the odd things that the protocol might
handle when accepting the user command.

For example, each of the following are accepted by most FTP servers:

\begin{verbatim}
user root
user root
user root
user     root
user<tab>root
\end{verbatim}

To handle all of the cases that the FTP server might handle, the rule needs
more smarts than a simple string match.

A good rule that looks for root login on ftp would be:

\begin{verbatim}
alert tcp any any -> any 21 (flow:to_server,established; content:"root";
   pcre:"/user\s+root/i";)
\end{verbatim}

There are a few important things to note in this rule:
\begin{itemize}
\item The rule has a \emph{flow} option, verifying this is traffic going to the server on an enstablished session.
\item The rule has a \emph{content} option, looking for \emph{root}, which is
the longest, most unique string in the attack.  This option is added to allow
Snort's setwise pattern match detection engine to give Snort a boost in speed.
\item The rule has a \emph{pcre} option, looking for user, followed at least one space character (which includes tab), followed by root, ignoring case.
\end{itemize}

% optomizing :)
\subsection{Optimizing Rules}

The content matching portion of the detection engine has recursion to handle a
few evasion cases.  Rules that are not properly written can cause Snort to
waste time duplicating checks.

The way the recursion works now is if a pattern matches, and if any of the
detection options after that pattern fail, then look for the pattern again
after where it was found the previous time.  Repeat until the pattern is not
found again or the opt functions all succeed.

On first read, that may not sound like a smart idea, but it is needed.  For example, take the following rule:

\begin{verbatim}
alert ip any any -> any any (content:"a"; content:"b"; within:1;)
\end{verbatim}

This rule would look for ``a'', immediately followed by ``b''.  Without recursion,
the payload ``aab'' would fail, even though it is obvious that the payload ``aab''
has ``a'' immediately followed by ``b'', because the first "a" is not
immediately followed by ``b''.

While recursion is important for detection, the recursion implementation is not
very smart.

For example, the following rule options are not optimized:
\begin{verbatim}
content:"|13|"; dsize:1;
\end{verbatim}

By looking at this rule snippit, it is obvious the rule looks for a packet with
a single byte of 0x13.  However, because of recursion, a packet with 1024 bytes
of 0x13 could cause 1023 too many pattern match attempts and 1023 too many
dsize checks.  Why?  The content 0x13 would be found in the first byte, then
the dsize option would fail, and because of recursion, the content 0x13 would
be found again starting after where the previous 0x13 was found, once it is
found, then check the dsize again, repeating until 0x13 is not found in the
payload again.

Reordering the rule options so that discrete checks (such as dsize) are moved to the begining of the rule speed up Snort.  

The optimized rule snipping would be:
\begin{verbatim}
dsize:1; content:"|13|";
\end{verbatim}

A packet of 1024 bytes of 0x13 would fail immediately, as the dsize check is
the first option checked and dsize is a discrete check without recursion.

The following rule options are discrete and should generally be placed at the
begining of any rule:

\begin{itemize}
\item \texttt{dsize}
\item \texttt{flags}
\item \texttt{flow}
\item \texttt{fragbits}
\item \texttt{icmp\_id}
\item \texttt{icmp\_seq} 
\item \texttt{icode} 
\item \texttt{id}
\item \texttt{ipopts}
\item \texttt{ip\_proto} 
\item \texttt{itype} 
\item \texttt{seq}
\item \texttt{session} 
\item \texttt{tos}
\item \texttt{ttl}
\item \texttt{ack}
\item \texttt{window}
\item \texttt{resp} 
\item \texttt{sameip}
\end{itemize}

\subsection{testing numerical values \label{testing numerical values}}
The rule options \emph{byte\_test} and \emph{byte\_jump} were written to
support writing rules for protocols that have length encoded data.  RPC was the 
protocol that spawned the requirement for these two rule options, as RPC uses simple 
length based encoding for passing data.

In order to understand \emph{why} byte\_test and byte\_jump are useful, let's go
through an exploit attempt against the sadmind service.

This is the payload of the exploit:

\begin{verbatim}
89 09 9c e2 00 00 00 00 00 00 00 02 00 01 87 88  ................
00 00 00 0a 00 00 00 01 00 00 00 01 00 00 00 20  ...............
40 28 3a 10 00 00 00 0a 4d 45 54 41 53 50 4c 4f  @(:.....metasplo
49 54 00 00 00 00 00 00 00 00 00 00 00 00 00 00  it..............
00 00 00 00 00 00 00 00 40 28 3a 14 00 07 45 df  ........@(:...e.
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00 00 00 00 00 00 00 06 00 00 00 00 00 00 00 00  ................
00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 04  ................
7f 00 00 01 00 01 87 88 00 00 00 0a 00 00 00 04  ................
7f 00 00 01 00 01 87 88 00 00 00 0a 00 00 00 11  ................
00 00 00 1e 00 00 00 00 00 00 00 00 00 00 00 00  ................
00 00 00 00 00 00 00 3b 4d 45 54 41 53 50 4c 4f  .......;metasplo
49 54 00 00 00 00 00 00 00 00 00 00 00 00 00 00  it..............
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00 00 00 00 00 00 00 06 73 79 73 74 65 6d 00 00  ........system..
00 00 00 15 2e 2e 2f 2e 2e 2f 2e 2e 2f 2e 2e 2f  ....../../../../
2e 2e 2f 62 69 6e 2f 73 68 00 00 00 00 00 04 1e  ../bin/sh.......
<snip>
\end{verbatim}

Let's break this up, describe each of the fields, and figure out
how to write a rule to catch this exploit.  


There are a few things to note with RPC:
\begin{itemize}
\item Numbers are written as uint32s, taking four bytes.  The number 26 would show up as 0x0000001a.
\item Strings are written as a uint32 specifying the length of the string, the string, and then null bytes to pad the length of the string to end on a 4 byte boundary.  The string ``bob'' would show up as 0x00000003626f6200.
\end{itemize}

\begin{verbatim}
89 09 9c e2     - the request id, a random uint32, unique to each request
00 00 00 00     - rpc type (call = 0, response = 1)
00 00 00 02     - rpc version (2)
00 01 87 88     - rpc program (0x00018788 = 100232 = sadmind)
00 00 00 0a     - rpc program version (0x0000000a = 10)
00 00 00 01     - rpc procedure (0x00000001 = 1)
00 00 00 01     - credential flavor (1 = auth\_unix)
00 00 00 20     - length of auth\_unix data (0x20 = 32

## the next 32 bytes are the auth\_unix data
40 28 3a 10 - unix timestamp (0x40283a10 = 1076378128 = feb 10 01:55:28 2004 gmt)
00 00 00 0a - length of the client machine name (0x0a = 10)
4d 45 54 41 53 50 4c 4f 49 54 00 00  - metasploit

00 00 00 00 - uid of requesting user (0)
00 00 00 00 - gid of requesting user (0)
00 00 00 00 - extra group ids (0)

00 00 00 00     - verifier flavor (0 = auth\_null, aka none)
00 00 00 00     - length of verifier (0, aka none)
\end{verbatim}

The rest of the packet is the request that gets passed to procedure 1 of sadmind.

However, we know the vulnerability is that sadmind trusts the uid coming from the client.  sadmind runs any request where the client's uid is 0 as root.  As such, we have decoded enough of the request to write our rule.  


First, we need to make sure that our packet is an RPC call.
    
\begin{verbatim}
    content:"|00 00 00 00|"; offset:4; depth:4;
\end{verbatim}

Then, we need to make sure that our packet is a call to sadmind.
    
\begin{verbatim}
    content:"|00 01 87 88|"; offset:12; depth:4;
\end{verbatim}

Then, we need to make sure that our packet is a call to the procedure 1, the vulnerable procedure.  
   
\begin{verbatim}
    content:"|00 00 00 01|"; offset:16; depth:4;
\end{verbatim}

Then, we need to make sure that our packet has auth\_unix credentials.  
    
\begin{verbatim}
    content:"|00 00 00 01|"; offset:20; depth:4;
\end{verbatim}

We don't care about the hostname, but we want to skip over it and check a
number value after the hostname.  This is where byte\_test is useful.  Starting
at the length of the hostname, the data we have is:

\begin{verbatim}
00 00 00 0a 4d 45 54 41 53 50 4c 4f 49 54 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00
\end{verbatim}

We want to read 4 bytes, turn it into a number, and jump that many bytes
forward, making sure to account for the padding that RPC requires on strings.
If we do that, we are now at:

\begin{verbatim}
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 
\end{verbatim}

which happens to be the exact location of the uid, the value we want to check.

In english, we want to read 4 bytes, 36 bytes from the beginning of the packet, and turn those 4 bytes into an integer and jump that many bytes forward, aligning on the 4 byte boundary.  To do that in a Snort rule, we use:

\begin{verbatim}
    byte_jump:4,36,align;
\end{verbatim}

then we want to look for the uid of 0.

\begin{verbatim}
    content:"|00 00 00 00|"; within:4;
\end{verbatim}

Now that we have all the detection capabilities for our rule, let's put them all together.  

\begin{verbatim}
    content:"|00 00 00 00|"; offset:4; depth:4;
    content:"g00 01 87 88|"; offset:12; depth:4;
    content:"|00 00 00 01|"; offset:16; depth:4;
    content:"|00 00 00 01|"; offset:20; depth:4;
    byte_jump:4,36,align;
    content:"|00 00 00 00|"; within:4;
\end{verbatim}

The 3rd and fourth string match are right next to each other, so we should combine those patterns.  We end up with:

\begin{verbatim}
    content:"|00 00 00 00|"; offset:4; depth:4;
    content:"|00 01 87 88|"; offset:12; depth:4;
    content:"|00 00 00 01 00 00 00 01|"; offset:16; depth:8;
    byte_jump:4,36,align;
    content:"|00 00 00 00|"; within:4;
\end{verbatim}

If the sadmind service was vulnerable to a buffer overflow when reading the client's hostname, instead of reading the length of the hostname and jumping that many bytes forward, we would check the length of the hostname to make sure it is not too large.  

To do that, we would read 4 bytes, starting 36 bytes into the packet, turn it into a number, and then make sure it is not too large (let's say bigger than 200 bytes).  In Snort, we do: 

\begin{verbatim}
    byte_test:4,>,200,36;
\end{verbatim}
    
Our full rule would be:    

\begin{verbatim}
    content:"|00 00 00 00|"; offset:4; depth:4;
    content:"|00 01 87 88|"; offset:12; depth:4;
    content:"|00 00 00 01 00 00 00 01|"; offset:16; depth:8;
    byte_test:4,>,200,36;
\end{verbatim}

\newpage
\chapter{Making Snort Faster}

\section{MMAPed pcap}

On Linux, a modified version of libpcap is available that implements a shared memory ring buffer.  Phil Woods (cpw@lanl.gov) is the current maintainer of the libpcap implementation of the shared memory ring buffer.  The shared memory ring buffer libpcap can be downloaded from his website at \url{http://public.lanl.gov/cpw/}.

Instead of the normal mechanism of copying the packets from kernel memory into userland memory, by using a shared memory ring buffer, libpcap is able to queue packets into a shared buffer that Snort is able to read directly.  This change speeds up Snort by limiting the number of times the packet is copied before Snort gets to perform its detection upon it.

Once Snort linked against the shared memory libpcap, enabling the ring buffer is done via setting the enviornment variable \emph{PCAP\_FRAMES}.  \emph{PCAP\_FRAMES} is the size of the ring buffer.  According to Phil, the maximum size is 32768, as this appears to be the maximum number of iovecs the kernel can handle.  By using \emph{PCAP\_FRAMES=max}, libpcap will automatically use the most frames possible.  On Ethernet, this ends up being 1530 bytes per frame, for a total of around 52 Mbytes of memory for the ring buffer alone.

\newpage
\chapter{Snort Development}

Currently, this chapter is here as a place holder. It will someday
contain references on how to create new detection plugins and
preprocessors.  End users don't really need to be reading this
section. This is intended to help developers get a basic understanding
of whats going on quickly.

If you are going to be helping out with Snort development, please
use the \textsc{head} branch of cvs. We've had problems in the past
of people submitting patches only to the stable branch (since they
are likely writing this stuff for their own IDS purposes). Bugfixes
are what goes into \textsc{stable}. Features go into \textsc{head}.

\section{Submitting Patches}
Patches to Snort should be sent to the \verb!snort-devel@lists.sourceforge.net!
mailing list.  Patches should done with the command \verb!diff -nu snort-orig snort-new!.

\section{Snort dataflow}
First, traffic is acquired from the network link via libpcap. Packets
are passed through a series of decoder routines that first fill out
the packet structure for link level protocols then are further decoded
for things like TCP and UDP ports.

Packets are then sent through the registered set of preprocessors.
Each preprocessor checks to see if this packet is something it should
look at.

Packets are then sent through the detection engine. The detection
engine checks each packet against the various options listed in the
Snort rules files. Each of the keyword options is a plugin. This allows
this to be easily extensible.


\subsection{Preprocessors}

For example, a TCP analysis preprocessor could simply return if the
packet does not have a TCP header. It can do this by checking: 

\begin{verbatim}
if (p->tcph==null)
   return;
\end{verbatim}
Similarly, there are a lot of packet\_flags available that can be
used to mark a packet as ``reassembled'' or logged. Check out src/decode.h
for the list of pkt\_{*} constants.


\subsection{Detection Plugins}
Basically, look at an existing output plugin and copy it to a new item
and change a few things. Later, we'll document what these few things are.

\subsection{Output Plugins}
Generally, new output plugins should go into the barnyard project
rather than the Snort project. We are currently cleaning house on the
available output options.

\section{The Snort Team}

\begin{tabular}{p{3in} p{3in}}

\textbf{Creator and Lead Architect} &	 Marty Roesch\\
\\
\textbf{Snort Release Manager} &	 Jeremy Hewlett\\
\\
\textbf{Lead Snort Developers} &	 Marc Norton\\
 & 					 Daniel Roelker\\
\\
\textbf{Snort Rules Maintainer} & 	 Brian Caswell\\
\\
\textbf{Snort Rules Team} &		 Nigel Houghton\\
 		& 			Alex Kirk\\
		&			Judy Novak\\
		&			Matt Watchinski\\
\\
\textbf{Win32 Support} &	 	Chris Reid\\
\\
\textbf{RPM Maintainers} &	 	JP Vossen\\
			&		Daniel Wittenberg\\
\\
\textbf{Inline Developers} &	 	Victor Julien\\
				&	Rob McMillen\\
				& 	William Metcalf\\

\textbf{Major Contributors} & 	Erek Adams\\
		&		Andrew Baker\\
		&		Scott Campbell\\
		&		Roman D.\\
		&		Michael Davis\\
		&		Chris Green\\
		&		Jed Haile\\
		&		Glenn Mansfield Keeni\\
		&		Chad Kreimendahl\\
		&		Jeff Nathan\\
		&		Andreas Ostling\\
		&		Dragos Ruiu\\
		&		Fyodor Yarochkin\\
		&		Phil Wood
\end{tabular}
\appendix

\begin{thebibliography}{99}
\bibitem{phracknmaparticle}http://packetstorm.securify.com/mag/phrack/phrack49/p49-06
\bibitem{nmaphomepage}http://www.nmap.org
\bibitem{cidrnotation}http://public.pacbell.net/dedicated/cidr.html
\bibitem{whitehatsurl}http://www.whitehats.com
\bibitem{snortdb}http://www.incident.org/snortdb
\bibitem{pcre}http://www.pcre.org
\end{thebibliography}

\end{document}
