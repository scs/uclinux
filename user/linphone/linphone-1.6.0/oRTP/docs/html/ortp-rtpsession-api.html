<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>RtpSession API</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="oRTP Reference Manual"
HREF="book1.html"><LINK
REL="UP"
TITLE="oRTP API"
HREF="ortpapi.html"><LINK
REL="PREVIOUS"
TITLE="Library management functions"
HREF="ortp-library-management-functions.html"><LINK
REL="NEXT"
TITLE="RTP payloads and profiles"
HREF="ortp-rtp-payloads-and-profiles.html"><STYLE
TYPE="text/css"
>.synopsis, .classsynopsis {
    background: #eeeeee;
    border: solid 1px #aaaaaa;
    padding: 0.5em;
}
.programlisting {
    background: #eeeeff;
    border: solid 1px #aaaaff;
    padding: 0.5em;
}
.variablelist {
    padding: 4px;
    margin-left: 3em;
}
.navigation {
    background: #ffeeee;
    border: solid 1px #ffaaaa;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}
.navigation a {
    color: #770000;
}
.navigation a:visited {
    color: #550000;
}
.navigation .title {
    font-size: 200%;
}</STYLE
></HEAD
><BODY
CLASS="REFENTRY"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><TABLE
WIDTH="100%"
CLASS="navigation"
SUMMARY="Navigation header"
CELLPADDING="2"
CELLSPACING="2"
><TR
VALIGN="middle"
><TD
><A
ACCESSKEY="p"
HREF="ortp-library-management-functions.html"
><IMG
SRC="left.png"
WIDTH="24"
HEIGHT="24"
BORDER="0"
ALT="Prev"></A
></TD
><TD
><A
ACCESSKEY="u"
HREF="ortpapi.html"
><IMG
SRC="up.png"
WIDTH="24"
HEIGHT="24"
BORDER="0"
ALT="Up"></A
></TD
><TD
><A
ACCESSKEY="h"
HREF="book1.html"
><IMG
SRC="home.png"
WIDTH="24"
HEIGHT="24"
BORDER="0"
ALT="Home"></A
></TD
><TH
WIDTH="100%"
align="center"
>oRTP Reference Manual</TH
><TD
><A
ACCESSKEY="n"
HREF="ortp-rtp-payloads-and-profiles.html"
><IMG
SRC="right.png"
WIDTH="24"
HEIGHT="24"
BORDER="0"
ALT="Next"></A
></TD
></TR
></TABLE
><H1
><A
NAME="ORTP-RTPSESSION-API"
></A
>RtpSession API</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN100"
></A
><H2
>Name</H2
>RtpSession API&nbsp;--&nbsp;The RtpSession object provides control on a RTP session as defined in RFC 1889.</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="SYNOPSIS"
></A
><H2
>Synopsis</H2
><PRE
CLASS="SYNOPSIS"
>&#13;#include &lt;ortp.h&gt;


            <A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
>;
enum        <A
HREF="ortp-rtpsession-api.html#RTPSESSIONMODE"
>RtpSessionMode</A
>;
#define     <A
HREF="ortp-rtpsession-api.html#RTP-CALLBACK-TABLE-MAX-ENTRIES:CAPS"
>RTP_CALLBACK_TABLE_MAX_ENTRIES</A
>
<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
>* <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-NEW"
>rtp_session_new</A
>                 (int mode);
void        <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-SCHEDULING-MODE"
>rtp_session_set_scheduling_mode</A
> (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int yesno);
void        <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-BLOCKING-MODE"
>rtp_session_set_blocking_mode</A
>   (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int yesno);
void        <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-PROFILE"
>rtp_session_set_profile</A
>         (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             <A
HREF="ortp-rtp-payloads-and-profiles.html#RTPPROFILE"
>RtpProfile</A
> *profile);
<A
HREF="ortp-rtp-payloads-and-profiles.html#RTPPROFILE"
>RtpProfile</A
>* <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-GET-PROFILE"
>rtp_session_get_profile</A
>         (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session);
int         <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-LOCAL-ADDR"
>rtp_session_set_local_addr</A
>      (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             const char *addr,
                                             int port);
int         <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-REMOTE-ADDR"
>rtp_session_set_remote_addr</A
>     (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             const char *addr,
                                             int port);
int         <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-GET-LOCAL-PORT"
>rtp_session_get_local_port</A
>      (const <A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session);
void        <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-JITTER-COMPENSATION"
>rtp_session_set_jitter_compensation</A
>
                                            (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int milisec);
void        <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-SSRC"
>rtp_session_set_ssrc</A
>            (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             uint32_t ssrc);
void        <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-SEQ-NUMBER"
>rtp_session_set_seq_number</A
>      (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             uint16_t seq);
int         <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-SEND-PAYLOAD-TYPE"
>rtp_session_set_send_payload_type</A
>
                                            (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int paytype);
int         <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-RECV-PAYLOAD-TYPE"
>rtp_session_set_recv_payload_type</A
>
                                            (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int pt);
int         <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-GET-SEND-PAYLOAD-TYPE"
>rtp_session_get_send_payload_type</A
>
                                            (const <A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session);
int         <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-GET-RECV-PAYLOAD-TYPE"
>rtp_session_get_recv_payload_type</A
>
                                            (const <A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session);
int         <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-PAYLOAD-TYPE"
>rtp_session_set_payload_type</A
>    (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int pt);
int         <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SIGNAL-CONNECT"
>rtp_session_signal_connect</A
>      (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             const char *signal,
                                             RtpCallback cb,
                                             unsigned long user_data);
int         <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SIGNAL-DISCONNECT-BY-CALLBACK"
>rtp_session_signal_disconnect_by_callback</A
>
                                            (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             const char *signal,
                                             RtpCallback cb);
int         <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SEND-WITH-TS"
>rtp_session_send_with_ts</A
>        (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             const char *buffer,
                                             int len,
                                             uint32_t userts);
int         <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-RECV-WITH-TS"
>rtp_session_recv_with_ts</A
>        (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             char *buffer,
                                             int len,
                                             uint32_t time,
                                             int *have_more);
mblk_t*     <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-RECVM-WITH-TS"
>rtp_session_recvm_with_ts</A
>       (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             uint32_t user_ts);
mblk_t*     <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-CREATE-PACKET"
>rtp_session_create_packet</A
>       (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int header_size,
                                             const char *payload,
                                             int payload_size);
mblk_t*     <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-CREATE-PACKET-WITH-DATA"
>rtp_session_create_packet_with_data</A
>
                                            (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             char *payload,
                                             int payload_size,
                                             void (*freefn) (void*));
int         <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SENDM-WITH-TS"
>rtp_session_sendm_with_ts</A
>       (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             mblk_t *mp,
                                             uint32_t userts);
uint32_t    <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-GET-CURRENT-SEND-TS"
>rtp_session_get_current_send_ts</A
> (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session);
void        <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-FLUSH-SOCKETS"
>rtp_session_flush_sockets</A
>       (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session);
void        <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-TIME-JUMP-LIMIT"
>rtp_session_set_time_jump_limit</A
> (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int miliseconds);
void        <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-RECV-BUF-SIZE"
>rtp_session_set_recv_buf_size</A
>   (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int bufsize);
void        <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-RESET"
>rtp_session_reset</A
>               (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session);
void        <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-DATA"
>rtp_session_set_data</A
>            (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             void *data);
void*       <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-GET-DATA"
>rtp_session_get_data</A
>            (const <A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session);</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="DESC"
></A
><H2
>Description</H2
><P
>The following api provides the application a way to define a RTP session, send or receives
data through it, and to keep informed of the evolution of the RTP session through a simple
callback mecanism (see <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SIGNAL-CONNECT"
><CODE
CLASS="FUNCTION"
>rtp_session_signal_connect()</CODE
></A
> for details).</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="DETAILS"
></A
><H2
>Details</H2
><DIV
CLASS="REFSECT2"
><A
NAME="AEN246"
></A
><H3
><A
NAME="RTPSESSION"
></A
>RtpSession</H3
><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
	RtpSession *next;	/* next RtpSession, when the session are enqueued by the scheduler */
	int mask_pos;	/* the position in the scheduler mask of RtpSession : do not move this field: it is part of the ABI since the session_set macros use it*/
	RtpProfile *profile;
	WaitPoint recv_wp;
	WaitPoint send_wp;
	ortp_mutex_t lock;
	uint32_t send_ssrc;
	uint32_t recv_ssrc;
	int send_pt;/* sent payload type */
	int recv_pt;/* recv payload type */
	int hw_recv_pt; /* recv payload type before jitter buffer */
	int recv_buf_size;
	RtpSignalTable on_ssrc_changed;
	RtpSignalTable on_payload_type_changed;
	RtpSignalTable on_telephone_event_packet;
	RtpSignalTable on_telephone_event;
	RtpSignalTable on_timestamp_jump;
	RtpSignalTable on_network_error;
	RtpSignalTable on_rtcp_bye;
	struct _OList *signal_tables;
	OrtpEvQueue eventq;
	RtpStream rtp;
	RtcpStream rtcp;
	RtpSessionMode mode;
	struct _RtpScheduler *sched;
	uint32_t flags;
	int multicast_ttl;
	int multicast_loopback;
	void * user_data;
	/* FIXME: Should be a table for all session participants. */
	struct timeval last_recv_time; /* Time of receiving the RTP/RTCP packet. */

	/* telephony events extension */
	int telephone_events_pt;	/* the payload type used for telephony events */
	mblk_t *current_tev;		/* the pending telephony events */
	mblk_t *sd;
	queue_t contributing_sources;
	bool_t symmetric_rtp;
	bool_t permissive; /*use the permissive algorithm*/
} RtpSession;</PRE
><P
>Users should not manipulate this structure directly.</P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN253"
></A
><H3
><A
NAME="RTPSESSIONMODE"
></A
>enum RtpSessionMode</H3
><PRE
CLASS="PROGRAMLISTING"
>typedef enum {
	RTP_SESSION_RECVONLY,
	RTP_SESSION_SENDONLY,
	RTP_SESSION_SENDRECV
} RtpSessionMode;</PRE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN260"
></A
><H3
><A
NAME="RTP-CALLBACK-TABLE-MAX-ENTRIES:CAPS"
></A
>RTP_CALLBACK_TABLE_MAX_ENTRIES</H3
><PRE
CLASS="PROGRAMLISTING"
>#define RTP_CALLBACK_TABLE_MAX_ENTRIES	5</PRE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN267"
></A
><H3
><A
NAME="RTP-SESSION-NEW"
></A
>rtp_session_new ()</H3
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
>* rtp_session_new                 (int mode);</PRE
><P
>Creates a new rtp session.
 If the session is able to send data (RTP_SESSION_SENDONLY or RTP_SESSION_SENDRECV), then a
random SSRC number is choosed for the outgoing stream.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN278"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>mode</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> One of the <A
HREF="ortp-rtpsession-api.html#RTPSESSIONMODE"
><SPAN
CLASS="TYPE"
>RtpSessionMode</SPAN
></A
> flags.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN285"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> the newly created rtp session.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN290"
></A
><H3
><A
NAME="RTP-SESSION-SET-SCHEDULING-MODE"
></A
>rtp_session_set_scheduling_mode ()</H3
><PRE
CLASS="PROGRAMLISTING"
>void        rtp_session_set_scheduling_mode (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int yesno);</PRE
><P
>Sets the scheduling mode of the rtp session. If <CODE
CLASS="PARAMETER"
>yesno</CODE
> is TRUE, the rtp session is in
the scheduled mode, that means that you can use <A
HREF="ortp-multiplexing-sessions---in-a-one-thread-design.html#SESSION-SET-SELECT"
><CODE
CLASS="FUNCTION"
>session_set_select()</CODE
></A
> to block until it's time
to receive or send on this session according to the timestamp passed to the respective functions.
 You can also use blocking mode (see <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-BLOCKING-MODE"
><CODE
CLASS="FUNCTION"
>rtp_session_set_blocking_mode()</CODE
></A
> ), to simply block within
the receive and send functions.
If <CODE
CLASS="PARAMETER"
>yesno</CODE
> is FALSE, the ortp scheduler will not manage those sessions, meaning that blocking mode 
 and the use of <A
HREF="ortp-multiplexing-sessions---in-a-one-thread-design.html#SESSION-SET-SELECT"
><CODE
CLASS="FUNCTION"
>session_set_select()</CODE
></A
> for this session are disabled.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN310"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN315"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>yesno</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	a boolean to indicate the scheduling mode.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN320"
></A
><H3
><A
NAME="RTP-SESSION-SET-BLOCKING-MODE"
></A
>rtp_session_set_blocking_mode ()</H3
><PRE
CLASS="PROGRAMLISTING"
>void        rtp_session_set_blocking_mode   (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int yesno);</PRE
><P
>Using this function implies that you previously enabled scheduled mode on the session
 (see <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-SCHEDULING-MODE"
><CODE
CLASS="FUNCTION"
>rtp_session_set_scheduling_mode()</CODE
></A
> ).
<A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-BLOCKING-MODE"
><CODE
CLASS="FUNCTION"
>rtp_session_set_blocking_mode()</CODE
></A
> defines the behaviour of the <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-RECV-WITH-TS"
><CODE
CLASS="FUNCTION"
>rtp_session_recv_with_ts()</CODE
></A
> and 
<A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SEND-WITH-TS"
><CODE
CLASS="FUNCTION"
>rtp_session_send_with_ts()</CODE
></A
> functions. If <CODE
CLASS="PARAMETER"
>yesno</CODE
> is TRUE, <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-RECV-WITH-TS"
><CODE
CLASS="FUNCTION"
>rtp_session_recv_with_ts()</CODE
></A
>
will block until it is time for the packet to be received, according to the timestamp
passed to the function. After this time, the function returns.
For <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SEND-WITH-TS"
><CODE
CLASS="FUNCTION"
>rtp_session_send_with_ts()</CODE
></A
>, it will block until it is time for the packet to be sent.
If <CODE
CLASS="PARAMETER"
>yesno</CODE
> is FALSE, then the two functions will return immediately.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN346"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN351"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>yesno</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a boolean</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN356"
></A
><H3
><A
NAME="RTP-SESSION-SET-PROFILE"
></A
>rtp_session_set_profile ()</H3
><PRE
CLASS="PROGRAMLISTING"
>void        rtp_session_set_profile         (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             <A
HREF="ortp-rtp-payloads-and-profiles.html#RTPPROFILE"
>RtpProfile</A
> *profile);</PRE
><P
>Set the RTP profile to be used for the session. By default, all session are created by
<A
HREF="ortp-rtpsession-api.html#RTP-SESSION-NEW"
><CODE
CLASS="FUNCTION"
>rtp_session_new()</CODE
></A
> are initialized with the AV profile, as defined in RFC 3551. The application
can set any other profile instead using that function.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN370"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN375"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>profile</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp profile</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN380"
></A
><H3
><A
NAME="RTP-SESSION-GET-PROFILE"
></A
>rtp_session_get_profile ()</H3
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="ortp-rtp-payloads-and-profiles.html#RTPPROFILE"
>RtpProfile</A
>* rtp_session_get_profile         (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session);</PRE
><P
></P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN391"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN396"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>current profile.&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN401"
></A
><H3
><A
NAME="RTP-SESSION-SET-LOCAL-ADDR"
></A
>rtp_session_set_local_addr ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         rtp_session_set_local_addr      (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             const char *addr,
                                             int port);</PRE
><P
>Specify the local addr to be use to listen for rtp packets or to send rtp packet from.
In case where the rtp session is send-only, then it is not required to call this function:
when calling <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-REMOTE-ADDR"
><CODE
CLASS="FUNCTION"
>rtp_session_set_remote_addr()</CODE
></A
>, if no local address has been set, then the 
default INADRR_ANY (0.0.0.0) IP address with a random port will be used. Calling 
<GTKDOCLINK
HREF="RTP-SESESSION-SET-LOCAL-ADDR"
><CODE
CLASS="FUNCTION"
>rtp_sesession_set_local_addr()</CODE
></GTKDOCLINK
> is mandatory when the session is recv-only or duplex.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN418"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>		a rtp session freshly created.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN423"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>addr</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>		a local IP address in the xxx.xxx.xxx.xxx form.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN428"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>port</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>		a local port or -1 to let oRTP choose the port randomly</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN433"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 0 on success.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN438"
></A
><H3
><A
NAME="RTP-SESSION-SET-REMOTE-ADDR"
></A
>rtp_session_set_remote_addr ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         rtp_session_set_remote_addr     (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             const char *addr,
                                             int port);</PRE
><P
>Sets the remote address of the rtp session, ie the destination address where rtp packet
are sent. If the session is recv-only or duplex, it also sets the origin of incoming RTP 
packets. Rtp packets that don't come from addr:port are discarded.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN451"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>		a rtp session freshly created.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN456"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>addr</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>		a local IP address in the xxx.xxx.xxx.xxx form.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN461"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>port</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>		a local port.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN466"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 0 on success.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN471"
></A
><H3
><A
NAME="RTP-SESSION-GET-LOCAL-PORT"
></A
>rtp_session_get_local_port ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         rtp_session_get_local_port      (const <A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session);</PRE
><P
>This function can be useful to retrieve the local port that was randomly choosen by 
<A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-REMOTE-ADDR"
><CODE
CLASS="FUNCTION"
>rtp_session_set_remote_addr()</CODE
></A
> when <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-LOCAL-ADDR"
><CODE
CLASS="FUNCTION"
>rtp_session_set_local_addr()</CODE
></A
> was not called.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN486"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	a rtp session for which <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-LOCAL-ADDR"
><CODE
CLASS="FUNCTION"
>rtp_session_set_local_addr()</CODE
></A
> or <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-REMOTE-ADDR"
><CODE
CLASS="FUNCTION"
>rtp_session_set_remote_addr()</CODE
></A
> has been called</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN495"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> the local port used to listen for rtp packets, -1 if not set.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN500"
></A
><H3
><A
NAME="RTP-SESSION-SET-JITTER-COMPENSATION"
></A
>rtp_session_set_jitter_compensation ()</H3
><PRE
CLASS="PROGRAMLISTING"
>void        rtp_session_set_jitter_compensation
                                            (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int milisec);</PRE
><P
>Sets the time interval for which packet are buffered instead of being delivered to the 
application.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN512"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a RtpSession</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN517"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>milisec</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> the time interval in milisec to be jitter compensed.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN522"
></A
><H3
><A
NAME="RTP-SESSION-SET-SSRC"
></A
>rtp_session_set_ssrc ()</H3
><PRE
CLASS="PROGRAMLISTING"
>void        rtp_session_set_ssrc            (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             uint32_t ssrc);</PRE
><P
>Sets the SSRC for the outgoing stream.
 If not done, a random ssrc is used.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN534"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN539"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>ssrc</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> an unsigned 32bit integer representing the synchronisation source identifier (SSRC).</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN544"
></A
><H3
><A
NAME="RTP-SESSION-SET-SEQ-NUMBER"
></A
>rtp_session_set_seq_number ()</H3
><PRE
CLASS="PROGRAMLISTING"
>void        rtp_session_set_seq_number      (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             uint16_t seq);</PRE
><P
>sets the initial sequence number of a sending session.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN556"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>		a rtp session freshly created.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN561"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>seq</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN566"
></A
><H3
><A
NAME="RTP-SESSION-SET-SEND-PAYLOAD-TYPE"
></A
>rtp_session_set_send_payload_type ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         rtp_session_set_send_payload_type
                                            (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int paytype);</PRE
><P
>Sets the payload type of the rtp session. It decides of the payload types written in the
of the rtp header for the outgoing stream, if the session is SENDRECV or SENDONLY.
For payload type in incoming packets, the application can be informed by registering
for the "payload_type_changed" signal, so that it can make the necessary changes
on the downstream decoder that deals with the payload of the packets.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN578"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN583"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>paytype</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> the payload type</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN588"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 0 on success, -1 if the payload is not defined.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN593"
></A
><H3
><A
NAME="RTP-SESSION-SET-RECV-PAYLOAD-TYPE"
></A
>rtp_session_set_recv_payload_type ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         rtp_session_set_recv_payload_type
                                            (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int pt);</PRE
><P
>Sets the expected payload type for incoming packets.
If the actual payload type in incoming packets is different that this expected payload type, thus
the "payload_type_changed" signal is emitted.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN605"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN610"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>pt</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN615"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 0 on success, -1 if the payload is not defined.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN620"
></A
><H3
><A
NAME="RTP-SESSION-GET-SEND-PAYLOAD-TYPE"
></A
>rtp_session_get_send_payload_type ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         rtp_session_get_send_payload_type
                                            (const <A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session);</PRE
><P
></P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN631"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN636"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> the payload type currently used in outgoing rtp packets</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN641"
></A
><H3
><A
NAME="RTP-SESSION-GET-RECV-PAYLOAD-TYPE"
></A
>rtp_session_get_recv_payload_type ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         rtp_session_get_recv_payload_type
                                            (const <A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session);</PRE
><P
></P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN652"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN657"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> the payload type currently used in incoming rtp packets</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN662"
></A
><H3
><A
NAME="RTP-SESSION-SET-PAYLOAD-TYPE"
></A
>rtp_session_set_payload_type ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         rtp_session_set_payload_type    (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int pt);</PRE
><P
>Sets the expected payload type for incoming packets and payload type to be used for outgoing packets.
If the actual payload type in incoming packets is different that this expected payload type, thus
the "payload_type_changed" signal is emitted.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN674"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN679"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>pt</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN684"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 0 on success, -1 if the payload is not defined.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN689"
></A
><H3
><A
NAME="RTP-SESSION-SIGNAL-CONNECT"
></A
>rtp_session_signal_connect ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         rtp_session_signal_connect      (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             const char *signal,
                                             RtpCallback cb,
                                             unsigned long user_data);</PRE
><P
>This function provides the way for an application to be informed of various events that
may occur during a rtp session. <CODE
CLASS="PARAMETER"
>signal</CODE
> is a string identifying the event, and <CODE
CLASS="PARAMETER"
>cb</CODE
> is 
a user supplied function in charge of processing it. The application can register
several callbacks for the same signal, in the limit of <A
HREF="ortp-rtpsession-api.html#RTP-CALLBACK-TABLE-MAX-ENTRIES:CAPS"
><SPAN
CLASS="TYPE"
>RTP_CALLBACK_TABLE_MAX_ENTRIES</SPAN
></A
>.
Here are name and meaning of supported signals types:</P
><P
>"ssrc_changed" : the SSRC of the incoming stream has changed.</P
><P
>"payload_type_changed" : the payload type of the incoming stream has changed.</P
><P
>"telephone-event_packet" : a telephone-event rtp packet (RFC2833) is received.</P
><P
>"telephone-event" : a telephone event has occured. This is a high-level shortcut for "telephone-event_packet".</P
><P
>"network_error" : a network error happened on a socket. Arguments of the callback functions are
					a const char * explaining the error, an int errno error code and the user_data as usual.</P
><P
>"timestamp_jump" : we have received a packet with timestamp in far future compared to last timestamp received.
					The farness of far future is set by <GTKDOCLINK
HREF="RTP-SESSSION-SET-TIME-JUMP-LIMIT"
><CODE
CLASS="FUNCTION"
>rtp_sesssion_set_time_jump_limit()</CODE
></GTKDOCLINK
>
 "rtcp_bye": we have received a RTCP bye packet. Arguments of the callback
             functions are a const char * containing the leaving reason and
             the user_data.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN715"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 	a rtp session</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN720"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>signal</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>		the name of a signal</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN725"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>cb</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>			a <GTKDOCLINK
HREF="RTPCALLBACK"
><SPAN
CLASS="TYPE"
>RtpCallback</SPAN
></GTKDOCLINK
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN732"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>Param4</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN737"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 0 on success, -EOPNOTSUPP if the signal does not exists, -1 if no more callbacks
can be assigned to the signal type.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN742"
></A
><H3
><A
NAME="RTP-SESSION-SIGNAL-DISCONNECT-BY-CALLBACK"
></A
>rtp_session_signal_disconnect_by_callback ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         rtp_session_signal_disconnect_by_callback
                                            (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             const char *signal,
                                             RtpCallback cb);</PRE
><P
>Removes callback function <CODE
CLASS="PARAMETER"
>cb</CODE
> to the list of callbacks for signal <CODE
CLASS="PARAMETER"
>signal</CODE
>.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN757"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN762"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>signal</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	a signal name</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN767"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>cb</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>		a callback function.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN772"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> 0 on success, -ENOENT if the callbacks was not found.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN777"
></A
><H3
><A
NAME="RTP-SESSION-SEND-WITH-TS"
></A
>rtp_session_send_with_ts ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         rtp_session_send_with_ts        (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             const char *buffer,
                                             int len,
                                             uint32_t userts);</PRE
><P
>Send a rtp datagram to the destination set by <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-REMOTE-ADDR"
><CODE
CLASS="FUNCTION"
>rtp_session_set_remote_addr()</CODE
></A
> containing
the data from <CODE
CLASS="PARAMETER"
>buffer</CODE
> with timestamp <CODE
CLASS="PARAMETER"
>userts</CODE
>. This is a high level function that uses
<A
HREF="ortp-rtpsession-api.html#RTP-SESSION-CREATE-PACKET"
><CODE
CLASS="FUNCTION"
>rtp_session_create_packet()</CODE
></A
> and <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SENDM-WITH-TS"
><CODE
CLASS="FUNCTION"
>rtp_session_sendm_with_ts()</CODE
></A
> to send the data.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN799"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN804"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>buffer</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	a buffer containing the data to be sent in a rtp packet.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN809"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>len</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>		the length of the data buffer, in bytes.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN814"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>userts</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	the timestamp of the data to be sent. Refer to the rfc to know what it is.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN819"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> the number of bytes sent over the network.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN824"
></A
><H3
><A
NAME="RTP-SESSION-RECV-WITH-TS"
></A
>rtp_session_recv_with_ts ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         rtp_session_recv_with_ts        (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             char *buffer,
                                             int len,
                                             uint32_t time,
                                             int *have_more);</PRE
><P
>Tries to read the bytes of the incoming rtp stream related to timestamp <CODE
CLASS="PARAMETER"
>time</CODE
>. In case 
where the user supplied buffer <CODE
CLASS="PARAMETER"
>buffer</CODE
> is not large enough to get all the data 
related to timestamp <CODE
CLASS="PARAMETER"
>time</CODE
>, then *( <CODE
CLASS="PARAMETER"
>have_more</CODE
>) is set to 1 to indicate that the application
should recall the function with the same timestamp to get more data.</P
><P
> When the rtp session is scheduled (see <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-SCHEDULING-MODE"
><CODE
CLASS="FUNCTION"
>rtp_session_set_scheduling_mode()</CODE
></A
> ), and the 
blocking mode is on (see <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-BLOCKING-MODE"
><CODE
CLASS="FUNCTION"
>rtp_session_set_blocking_mode()</CODE
></A
> ), then the calling thread
is suspended until the timestamp given as argument expires, whatever a received packet 
fits the query or not.</P
><P
>Important note: it is clear that the application cannot know the timestamp of the first
packet of the incoming stream, because it can be random. The <CODE
CLASS="PARAMETER"
>time</CODE
> timestamp given to the
function is used relatively to first timestamp of the stream. In simple words, 0 is a good
value to start calling this function.</P
><P
>This function internally calls <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-RECVM-WITH-TS"
><CODE
CLASS="FUNCTION"
>rtp_session_recvm_with_ts()</CODE
></A
> to get a rtp packet. The content
of this packet is then copied into the user supplied buffer in an intelligent manner:
the function takes care of the size of the supplied buffer and the timestamp given in  
argument. Using this function it is possible to read continous audio data (e.g. pcma,pcmu...)
with for example a standart buffer of size of 160 with timestamp incrementing by 160 while the incoming
stream has a different packet size.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN853"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN858"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>buffer</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	a user supplied buffer to write the data.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN863"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>len</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>		the length in bytes of the user supplied buffer.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN868"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>time</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	the timestamp wanted.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN873"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>have_more</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> the address of an integer to indicate if more data is availlable for the given timestamp.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN878"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> if a packet was availlable with the corresponding timestamp supplied in argument 
then the number of bytes written in the user supplied buffer is returned. If no packets
are availlable, either because the sender has not started to send the stream, or either
because silence packet are not transmitted, or either because the packet was lost during
network transport, then the function returns zero.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN883"
></A
><H3
><A
NAME="RTP-SESSION-RECVM-WITH-TS"
></A
>rtp_session_recvm_with_ts ()</H3
><PRE
CLASS="PROGRAMLISTING"
>mblk_t*     rtp_session_recvm_with_ts       (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             uint32_t user_ts);</PRE
><P
>Try to get a rtp packet presented as a mblk_t structure from the rtp session.
The <CODE
CLASS="PARAMETER"
>user_ts</CODE
> parameter is relative to the first timestamp of the incoming stream. In other
words, the application does not have to know the first timestamp of the stream, it can
simply call for the first time this function with <CODE
CLASS="PARAMETER"
>user_ts</CODE
>=0, and then incrementing it
as it want. The RtpSession takes care of synchronisation between the stream timestamp
and the user timestamp given here.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN897"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN902"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>user_ts</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	a timestamp.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN907"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp packet presented as a mblk_t.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN912"
></A
><H3
><A
NAME="RTP-SESSION-CREATE-PACKET"
></A
>rtp_session_create_packet ()</H3
><PRE
CLASS="PROGRAMLISTING"
>mblk_t*     rtp_session_create_packet       (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int header_size,
                                             const char *payload,
                                             int payload_size);</PRE
><P
>Allocates a new rtp packet. In the header, ssrc and payload_type according to the session's
context. Timestamp and seq number are not set, there will be set when the packet is going to be
sent with <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SENDM-WITH-TS"
><CODE
CLASS="FUNCTION"
>rtp_session_sendm_with_ts()</CODE
></A
>.
If payload_size is zero, thus an empty packet (just a RTP header) is returned.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN928"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>		a rtp session.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN933"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>header_size</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	the rtp header size. For standart size (without extensions), it is <GTKDOCLINK
HREF="RTP-FIXED-HEADER-SIZE:CAPS"
><SPAN
CLASS="TYPE"
>RTP_FIXED_HEADER_SIZE</SPAN
></GTKDOCLINK
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN940"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>payload</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>data to be copied into the rtp packet.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN945"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>payload_size</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> size of data carried by the rtp packet.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN950"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp packet in a mblk_t (message block) structure.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN955"
></A
><H3
><A
NAME="RTP-SESSION-CREATE-PACKET-WITH-DATA"
></A
>rtp_session_create_packet_with_data ()</H3
><PRE
CLASS="PROGRAMLISTING"
>mblk_t*     rtp_session_create_packet_with_data
                                            (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             char *payload,
                                             int payload_size,
                                             void (*freefn) (void*));</PRE
><P
>Creates a new rtp packet using the given payload buffer (no copy). The header will be allocated separetely.
 In the header, ssrc and payload_type according to the session's
context. Timestamp and seq number are not set, there will be set when the packet is going to be
sent with <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SENDM-WITH-TS"
><CODE
CLASS="FUNCTION"
>rtp_session_sendm_with_ts()</CODE
></A
>.
oRTP will send this packet using libc's <GTKDOCLINK
HREF="SENDMSG"
><CODE
CLASS="FUNCTION"
>sendmsg()</CODE
></GTKDOCLINK
> (if this function is availlable!) so that there will be no
packet concatenation involving copies to be done in user-space.
 <CODE
CLASS="PARAMETER"
>freefn</CODE
> can be NULL, in that case payload will be kept untouched.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN974"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>		a rtp session.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN979"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>payload</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> the data to be sent with this packet</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN984"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>payload_size</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> size of data</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN989"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>freefn</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a function that will be called when the payload buffer is no more needed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN994"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp packet in a mblk_t (message block) structure.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN999"
></A
><H3
><A
NAME="RTP-SESSION-SENDM-WITH-TS"
></A
>rtp_session_sendm_with_ts ()</H3
><PRE
CLASS="PROGRAMLISTING"
>int         rtp_session_sendm_with_ts       (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             mblk_t *mp,
                                             uint32_t userts);</PRE
><P
>Send the rtp datagram <CODE
CLASS="PARAMETER"
>mp</CODE
> to the destination set by <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-REMOTE-ADDR"
><CODE
CLASS="FUNCTION"
>rtp_session_set_remote_addr()</CODE
></A
> 
with timestamp <CODE
CLASS="PARAMETER"
>timestamp</CODE
>. For audio data, the timestamp is the number
of the first sample resulting of the data transmitted. See rfc1889 for details.
 The packet (<CODE
CLASS="PARAMETER"
>mp</CODE
>) is freed once it is sended.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1017"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1022"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>mp</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	a rtp packet presented as a mblk_t.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1027"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>userts</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1032"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> the number of bytes sent over the network.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN1037"
></A
><H3
><A
NAME="RTP-SESSION-GET-CURRENT-SEND-TS"
></A
>rtp_session_get_current_send_ts ()</H3
><PRE
CLASS="PROGRAMLISTING"
>uint32_t    rtp_session_get_current_send_ts (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session);</PRE
><P
>When the rtp session is scheduled and has started to send packets, this function
computes the timestamp that matches to the present time. Using this function can be 
usefull when sending discontinuous streams. Some time can be elapsed between the end
of a stream burst and the begin of a new stream burst, and the application may be not
not aware of this elapsed time. In order to get a valid (current) timestamp to pass to 
#<A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SEND-WITH-TS"
><CODE
CLASS="FUNCTION"
>rtp_session_send_with_ts()</CODE
></A
> or #<A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SENDM-WITH-TS"
><CODE
CLASS="FUNCTION"
>rtp_session_sendm_with_ts()</CODE
></A
>, the application may
use <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-GET-CURRENT-SEND-TS"
><CODE
CLASS="FUNCTION"
>rtp_session_get_current_send_ts()</CODE
></A
>.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1054"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1059"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> the current send timestamp for the rtp session.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN1064"
></A
><H3
><A
NAME="RTP-SESSION-FLUSH-SOCKETS"
></A
>rtp_session_flush_sockets ()</H3
><PRE
CLASS="PROGRAMLISTING"
>void        rtp_session_flush_sockets       (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session);</PRE
><P
>Flushes the sockets for all pending incoming packets.
This can be usefull if you did not listen to the stream for a while
and wishes to start to receive again. During the time no receive is made
packets get bufferised into the internal kernel socket structure.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1075"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN1080"
></A
><H3
><A
NAME="RTP-SESSION-SET-TIME-JUMP-LIMIT"
></A
>rtp_session_set_time_jump_limit ()</H3
><PRE
CLASS="PROGRAMLISTING"
>void        rtp_session_set_time_jump_limit (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int miliseconds);</PRE
><P
>oRTP has the possibility to inform the application through a callback registered 
with rtp_session_signal_connect about crazy incoming RTP stream that jumps from 
a timestamp N to N+&lt;some crazy value&gt;. This lets the opportunity for the application
to reset the session in order to resynchronize, or any other action like stopping the call
and reporting an error.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1092"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> the rtp session</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1097"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>miliseconds</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN1102"
></A
><H3
><A
NAME="RTP-SESSION-SET-RECV-BUF-SIZE"
></A
>rtp_session_set_recv_buf_size ()</H3
><PRE
CLASS="PROGRAMLISTING"
>void        rtp_session_set_recv_buf_size   (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             int bufsize);</PRE
><P
>The default value is 65535 bytes, a big value which is working for everyone.
However if your application can make assumption on the MTU, it can be interesting
to set it to a lower value in order to save memory.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1114"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1119"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>bufsize</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> buffer size in bytes for receiving packets</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN1124"
></A
><H3
><A
NAME="RTP-SESSION-RESET"
></A
>rtp_session_reset ()</H3
><PRE
CLASS="PROGRAMLISTING"
>void        rtp_session_reset               (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session);</PRE
><P
>Reset the session: local and remote addresses are kept unchanged but the internal
queue for ordering and buffering packets is flushed, the session is ready to be
re-synchronised to another incoming stream.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1135"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN1140"
></A
><H3
><A
NAME="RTP-SESSION-SET-DATA"
></A
>rtp_session_set_data ()</H3
><PRE
CLASS="PROGRAMLISTING"
>void        rtp_session_set_data            (<A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session,
                                             void *data);</PRE
><P
>Stores some application specific data into the session, so that it is easy to retrieve it
from the signal callbacks using <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-GET-DATA"
><CODE
CLASS="FUNCTION"
>rtp_session_get_data()</CODE
></A
>.</P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1154"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1159"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>data</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> an opaque pointer to be stored in the session</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN1164"
></A
><H3
><A
NAME="RTP-SESSION-GET-DATA"
></A
>rtp_session_get_data ()</H3
><PRE
CLASS="PROGRAMLISTING"
>void*       rtp_session_get_data            (const <A
HREF="ortp-rtpsession-api.html#RTPSESSION"
>RtpSession</A
> *session);</PRE
><P
></P
><P
></P
><P
></P
><TABLE
CLASS="variablelist"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1175"><SPAN
STYLE="white-space: nowrap"
><CODE
CLASS="PARAMETER"
>session</CODE
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> a rtp session</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><A
NAME="AEN1180"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> the void pointer previously set using <A
HREF="ortp-rtpsession-api.html#RTP-SESSION-SET-DATA"
><CODE
CLASS="FUNCTION"
>rtp_session_set_data()</CODE
></A
></P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><TABLE
CLASS="navigation"
WIDTH="100%"
SUMMARY="Navigation footer"
CELLPADDING="2"
CELLSPACING="2"
><TR
VALIGN="middle"
><TD
ALIGN="left"
><A
ACCESSKEY="p"
HREF="ortp-library-management-functions.html"
><B
>&lt;&lt;&lt;&nbsp;Library management functions</B
></A
></TD
><TD
ALIGN="right"
><A
ACCESSKEY="n"
HREF="ortp-rtp-payloads-and-profiles.html"
><B
>RTP payloads and profiles&nbsp;&gt;&gt;&gt;</B
></A
></TD
></TR
></TABLE
></BODY
></HTML
>