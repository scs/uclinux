#! /bin/sh
#
# Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software
# Foundation, Inc.
# This test suite is free software; the Free Software Foundation gives
# unlimited permission to copy, distribute and modify it.
## --------------------- ##
## M4sh Initialization.  ##
## --------------------- ##

# Be Bourne compatible
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
  emulate sh
  NULLCMD=:
  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac
fi
BIN_SH=xpg4; export BIN_SH # for Tru64
DUALCASE=1; export DUALCASE # for MKS sh


# PATH needs CR
# Avoid depending upon Character Ranges.
as_cr_letters='abcdefghijklmnopqrstuvwxyz'
as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
as_cr_Letters=$as_cr_letters$as_cr_LETTERS
as_cr_digits='0123456789'
as_cr_alnum=$as_cr_Letters$as_cr_digits

# The user is always right.
if test "${PATH_SEPARATOR+set}" != set; then
  echo "#! /bin/sh" >conf$$.sh
  echo  "exit 0"   >>conf$$.sh
  chmod +x conf$$.sh
  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
    PATH_SEPARATOR=';'
  else
    PATH_SEPARATOR=:
  fi
  rm -f conf$$.sh
fi

# Support unset when possible.
if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
  as_unset=unset
else
  as_unset=false
fi


# IFS
# We need space, tab and new line, in precisely that order.  Quoting is
# there to prevent editors from complaining about space-tab.
# (If _AS_PATH_WALK were called with IFS unset, it would disable word
# splitting by setting IFS to empty value.)
as_nl='
'
IFS=" ""	$as_nl"

# Find who we are.  Look in the path if we contain no directory separator.
case $0 in
  *[\\/]* ) as_myself=$0 ;;
  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
done
IFS=$as_save_IFS

     ;;
esac
# We did not find ourselves, most probably we were run as `sh COMMAND'
# in which case we are not to be found in the path.
if test "x$as_myself" = x; then
  as_myself=$0
fi
if test ! -f "$as_myself"; then
  echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
  { (exit 1); exit 1; }
fi

# Work around bugs in pre-3.0 UWIN ksh.
for as_var in ENV MAIL MAILPATH
do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
done
PS1='$ '
PS2='> '
PS4='+ '

# NLS nuisances.
for as_var in \
  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
  LC_TELEPHONE LC_TIME
do
  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
    eval $as_var=C; export $as_var
  else
    ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
  fi
done

# Required to use basename.
if expr a : '\(a\)' >/dev/null 2>&1 &&
   test "X`expr 00001 : '.*\(...\)'`" = X001; then
  as_expr=expr
else
  as_expr=false
fi

if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
  as_basename=basename
else
  as_basename=false
fi


# Name of the executable.
as_me=`$as_basename -- "$0" ||
$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
	 X"$0" : 'X\(//\)$' \| \
	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
echo X/"$0" |
    sed '/^.*\/\([^/][^/]*\)\/*$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`

# CDPATH.
$as_unset CDPATH


if test "x$CONFIG_SHELL" = x; then
  if (eval ":") 2>/dev/null; then
  as_have_required=yes
else
  as_have_required=no
fi

  if test $as_have_required = yes && 	 (eval ":
(as_func_return () {
  (exit \$1)
}
as_func_success () {
  as_func_return 0
}
as_func_failure () {
  as_func_return 1
}
as_func_ret_success () {
  return 0
}
as_func_ret_failure () {
  return 1
}

exitcode=0
if as_func_success; then
  :
else
  exitcode=1
  echo as_func_success failed.
fi

if as_func_failure; then
  exitcode=1
  echo as_func_failure succeeded.
fi

if as_func_ret_success; then
  :
else
  exitcode=1
  echo as_func_ret_success failed.
fi

if as_func_ret_failure; then
  exitcode=1
  echo as_func_ret_failure succeeded.
fi

if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
  :
else
  exitcode=1
  echo positional parameters were not saved.
fi

test \$exitcode = 0) || { (exit 1); exit 1; }

(
  as_lineno_1=\$LINENO
  as_lineno_2=\$LINENO
  test \"x\$as_lineno_1\" != \"x\$as_lineno_2\" &&
  test \"x\`expr \$as_lineno_1 + 1\`\" = \"x\$as_lineno_2\") || { (exit 1); exit 1; }
") 2> /dev/null; then
  :
else
  as_candidate_shells=
    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in /usr/bin/posix$PATH_SEPARATOR/bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  case $as_dir in
	 /*)
	   for as_base in sh bash ksh sh5; do
	     as_candidate_shells="$as_candidate_shells $as_dir/$as_base"
	   done;;
       esac
done
IFS=$as_save_IFS


      for as_shell in $as_candidate_shells $SHELL; do
	 # Try only shells that exist, to save several forks.
	 if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
		{ ("$as_shell") 2> /dev/null <<\_ASEOF
# Be Bourne compatible
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
  emulate sh
  NULLCMD=:
  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac
fi
BIN_SH=xpg4; export BIN_SH # for Tru64
DUALCASE=1; export DUALCASE # for MKS sh

:
_ASEOF
}; then
  CONFIG_SHELL=$as_shell
	       as_have_required=yes
	       if { "$as_shell" 2> /dev/null <<\_ASEOF
# Be Bourne compatible
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
  emulate sh
  NULLCMD=:
  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac
fi
BIN_SH=xpg4; export BIN_SH # for Tru64
DUALCASE=1; export DUALCASE # for MKS sh

:
(as_func_return () {
  (exit $1)
}
as_func_success () {
  as_func_return 0
}
as_func_failure () {
  as_func_return 1
}
as_func_ret_success () {
  return 0
}
as_func_ret_failure () {
  return 1
}

exitcode=0
if as_func_success; then
  :
else
  exitcode=1
  echo as_func_success failed.
fi

if as_func_failure; then
  exitcode=1
  echo as_func_failure succeeded.
fi

if as_func_ret_success; then
  :
else
  exitcode=1
  echo as_func_ret_success failed.
fi

if as_func_ret_failure; then
  exitcode=1
  echo as_func_ret_failure succeeded.
fi

if ( set x; as_func_ret_success y && test x = "$1" ); then
  :
else
  exitcode=1
  echo positional parameters were not saved.
fi

test $exitcode = 0) || { (exit 1); exit 1; }

(
  as_lineno_1=$LINENO
  as_lineno_2=$LINENO
  test "x$as_lineno_1" != "x$as_lineno_2" &&
  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2") || { (exit 1); exit 1; }

_ASEOF
}; then
  break
fi

fi

      done

      if test "x$CONFIG_SHELL" != x; then
  for as_var in BASH_ENV ENV
        do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
        done
        export CONFIG_SHELL
        exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
fi


    if test $as_have_required = no; then
  echo This script requires a shell more modern than all the
      echo shells that I found on your system.  Please install a
      echo modern shell, or manually run the script under such a
      echo shell if you do have one.
      { (exit 1); exit 1; }
fi


fi

fi



(eval "as_func_return () {
  (exit \$1)
}
as_func_success () {
  as_func_return 0
}
as_func_failure () {
  as_func_return 1
}
as_func_ret_success () {
  return 0
}
as_func_ret_failure () {
  return 1
}

exitcode=0
if as_func_success; then
  :
else
  exitcode=1
  echo as_func_success failed.
fi

if as_func_failure; then
  exitcode=1
  echo as_func_failure succeeded.
fi

if as_func_ret_success; then
  :
else
  exitcode=1
  echo as_func_ret_success failed.
fi

if as_func_ret_failure; then
  exitcode=1
  echo as_func_ret_failure succeeded.
fi

if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
  :
else
  exitcode=1
  echo positional parameters were not saved.
fi

test \$exitcode = 0") || {
  echo No shell found that supports shell functions.
  echo Please tell autoconf@gnu.org about your system,
  echo including any error possibly output before this
  echo message
}



  as_lineno_1=$LINENO
  as_lineno_2=$LINENO
  test "x$as_lineno_1" != "x$as_lineno_2" &&
  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {

  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
  # uniformly replaced by the line number.  The first 'sed' inserts a
  # line-number line after each line using $LINENO; the second 'sed'
  # does the real work.  The second script uses 'N' to pair each
  # line-number line with the line containing $LINENO, and appends
  # trailing '-' during substitution so that $LINENO is not a special
  # case at line end.
  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
  # scripts with optimization help from Paolo Bonzini.  Blame Lee
  # E. McMahon (1931-1989) for sed's syntax.  :-)
  sed -n '
    p
    /[$]LINENO/=
  ' <$as_myself |
    sed '
      s/[$]LINENO.*/&-/
      t lineno
      b
      :lineno
      N
      :loop
      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
      t loop
      s/-\n.*//
    ' >$as_me.lineno &&
  chmod +x "$as_me.lineno" ||
    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
   { (exit 1); exit 1; }; }

  # Don't try to exec as it changes $[0], causing all sort of problems
  # (the dirname of $[0] is not the place where we might find the
  # original and so on.  Autoconf is especially sensitive to this).
  . "./$as_me.lineno"
  # Exit status is that of the last command.
  exit
}


if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
  as_dirname=dirname
else
  as_dirname=false
fi

ECHO_C= ECHO_N= ECHO_T=
case `echo -n x` in
-n*)
  case `echo 'x\c'` in
  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
  *)   ECHO_C='\c';;
  esac;;
*)
  ECHO_N='-n';;
esac

if expr a : '\(a\)' >/dev/null 2>&1 &&
   test "X`expr 00001 : '.*\(...\)'`" = X001; then
  as_expr=expr
else
  as_expr=false
fi

rm -f conf$$ conf$$.exe conf$$.file
if test -d conf$$.dir; then
  rm -f conf$$.dir/conf$$.file
else
  rm -f conf$$.dir
  mkdir conf$$.dir
fi
echo >conf$$.file
if ln -s conf$$.file conf$$ 2>/dev/null; then
  as_ln_s='ln -s'
  # ... but there are two gotchas:
  # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
  # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
  # In both cases, we have to default to `cp -p'.
  ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
    as_ln_s='cp -p'
elif ln conf$$.file conf$$ 2>/dev/null; then
  as_ln_s=ln
else
  as_ln_s='cp -p'
fi
rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
rmdir conf$$.dir 2>/dev/null

if mkdir -p . 2>/dev/null; then
  as_mkdir_p=:
else
  test -d ./-p && rmdir ./-p
  as_mkdir_p=false
fi

# Find out whether ``test -x'' works.  Don't use a zero-byte file, as
# systems may use methods other than mode bits to determine executability.
cat >conf$$.file <<_ASEOF
#! /bin/sh
exit 0
_ASEOF
chmod +x conf$$.file
if test -x conf$$.file >/dev/null 2>&1; then
  as_executable_p="test -x"
else
  as_executable_p=:
fi
rm -f conf$$.file

# Sed expression to map a string onto a valid CPP name.
as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"

# Sed expression to map a string onto a valid variable name.
as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"



SHELL=${CONFIG_SHELL-/bin/sh}

# How were we run?
at_cli_args="$@"

# Load the config file.
for at_file in atconfig atlocal
do
  test -r $at_file || continue
  . ./$at_file || { echo "$as_me: error: invalid content: $at_file" >&2
   { (exit 1); exit 1; }; }
done

# Autoconf <=2.59b set at_top_builddir instead of at_top_build_prefix:
: ${at_top_build_prefix=$at_top_builddir}

# atconfig delivers names relative to the directory the test suite is
# in, but the groups themselves are run in testsuite-dir/group-dir.
if test -n "$at_top_srcdir"; then
  builddir=../..
  for at_dir in srcdir top_srcdir top_build_prefix
  do
    at_val=`eval echo '${'at_$at_dir'}'`
    eval "$at_dir=\$at_val/../.."
  done
fi

# Not all shells have the 'times' builtin; the subshell is needed to make
# sure we discard the 'times: not found' message from the shell.
at_times_p=false
(times) >/dev/null 2>&1 && at_times_p=:

# CLI Arguments to pass to the debugging scripts.
at_debug_args=
# -e sets to true
at_errexit_p=false
# Shall we be verbose?
at_verbose=:
at_quiet=echo

# Shall we keep the debug scripts?  Must be `:' when the suite is
# run by a debug script, so that the script doesn't remove itself.
at_debug_p=false
# Display help message?
at_help_p=false
# Display the version message?
at_version_p=false
# List test groups?
at_list_p=false
# Test groups to run
at_groups=

# The directory we are in.
at_dir=`pwd`
# The directory the whole suite works in.
# Should be absolutely to let the user `cd' at will.
at_suite_dir=$at_dir/$as_me.dir
# The file containing the suite.
at_suite_log=$at_dir/$as_me.log
# The file containing the location of the last AT_CHECK.
at_check_line_file=$at_suite_dir/at-check-line
# The file containing the exit status of the last command.
at_status_file=$at_suite_dir/at-status
# The files containing the output of the tested commands.
at_stdout=$at_suite_dir/at-stdout
at_stder1=$at_suite_dir/at-stder1
at_stderr=$at_suite_dir/at-stderr
# The file containing dates.
at_times_file=$at_suite_dir/at-times

# List of the tested programs.
at_tested=''
# List of the all the test groups.
at_groups_all=' banner-1 1 banner-2 2 banner-3 3'
# As many question marks as there are digits in the last test group number.
# Used to normalize the test group numbers so that `ls' lists them in
# numerical order.
at_format='?'
# Description of all the test groups.
at_help_all='1;unittests.at:3;unittests;;
2;colourbars.at:3;colourbars;;
3;samples.at:3;samples;;
'

at_prev=
for at_option
do
  # If the previous option needs an argument, assign it.
  if test -n "$at_prev"; then
    at_option=$at_prev=$at_option
    at_prev=
  fi

  case $at_option in
  *=*) at_optarg=`expr "x$at_option" : 'x[^=]*=\(.*\)'` ;;
  *)   at_optarg= ;;
  esac

  # Accept the important Cygnus configure options, so we can diagnose typos.

  case $at_option in
    --help | -h )
	at_help_p=:
	;;

    --list | -l )
	at_list_p=:
	;;

    --version | -V )
	at_version_p=:
	;;

    --clean | -c )
	test -d "$at_suite_dir" &&
	  find "$at_suite_dir" -type d ! -perm -700 -exec chmod u+rwx \{\} \;
	rm -f -r "$at_suite_dir" "$at_suite_log"
	exit 0
	;;

    --debug | -d )
	at_debug_p=:
	;;

    --errexit | -e )
	at_debug_p=:
	at_errexit_p=:
	;;

    --verbose | -v )
	at_verbose=echo; at_quiet=:
	;;

    --trace | -x )
	at_traceon='set -x'; at_traceoff='set +x'
	;;

    [0-9] | [0-9][0-9] | [0-9][0-9][0-9] | [0-9][0-9][0-9][0-9])
	at_groups="$at_groups$at_option "
	;;

    # Ranges
    [0-9]- | [0-9][0-9]- | [0-9][0-9][0-9]- | [0-9][0-9][0-9][0-9]-)
	at_range_start=`echo $at_option |tr -d X-`
	at_range=`echo " $at_groups_all " | \
	  sed -e 's/^.* \('$at_range_start' \)/\1/'`
	at_groups="$at_groups$at_range "
	;;

    -[0-9] | -[0-9][0-9] | -[0-9][0-9][0-9] | -[0-9][0-9][0-9][0-9])
	at_range_end=`echo $at_option |tr -d X-`
	at_range=`echo " $at_groups_all " | \
	  sed -e 's/\( '$at_range_end'\) .*$/\1/'`
	at_groups="$at_groups$at_range "
	;;

    [0-9]-[0-9] | [0-9]-[0-9][0-9] | [0-9]-[0-9][0-9][0-9] | \
    [0-9]-[0-9][0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9] | \
    [0-9][0-9]-[0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] )
	at_range_start=`expr $at_option : '\(.*\)-'`
	at_range_end=`expr $at_option : '.*-\(.*\)'`
	if test $at_range_start -gt $at_range_end; then
	  at_tmp=$at_range_end
	  at_range_end=$at_range_start
	  at_range_start=$at_tmp
	fi
	at_range=`echo " $at_groups_all " | \
	  sed -e 's/^.*\( '$at_range_start' \)/\1/' \
	      -e 's/\( '$at_range_end'\) .*$/\1/'`
	at_groups="$at_groups$at_range "
	;;

    # Keywords.
    --keywords | -k )
	at_prev=--keywords
	;;
    --keywords=* )
	at_groups_selected=$at_help_all
	at_save_IFS=$IFS
	IFS=,
	set X $at_optarg
	shift
	IFS=$at_save_IFS
	for at_keyword
	do
	  at_invert=
	  case $at_keyword in
	  '!'*)
	    at_invert="-v"
	    at_keyword=`expr "X$at_keyword" : 'X!\(.*\)'`
	    ;;
	  esac
	  # It is on purpose that we match the test group titles too.
	  at_groups_selected=`echo "$at_groups_selected" |
	      grep -i $at_invert "^[1-9][^;]*;.*[; ]$at_keyword[ ;]"`
	done
	at_groups_selected=`echo "$at_groups_selected" | sed 's/;.*//'`
	# Smash the newlines.
	at_groups="$at_groups`echo $at_groups_selected` "
	;;

    *=*)
	at_envvar=`expr "x$at_option" : 'x\([^=]*\)='`
	# Reject names that are not valid shell variable names.
	expr "x$at_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
	  { echo "$as_me: error: invalid variable name: $at_envvar" >&2
   { (exit 1); exit 1; }; }
	at_value=`echo "$at_optarg" | sed "s/'/'\\\\\\\\''/g"`
	eval "$at_envvar='$at_value'"
	export $at_envvar
	# Propagate to debug scripts.
	at_debug_args="$at_debug_args $at_envvar='$at_value'"
	;;

     *) echo "$as_me: invalid option: $at_option" >&2
	echo "Try \`$0 --help' for more information." >&2
	exit 1
	;;
  esac
done

# Selected test groups.
if test -z "$at_groups"; then
  at_groups=$at_groups_all
else
  # Sort the tests, removing duplicates:
  at_groups=`echo $at_groups | tr ' ' "$as_nl" | sort -nu`
  # and add banners.  (Passing at_groups_all is tricky--see the comment
  # starting with "Passing at_groups is tricky.")
  at_groups=`echo "$at_groups$as_nl $at_groups_all" |
    awk 'BEGIN { FS = "@" } # Effectively switch off field splitting.
	/^$/ { next }  # Ignore the empty line.
	!/ / { groups++; selected[$ 0] = 1; next }
	# The last line, containing at_groups_all.
	{
		n = split($ 0, a, " ")
		# If there are several tests, select their banners:
		if (groups > 1) {
			for (i = 1; i <= n; i++) {
				if (a[i] ~ /^banner-/)
					banner = a[i]
				else if (banner != "" && selected[a[i]] == 1)
					selected[banner] = 1
			}
		}
		for (i = 1; i <= n; i++)
			if (selected[a[i]] == 1)
				list = list " " a[i]
		print list
	}'`
fi

# Help message.
if $at_help_p; then
  cat <<_ATEOF
Usage: $0 [OPTION]... [VARIABLE=VALUE]... [TESTS]

Run all the tests, or the selected TESTS, given by numeric ranges, and
save a detailed log file.  Upon failure, create debugging scripts.

You should not change environment variables unless explicitly passed
as command line arguments.  Set \`AUTOTEST_PATH' to select the executables
to exercise.  Each relative directory is expanded as build and source
directories relatively to the top level of this distribution.  E.g.,

  $ $0 AUTOTEST_PATH=bin

possibly amounts into

  PATH=/tmp/foo-1.0/bin:/src/foo-1.0/bin:\$PATH
_ATEOF
cat <<_ATEOF

Operation modes:
  -h, --help     print the help message, then exit
  -V, --version  print version number, then exit
  -c, --clean    remove all the files this test suite might create and exit
  -l, --list     describes all the tests, or the selected TESTS
_ATEOF
cat <<_ATEOF

Execution tuning:
  -k, --keywords=KEYWORDS
	         select the tests matching all the comma-separated KEYWORDS
	         multiple \`-k' accumulate; prefixed \`!' negates a KEYWORD
  -e, --errexit  abort as soon as a test fails; implies --debug
  -v, --verbose  force more detailed output
	         default for debugging scripts
  -d, --debug    inhibit clean up and top-level logging
	         default for debugging scripts
  -x, --trace    enable tests shell tracing
_ATEOF
cat <<_ATEOF

Report bugs to <>.
_ATEOF
  exit 0
fi

# List of tests.
if $at_list_p; then
  cat <<_ATEOF
 test suite: dirac test groups:

 NUM: FILE-NAME:LINE     TEST-GROUP-NAME
      KEYWORDS

_ATEOF
  # Passing at_groups is tricky.  We cannot use it to form a literal string
  # or regexp because of the limitation of AIX awk.  And Solaris' awk
  # doesn't grok more than 99 fields in a record, so we have to use `split'.
  echo "$at_groups$as_nl$at_help_all" |
    awk 'BEGIN { FS = ";" }
	 NR == 1 {
	   for (n = split($ 0, a, " "); n; n--) selected[a[n]] = 1
	   next
	 }
	 {
	   if (selected[$ 1]) {
	     printf " %3d: %-18s %s\n", $ 1, $ 2, $ 3
	     if ($ 4) printf "      %s\n", $ 4
	   }
	 }'
  exit 0
fi
if $at_version_p; then
  echo "$as_me ()"
  cat <<\_ACEOF

Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software
Foundation, Inc.
This test suite is free software; the Free Software Foundation gives
unlimited permission to copy, distribute and modify it.
_ACEOF
  exit 0
fi

# Don't take risks: use only absolute directories in PATH.
#
# For stand-alone test suites, AUTOTEST_PATH is relative to `.'.
#
# For embedded test suites, AUTOTEST_PATH is relative to the top level
# of the package.  Then expand it into build/src parts, since users
# may create executables in both places.
AUTOTEST_PATH=`echo $AUTOTEST_PATH | sed "s&:&$PATH_SEPARATOR&g"`
at_path=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $AUTOTEST_PATH $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -n "$at_path" && at_path=$at_path$PATH_SEPARATOR
case $as_dir in
  [\\/]* | ?:[\\/]* )
    at_path=$at_path$as_dir
    ;;
  * )
    if test -z "$at_top_build_prefix"; then
      # Stand-alone test suite.
      at_path=$at_path$as_dir
    else
      # Embedded test suite.
      at_path=$at_path$at_top_build_prefix$as_dir$PATH_SEPARATOR
      at_path=$at_path$at_top_srcdir/$as_dir
    fi
    ;;
esac
done
IFS=$as_save_IFS


# Now build and simplify PATH.
#
# There might be directories that don't exist, but don't redirect
# builtins' (eg., cd) stderr directly: Ultrix's sh hates that.
PATH=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $at_path
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  as_dir=`(cd "$as_dir" && pwd) 2>/dev/null`
test -d "$as_dir" || continue
case $PATH in
	          $as_dir                 | \
	          $as_dir$PATH_SEPARATOR* | \
  *$PATH_SEPARATOR$as_dir                 | \
  *$PATH_SEPARATOR$as_dir$PATH_SEPARATOR* ) ;;

  '') PATH=$as_dir ;;
   *) PATH=$PATH$PATH_SEPARATOR$as_dir ;;
esac
done
IFS=$as_save_IFS

export PATH

# Setting up the FDs.
# 5 is the log file.  Not to be overwritten if `-d'.

if $at_debug_p; then
  at_suite_log=/dev/null
else
  : >"$at_suite_log"
fi
exec 5>>"$at_suite_log"

# Banners and logs.
cat <<\_ASBOX
## ------------------- ##
##  test suite: dirac. ##
## ------------------- ##
_ASBOX
{
  cat <<\_ASBOX
## ------------------- ##
##  test suite: dirac. ##
## ------------------- ##
_ASBOX
  echo

  echo "$as_me: command line was:"
  echo "  $ $0 $at_cli_args"
  echo

  # Try to find a few ChangeLogs in case it might help determining the
  # exact version.  Use the relative dir: if the top dir is a symlink,
  # find will not follow it (and options to follow the links are not
  # portable), which would result in no output here.
  if test -n "$at_top_srcdir"; then
    cat <<\_ASBOX
## ----------- ##
## ChangeLogs. ##
## ----------- ##
_ASBOX
    echo
    for at_file in `find "$at_top_srcdir" -name ChangeLog -print`
    do
      echo "$as_me: $at_file:"
      sed 's/^/| /;10q' $at_file
      echo
    done

    {
cat <<_ASUNAME
## --------- ##
## Platform. ##
## --------- ##

hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
uname -m = `(uname -m) 2>/dev/null || echo unknown`
uname -r = `(uname -r) 2>/dev/null || echo unknown`
uname -s = `(uname -s) 2>/dev/null || echo unknown`
uname -v = `(uname -v) 2>/dev/null || echo unknown`

/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`

/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`

_ASUNAME

as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  echo "PATH: $as_dir"
done
IFS=$as_save_IFS

}
    echo
  fi

  # Contents of the config files.
  for at_file in atconfig atlocal
  do
    test -r $at_file || continue
    echo "$as_me: $at_file:"
    sed 's/^/| /' $at_file
    echo
  done

  cat <<\_ASBOX
## ---------------- ##
## Tested programs. ##
## ---------------- ##
_ASBOX
  echo
} >&5

# Report what programs are being tested.
for at_program in : $at_tested
do
  test "$at_program" = : && continue
  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -f "$as_dir/$at_program" && break
done
IFS=$as_save_IFS

  if test -f "$as_dir/$at_program"; then
    {
      echo "$at_srcdir/testsuite.at:25: $as_dir/$at_program --version"
      "$as_dir/$at_program" --version
      echo
    } >&5 2>&1
  else
    { { echo "$as_me:$LINENO: error: cannot find $at_program" >&5
echo "$as_me: error: cannot find $at_program" >&2;}
   { (exit 1); exit 1; }; }
  fi
done

{
  cat <<\_ASBOX
## ------------------ ##
## Running the tests. ##
## ------------------ ##
_ASBOX
} >&5

at_start_date=`date`
at_start_time=`date +%s 2>/dev/null`
echo "$as_me: starting at: $at_start_date" >&5
at_xpass_list=
at_xfail_list=
at_pass_list=
at_fail_list=
at_skip_list=
at_group_count=0

# Create the master directory if it doesn't already exist.
test -d "$at_suite_dir" ||
  mkdir "$at_suite_dir" ||
  { { echo "$as_me:$LINENO: error: cannot create '$at_suite_dir'" >&5
echo "$as_me: error: cannot create '$at_suite_dir'" >&2;}
   { (exit 1); exit 1; }; }

# Can we diff with `/dev/null'?  DU 5.0 refuses.
if diff /dev/null /dev/null >/dev/null 2>&1; then
  at_devnull=/dev/null
else
  at_devnull=$at_suite_dir/devnull
  >"$at_devnull"
fi

# Use `diff -u' when possible.
if at_diff=`diff -u "$at_devnull" "$at_devnull" 2>&1` && test -z "$at_diff"
then
  at_diff='diff -u'
else
  at_diff=diff
fi


for at_group in $at_groups
do
  # Be sure to come back to the top test directory.
  cd "$at_suite_dir"

  case $at_group in
    banner-*)
      at_group_log=$at_suite_log
      ;;

    *)
      at_group_normalized=$at_group

  while :; do
    case $at_group_normalized in #(
    $at_format*) break;;
    esac
    at_group_normalized=0$at_group_normalized
  done


      # Create a fresh directory for the next test group, and enter.
      at_group_dir=$at_suite_dir/$at_group_normalized
      at_group_log=$at_group_dir/$as_me.log
      if test -d "$at_group_dir"; then
	find "$at_group_dir" -type d ! -perm -700 -exec chmod u+rwx \{\} \;
	rm -fr "$at_group_dir"
      fi
      # Be tolerant if the above `rm' was not able to remove the directory.
      { as_dir=$at_group_dir
  case $as_dir in #(
  -*) as_dir=./$as_dir;;
  esac
  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
    as_dirs=
    while :; do
      case $as_dir in #(
      *\'*) as_qdir=`echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #(
      *) as_qdir=$as_dir;;
      esac
      as_dirs="'$as_qdir' $as_dirs"
      as_dir=`$as_dirname -- "$as_dir" ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$as_dir" : 'X\(//\)[^/]' \| \
	 X"$as_dir" : 'X\(//\)$' \| \
	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
echo X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
      test -d "$as_dir" && break
    done
    test -z "$as_dirs" || eval "mkdir $as_dirs"
  } || test -d "$as_dir" || { { echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
echo "$as_me: error: cannot create directory $as_dir" >&2;}
   { (exit 1); exit 1; }; }; }
      cd $at_group_dir
      ;;
  esac

  echo 0 > "$at_status_file"

  # Clearly separate the test groups when verbose.
  test $at_group_count != 0 && $at_verbose

  # In verbose mode, append to the log file *and* show on
  # the standard output; in quiet mode only write to the log
  if test $at_verbose = echo; then
    at_tee_pipe='tee -a "$at_group_log"'
  else
    at_tee_pipe='cat >> "$at_group_log"'
  fi

  case $at_group in

  banner-1 ) # Banner 1. unittests.at:1
    cat <<\_ATEOF

Running unit tests

_ATEOF
    ;;

  1 ) # 1. unittests.at:3: unittests
    at_setup_line='unittests.at:3'
    at_desc='unittests'
    $at_quiet $ECHO_N "  1: unittests                                    $ECHO_C"
    at_xfail=no
    echo "#                             -*- compilation -*-" >> "$at_group_log"
    (
      echo "1. unittests.at:3: testing ..."
      $at_traceon


$at_traceoff
echo "$at_srcdir/unittests.at:5: test -x ../../../unit_tests/dirac_unittest || exit 77"
echo unittests.at:5 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    at_trace_this=yes
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; test -x ../../../unit_tests/dirac_unittest || exit 77 ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; test -x ../../../unit_tests/dirac_unittest || exit 77 ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   *);;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon


$at_traceoff
echo "$at_srcdir/unittests.at:7: at_wrap dirac_unittest"
echo unittests.at:7 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    at_trace_this=yes
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_unittest ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_unittest ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
echo stderr:; tee stderr <"$at_stderr"
echo stdout:; tee stdout <"$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/unittests.at:7: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >"$at_times_file"
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat "$at_status_file"`
    ;;


  banner-2 ) # Banner 2. colourbars.at:1
    cat <<\_ATEOF

Checking encode and decode of colourbars

_ATEOF
    ;;

  2 ) # 2. colourbars.at:3: colourbars
    at_setup_line='colourbars.at:3'
    at_desc='colourbars'
    $at_quiet $ECHO_N "  2: colourbars                                   $ECHO_C"
    at_xfail=no
    echo "#                             -*- compilation -*-" >> "$at_group_log"
    (
      echo "2. colourbars.at:3: testing ..."
      $at_traceon


# FIXME: Once the encoder stops reporting "Can't read component picture data"
# FIXME: remove the [ignore] for stdout and stderr.
$at_traceoff
echo "$at_srcdir/colourbars.at:7: at_wrap dirac_encoder -cformat YUV420P -SD576I50 -qf 7 -num_L1 0 -local \$abs_srcdir/colourbars_420.yuv ../../colourbars_420_enc.drc"
echo colourbars.at:7 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -cformat YUV420P -SD576I50 -qf 7 -num_L1 0 -local $abs_srcdir/colourbars_420.yuv ../../colourbars_420_enc.drc" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -cformat YUV420P -SD576I50 -qf 7 -num_L1 0 -local $abs_srcdir/colourbars_420.yuv ../../colourbars_420_enc.drc ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -cformat YUV420P -SD576I50 -qf 7 -num_L1 0 -local $abs_srcdir/colourbars_420.yuv ../../colourbars_420_enc.drc ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/colourbars.at:7: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon


$at_traceoff
echo "$at_srcdir/colourbars.at:9: at_wrap dirac_decoder ../../colourbars_420_enc.drc ../../colourbars_420_dec.yuv"
echo colourbars.at:9 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    at_trace_this=yes
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../colourbars_420_enc.drc ../../colourbars_420_dec.yuv ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../colourbars_420_enc.drc ../../colourbars_420_dec.yuv ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/colourbars.at:9: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon


$at_traceoff
echo "$at_srcdir/colourbars.at:11: cmp ../../colourbars_420_enc.drc.localdec.yuv ../../colourbars_420_dec.yuv"
echo colourbars.at:11 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    at_trace_this=yes
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp ../../colourbars_420_enc.drc.localdec.yuv ../../colourbars_420_dec.yuv ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp ../../colourbars_420_enc.drc.localdec.yuv ../../colourbars_420_dec.yuv ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/colourbars.at:11: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >"$at_times_file"
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat "$at_status_file"`
    ;;


  banner-3 ) # Banner 3. samples.at:1
    cat <<\_ATEOF

Checking encode and decode of sample data

_ATEOF
    ;;

  3 ) # 3. samples.at:3: samples
    at_setup_line='samples.at:3'
    at_desc='samples'
    $at_quiet $ECHO_N "  3: samples                                      $ECHO_C"
    at_xfail=no
    echo "#                             -*- compilation -*-" >> "$at_group_log"
    (
      echo "3. samples.at:3: testing ..."
      $at_traceon


$at_traceoff
echo "$at_srcdir/samples.at:5: (test \$DIRAC_INPUT_DATA_DIR -a -d \$DIRAC_INPUT_DATA_DIR) || exit 77"
echo samples.at:5 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "(test $DIRAC_INPUT_DATA_DIR -a -d $DIRAC_INPUT_DATA_DIR) || exit 77" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; (test $DIRAC_INPUT_DATA_DIR -a -d $DIRAC_INPUT_DATA_DIR) || exit 77 ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; (test $DIRAC_INPUT_DATA_DIR -a -d $DIRAC_INPUT_DATA_DIR) || exit 77 ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   *);;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon


echo "HERE     "
for samp in `ls $DIRAC_INPUT_DATA_DIR/*.yuv`;
do
tsamp=`echo $samp | sed 's/\.yuv//g'`;
encout="$tsamp"_"enc.drc";
encout=`basename $encout`
decout="$tsamp"_"dec.yuv";
decout=`basename $decout`
instrout="$tsamp"_"instr";
instrout=`basename $instrout`

iframe_encout="$tsamp"_"iframe_enc.drc";
iframe_encout=`basename $iframe_encout`
iframe_decout="$tsamp"_"iframe_dec.yuv";
iframe_decout=`basename $iframe_decout`

vc2_encout="$tsamp"_"vc2_enc.drc";
vc2_encout=`basename $vc2_encout`
vc2_decout="$tsamp"_"vc2_dec.yuv";
vc2_decout=`basename $vc2_decout`

width=0
height=0
chroma="unknown"
preset=""

extras=""
# first tackle files name in the style nameFORMAT_CHROMA.yuv
# e.g. waterfallCIF_411 or waterfall576p_444 etc
case $tsamp in
*576p*)
	width=720
	height=576
	chroma=`echo $tsamp | sed -e 's/.*576p_\(.*\)/\1/'`
	;;
*720p*)
	width=1280;
	height=720;
	chroma=`echo $tsamp | sed -e 's/.*720p_\(.*\)/\1/'`
	;;
*1080i*)
	width=1920
	height=1080
	chroma=`echo $tsamp | sed -e 's/.*1080i_\(.*\)/\1/'`
	;;
*CIF*)
	width=352;
	height=288;
	chroma=`echo $tsamp | sed -e 's/.*CIF_\(.*\)/\1/'`
	;;
*)
	#handle files with names like name-WIDTHxHEIGHTxNUMFRAMES_CHROMA.yuv
	#e.g. snowboard-jum-720x576x50_430.yuv
	width=`echo $tsamp |  sed -e 's/.*[^0-9]\([0-9][0-9]*\)x\([0-9][0-9]*\)x[0-9][0-9]*_\(.*\)/\1/'`
	height=`echo $tsamp |  sed -e 's/.*[^0-9]\([0-9][0-9]*\)x\([0-9][0-9]*\)x[0-9][0-9]*_\(.*\)/\2/'`
	chroma=`echo $tsamp |  sed -e 's/.*[^0-9]\([0-9][0-9]*\)x\([0-9][0-9]*\)x[0-9][0-9]*_\(.*\)/\3/'`
	;;
esac

if test $width = $tsamp || test $height = $tsamp  || test $chroma = $tsamp;
then
	echo "Filename not in expected format :  $tsamp.yuv : Skipping this file..."
	continue;
fi

case $chroma in
"444")
	chroma="YUV444P";;
"422")
	chroma="YUV422P";;
"420")
	chroma="YUV420P";;
*)
	chroma="unknown";;
esac

#cannot proceed if with or height or chroma not set
if test $width -eq 0 || test $height -eq 0 || test $chroma = "unknown";
then
	continue;
fi

if test $width -eq 720 || test $height -eq 576;
then
	preset="-SD576I50";
	#luma block parameters
	xblen=12;
	xbsep=8;
	yblen=12;
	ybsep=8;
	bitrate="2000"
elif test $width -eq 1280 || test $height -eq 720;
then
	preset="-HD720P50";
	#luma block parameters
	xblen=16;
	xbsep=12;
	yblen=16
	ybsep=12;
	extras="-fr 25"; #sample data  is 25 fps
	bitrate="4000"
elif test $width -eq 1920 || test $height -eq 1080;
then
	preset="-HD1080I50";
	#luma block parameters
	xblen=24;
	xbsep=16;
	yblen=24;
	ybsep=16;
	bitrate="8000"
elif test $width -eq 176 || test $height -eq 144;
then
	preset="-QCIF";
	#luma block parameters
	xblen=8;
	xbsep=4;
	yblen=8;
	ybsep=4;
	bitrate="100"
else
	#luma block parameters
	xblen=12;
	xbsep=8;
	yblen=12;
	ybsep=8;
	preset="-CIF";
	bitrate="500"
fi

#set Motion vector precision here. Possible values are 1, 1/2, 1/4 and
# 1/8. Default value is 1/4
mv_prec=1/4
#extras=`echo $extras`" -L1_sep 6 -stop 6"

#iframe tests
#  progressive
#      constant quality
echo "iframe $samp $preset $chroma $width $height $mv_prec $extras"
$at_traceoff
echo "$at_srcdir/samples.at:145: at_wrap dirac_encoder -local -num_L1 0 \$preset -width \$width -height \$height -cformat \$chroma \$extras \$samp ../../\$iframe_encout"
echo samples.at:145 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../$iframe_encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../$iframe_encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../$iframe_encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:145: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:146: at_wrap dirac_decoder ../../\$iframe_encout ../../\$iframe_decout"
echo samples.at:146 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../$iframe_encout ../../$iframe_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../$iframe_encout ../../$iframe_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../$iframe_encout ../../$iframe_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:146: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:147: cmp ../../\$iframe_encout.localdec.yuv ../../\$iframe_decout"
echo samples.at:147 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp ../../$iframe_encout.localdec.yuv ../../$iframe_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp ../../$iframe_encout.localdec.yuv ../../$iframe_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp ../../$iframe_encout.localdec.yuv ../../$iframe_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:147: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#      constant bit-rate
echo "iframe $samp $preset $chroma $width $height $mv_prec $extras $bitrate"
$at_traceoff
echo "$at_srcdir/samples.at:150: at_wrap dirac_encoder -targetrate \$bitrate -local -num_L1 0 \$preset -width \$width -height \$height -cformat \$chroma \$extras \$samp ../../\$bitrate\"Kbps_\"\$iframe_encout"
echo samples.at:150 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -targetrate $bitrate -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../$bitrate\"Kbps_\"$iframe_encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -targetrate $bitrate -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../$bitrate"Kbps_"$iframe_encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -targetrate $bitrate -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../$bitrate"Kbps_"$iframe_encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:150: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:151: at_wrap dirac_decoder ../../\$bitrate\"Kbps_\"\$iframe_encout ../../\$bitrate\"Kbps_\"\$iframe_decout"
echo samples.at:151 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../$bitrate\"Kbps_\"$iframe_encout ../../$bitrate\"Kbps_\"$iframe_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../$bitrate"Kbps_"$iframe_encout ../../$bitrate"Kbps_"$iframe_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../$bitrate"Kbps_"$iframe_encout ../../$bitrate"Kbps_"$iframe_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:151: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:152: cmp ../../\$bitrate\"Kbps_\"\$iframe_encout.localdec.yuv ../../\$bitrate\"Kbps_\"\$iframe_decout"
echo samples.at:152 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp ../../$bitrate\"Kbps_\"$iframe_encout.localdec.yuv ../../$bitrate\"Kbps_\"$iframe_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp ../../$bitrate"Kbps_"$iframe_encout.localdec.yuv ../../$bitrate"Kbps_"$iframe_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp ../../$bitrate"Kbps_"$iframe_encout.localdec.yuv ../../$bitrate"Kbps_"$iframe_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:152: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#      lossless
echo "iframe lossless $samp $preset $chroma $width $height $mv_prec $extras"
$at_traceoff
echo "$at_srcdir/samples.at:155: at_wrap dirac_encoder -lossless -local -num_L1 0 \$preset -width \$width -height \$height -cformat \$chroma \$extras \$samp ../../\"lossless_\"\$iframe_encout"
echo samples.at:155 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -lossless -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../\"lossless_\"$iframe_encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -lossless -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../"lossless_"$iframe_encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -lossless -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../"lossless_"$iframe_encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:155: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:156: at_wrap dirac_decoder ../../\"lossless_\"\$iframe_encout ../../\"lossless_\"\$iframe_decout"
echo samples.at:156 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../\"lossless_\"$iframe_encout ../../\"lossless_\"$iframe_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../"lossless_"$iframe_encout ../../"lossless_"$iframe_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../"lossless_"$iframe_encout ../../"lossless_"$iframe_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:156: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:157: cmp ../../\"lossless_\"\$iframe_encout.localdec.yuv ../../\"lossless_\"\$iframe_decout"
echo samples.at:157 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp ../../\"lossless_\"$iframe_encout.localdec.yuv ../../\"lossless_\"$iframe_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp ../../"lossless_"$iframe_encout.localdec.yuv ../../"lossless_"$iframe_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp ../../"lossless_"$iframe_encout.localdec.yuv ../../"lossless_"$iframe_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:157: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:158: cmp \$samp ../../\"lossless_\"\$iframe_decout"
echo samples.at:158 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp $samp ../../\"lossless_\"$iframe_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp $samp ../../"lossless_"$iframe_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp $samp ../../"lossless_"$iframe_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:158: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon


# interlaced
#      constant quality
echo "interlaced iframe $samp $preset $chroma $width $height $mv_prec $extras"
$at_traceoff
echo "$at_srcdir/samples.at:163: at_wrap dirac_encoder -field_coding -local -num_L1 0 \$preset -width \$width -height \$height -cformat \$chroma \$extras \$samp ../../\"inter_\"\$iframe_encout"
echo samples.at:163 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -field_coding -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../\"inter_\"$iframe_encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -field_coding -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../"inter_"$iframe_encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -field_coding -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../"inter_"$iframe_encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:163: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:164: at_wrap dirac_decoder ../../\"inter_\"\$iframe_encout ../../\"inter_\"\$iframe_decout"
echo samples.at:164 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../\"inter_\"$iframe_encout ../../\"inter_\"$iframe_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../"inter_"$iframe_encout ../../"inter_"$iframe_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../"inter_"$iframe_encout ../../"inter_"$iframe_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:164: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#      constant bit-rate
echo "interlaced iframe $samp $preset $chroma $width $height $mv_prec $extras $bitrate"
$at_traceoff
echo "$at_srcdir/samples.at:167: at_wrap dirac_encoder -targetrate \$bitrate -field_coding -local -num_L1 0 \$preset -width \$width -height \$height -cformat \$chroma \$extras \$samp ../../\$bitrate\"Kbps_inter_\"\$iframe_encout"
echo samples.at:167 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -targetrate $bitrate -field_coding -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../$bitrate\"Kbps_inter_\"$iframe_encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -targetrate $bitrate -field_coding -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../$bitrate"Kbps_inter_"$iframe_encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -targetrate $bitrate -field_coding -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../$bitrate"Kbps_inter_"$iframe_encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:167: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:168: at_wrap dirac_decoder ../../\$bitrate\"Kbps_inter_\"\$iframe_encout ../../\$bitrate\"Kbps_inter_\"\$iframe_decout"
echo samples.at:168 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../$bitrate\"Kbps_inter_\"$iframe_encout ../../$bitrate\"Kbps_inter_\"$iframe_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../$bitrate"Kbps_inter_"$iframe_encout ../../$bitrate"Kbps_inter_"$iframe_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../$bitrate"Kbps_inter_"$iframe_encout ../../$bitrate"Kbps_inter_"$iframe_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:168: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#      lossless
echo "interlaced iframe lossless $samp $preset $chroma $width $height $mv_prec $extras"
$at_traceoff
echo "$at_srcdir/samples.at:171: at_wrap dirac_encoder -lossless -field_coding -local -num_L1 0 \$preset -width \$width -height \$height -cformat \$chroma \$extras \$samp ../../\"lossless_inter_\"\$iframe_encout"
echo samples.at:171 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -lossless -field_coding -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../\"lossless_inter_\"$iframe_encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -lossless -field_coding -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../"lossless_inter_"$iframe_encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -lossless -field_coding -local -num_L1 0 $preset -width $width -height $height -cformat $chroma $extras $samp ../../"lossless_inter_"$iframe_encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:171: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:172: at_wrap dirac_decoder ../../\"lossless_inter_\"\$iframe_encout ../../\"lossless_inter_\"\$iframe_decout"
echo samples.at:172 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../\"lossless_inter_\"$iframe_encout ../../\"lossless_inter_\"$iframe_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../"lossless_inter_"$iframe_encout ../../"lossless_inter_"$iframe_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../"lossless_inter_"$iframe_encout ../../"lossless_inter_"$iframe_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:172: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:173: cmp \$samp ../../\"lossless_inter_\"\$iframe_decout"
echo samples.at:173 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp $samp ../../\"lossless_inter_\"$iframe_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp $samp ../../"lossless_inter_"$iframe_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp $samp ../../"lossless_inter_"$iframe_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:173: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon




#vc-2 stream tests
# progressive
#      constant quality
$at_traceoff
echo "$at_srcdir/samples.at:180: at_wrap dirac_encoder -use_vlc -local -num_L1 0 \$preset -width \$width -height \$height -cformat \$chroma  \$extras \$samp ../../\$vc2_encout"
echo samples.at:180 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../$vc2_encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../$vc2_encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../$vc2_encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:180: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:181: at_wrap dirac_decoder ../../\$vc2_encout ../../\$vc2_decout"
echo samples.at:181 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../$vc2_encout ../../$vc2_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../$vc2_encout ../../$vc2_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../$vc2_encout ../../$vc2_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:181: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:182: cmp ../../\$vc2_encout.localdec.yuv ../../\$vc2_decout"
echo samples.at:182 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp ../../$vc2_encout.localdec.yuv ../../$vc2_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp ../../$vc2_encout.localdec.yuv ../../$vc2_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp ../../$vc2_encout.localdec.yuv ../../$vc2_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:182: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#      constant bit-rate
$at_traceoff
echo "$at_srcdir/samples.at:184: at_wrap dirac_encoder -targetrate \$bitrate -use_vlc -local -num_L1 0 \$preset -width \$width -height \$height -cformat \$chroma  \$extras \$samp ../../\$bitrate\"Kbps_\"\$vc2_encout"
echo samples.at:184 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -targetrate $bitrate -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../$bitrate\"Kbps_\"$vc2_encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -targetrate $bitrate -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../$bitrate"Kbps_"$vc2_encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -targetrate $bitrate -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../$bitrate"Kbps_"$vc2_encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:184: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:185: at_wrap dirac_decoder ../../\$bitrate\"Kbps_\"\$vc2_encout ../../\$bitrate\"Kbps_\"\$vc2_decout"
echo samples.at:185 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../$bitrate\"Kbps_\"$vc2_encout ../../$bitrate\"Kbps_\"$vc2_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../$bitrate"Kbps_"$vc2_encout ../../$bitrate"Kbps_"$vc2_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../$bitrate"Kbps_"$vc2_encout ../../$bitrate"Kbps_"$vc2_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:185: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:186: cmp ../../\$bitrate\"Kbps_\"\$vc2_encout.localdec.yuv ../../\$bitrate\"Kbps_\"\$vc2_decout"
echo samples.at:186 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp ../../$bitrate\"Kbps_\"$vc2_encout.localdec.yuv ../../$bitrate\"Kbps_\"$vc2_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp ../../$bitrate"Kbps_"$vc2_encout.localdec.yuv ../../$bitrate"Kbps_"$vc2_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp ../../$bitrate"Kbps_"$vc2_encout.localdec.yuv ../../$bitrate"Kbps_"$vc2_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:186: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#      lossless
$at_traceoff
echo "$at_srcdir/samples.at:188: at_wrap dirac_encoder -lossless -use_vlc -local -num_L1 0 \$preset -width \$width -height \$height -cformat \$chroma  \$extras \$samp ../../\"lossless_\"\$vc2_encout"
echo samples.at:188 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -lossless -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../\"lossless_\"$vc2_encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -lossless -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../"lossless_"$vc2_encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -lossless -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../"lossless_"$vc2_encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:188: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:189: at_wrap dirac_decoder ../../\"lossless_\"\$vc2_encout ../../\"lossless_\"\$vc2_decout"
echo samples.at:189 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../\"lossless_\"$vc2_encout ../../\"lossless_\"$vc2_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../"lossless_"$vc2_encout ../../"lossless_"$vc2_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../"lossless_"$vc2_encout ../../"lossless_"$vc2_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:189: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:190: cmp ../../\"lossless_\"\$vc2_encout.localdec.yuv ../../\"lossless_\"\$vc2_decout"
echo samples.at:190 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp ../../\"lossless_\"$vc2_encout.localdec.yuv ../../\"lossless_\"$vc2_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp ../../"lossless_"$vc2_encout.localdec.yuv ../../"lossless_"$vc2_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp ../../"lossless_"$vc2_encout.localdec.yuv ../../"lossless_"$vc2_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:190: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:191: cmp \$samp ../../\"lossless_\"\$vc2_decout"
echo samples.at:191 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp $samp ../../\"lossless_\"$vc2_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp $samp ../../"lossless_"$vc2_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp $samp ../../"lossless_"$vc2_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:191: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon


# interlaced
#      constant quality
$at_traceoff
echo "$at_srcdir/samples.at:195: at_wrap dirac_encoder -field_coding -use_vlc -local -num_L1 0 \$preset -width \$width -height \$height -cformat \$chroma  \$extras \$samp ../../\"inter_\"\$vc2_encout"
echo samples.at:195 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -field_coding -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../\"inter_\"$vc2_encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -field_coding -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../"inter_"$vc2_encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -field_coding -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../"inter_"$vc2_encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:195: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:196: at_wrap dirac_decoder ../../\"inter_\"\$vc2_encout ../../\"inter_\"\$vc2_decout"
echo samples.at:196 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../\"inter_\"$vc2_encout ../../\"inter_\"$vc2_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../"inter_"$vc2_encout ../../"inter_"$vc2_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../"inter_"$vc2_encout ../../"inter_"$vc2_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:196: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#      constant bit-rate
$at_traceoff
echo "$at_srcdir/samples.at:198: at_wrap dirac_encoder -targetrate \$bitrate -field_coding -use_vlc -local -num_L1 0 \$preset -width \$width -height \$height -cformat \$chroma  \$extras \$samp ../../\$bitrate\"Kbps_inter_\"\$vc2_encout"
echo samples.at:198 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -targetrate $bitrate -field_coding -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../$bitrate\"Kbps_inter_\"$vc2_encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -targetrate $bitrate -field_coding -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../$bitrate"Kbps_inter_"$vc2_encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -targetrate $bitrate -field_coding -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../$bitrate"Kbps_inter_"$vc2_encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:198: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:199: at_wrap dirac_decoder ../../\$bitrate\"Kbps_inter_\"\$vc2_encout ../../\$bitrate\"Kbps_inter_\"\$vc2_decout"
echo samples.at:199 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../$bitrate\"Kbps_inter_\"$vc2_encout ../../$bitrate\"Kbps_inter_\"$vc2_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../$bitrate"Kbps_inter_"$vc2_encout ../../$bitrate"Kbps_inter_"$vc2_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../$bitrate"Kbps_inter_"$vc2_encout ../../$bitrate"Kbps_inter_"$vc2_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:199: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#      lossless
$at_traceoff
echo "$at_srcdir/samples.at:201: at_wrap dirac_encoder -lossless -field_coding -use_vlc -local -num_L1 0 \$preset -width \$width -height \$height -cformat \$chroma  \$extras \$samp ../../\"lossless_inter_\"\$vc2_encout"
echo samples.at:201 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -lossless -field_coding -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../\"lossless_inter_\"$vc2_encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -lossless -field_coding -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../"lossless_inter_"$vc2_encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -lossless -field_coding -use_vlc -local -num_L1 0 $preset -width $width -height $height -cformat $chroma  $extras $samp ../../"lossless_inter_"$vc2_encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:201: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:202: at_wrap dirac_decoder ../../\"lossless_inter_\"\$vc2_encout ../../\"lossless_inter_\"\$vc2_decout"
echo samples.at:202 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../\"lossless_inter_\"$vc2_encout ../../\"lossless_inter_\"$vc2_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../"lossless_inter_"$vc2_encout ../../"lossless_inter_"$vc2_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../"lossless_inter_"$vc2_encout ../../"lossless_inter_"$vc2_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:202: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:203: cmp \$samp ../../\"lossless_inter_\"\$vc2_decout"
echo samples.at:203 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp $samp ../../\"lossless_inter_\"$vc2_decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp $samp ../../"lossless_inter_"$vc2_decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp $samp ../../"lossless_inter_"$vc2_decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:203: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon


#Long-GOP tests
# progressive
#      constant quality
$at_traceoff
echo "$at_srcdir/samples.at:208: at_wrap dirac_encoder -local \$preset -width \$width -height \$height -cformat \$chroma  -xblen \$xblen -xbsep \$xbsep -yblen \$yblen -ybsep \$ybsep -mv_prec \$mv_prec \$extras \$samp ../../\$encout"
echo samples.at:208 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../$encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../$encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../$encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:208: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:209: at_wrap dirac_decoder ../../\$encout ../../\$decout"
echo samples.at:209 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../$encout ../../$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../$encout ../../$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../$encout ../../$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:209: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:210: cmp ../../\$encout.localdec.yuv ../../\$decout"
echo samples.at:210 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp ../../$encout.localdec.yuv ../../$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp ../../$encout.localdec.yuv ../../$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp ../../$encout.localdec.yuv ../../$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:210: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:211: at_wrap dirac_instrumentation ../../\$encout ../../\"\$instrout\"_mc_instr.yuv -motion_colour -clip 50"
echo samples.at:211 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_instrumentation ../../$encout ../../\"$instrout\"_mc_instr.yuv -motion_colour -clip 50" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_instrumentation ../../$encout ../../"$instrout"_mc_instr.yuv -motion_colour -clip 50 ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_instrumentation ../../$encout ../../"$instrout"_mc_instr.yuv -motion_colour -clip 50 ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:211: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:212: at_wrap dirac_instrumentation ../../\$encout ../../\"\$instrout\"_ma_instr.yuv -motion_arrows -clip 50"
echo samples.at:212 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_instrumentation ../../$encout ../../\"$instrout\"_ma_instr.yuv -motion_arrows -clip 50" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_instrumentation ../../$encout ../../"$instrout"_ma_instr.yuv -motion_arrows -clip 50 ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_instrumentation ../../$encout ../../"$instrout"_ma_instr.yuv -motion_arrows -clip 50 ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:212: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:213: at_wrap dirac_instrumentation ../../\$encout ../../\"\$instrout\"_mca_instr.yuv -motion_colour_arrows -clip 50"
echo samples.at:213 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_instrumentation ../../$encout ../../\"$instrout\"_mca_instr.yuv -motion_colour_arrows -clip 50" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_instrumentation ../../$encout ../../"$instrout"_mca_instr.yuv -motion_colour_arrows -clip 50 ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_instrumentation ../../$encout ../../"$instrout"_mca_instr.yuv -motion_colour_arrows -clip 50 ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:213: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:214: at_wrap dirac_instrumentation ../../\$encout ../../\"\$instrout\"_spm_instr.yuv -split_mode -clip 50"
echo samples.at:214 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_instrumentation ../../$encout ../../\"$instrout\"_spm_instr.yuv -split_mode -clip 50" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_instrumentation ../../$encout ../../"$instrout"_spm_instr.yuv -split_mode -clip 50 ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_instrumentation ../../$encout ../../"$instrout"_spm_instr.yuv -split_mode -clip 50 ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:214: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:215: at_wrap dirac_instrumentation ../../\$encout ../../\"\$instrout\"_sad_instr.yuv -sad -clip 50"
echo samples.at:215 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_instrumentation ../../$encout ../../\"$instrout\"_sad_instr.yuv -sad -clip 50" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_instrumentation ../../$encout ../../"$instrout"_sad_instr.yuv -sad -clip 50 ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_instrumentation ../../$encout ../../"$instrout"_sad_instr.yuv -sad -clip 50 ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:215: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:216: at_wrap dirac_instrumentation ../../\$encout ../../\"\$instrout\"_pred_instr.yuv -pred_mode -clip 50"
echo samples.at:216 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_instrumentation ../../$encout ../../\"$instrout\"_pred_instr.yuv -pred_mode -clip 50" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_instrumentation ../../$encout ../../"$instrout"_pred_instr.yuv -pred_mode -clip 50 ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_instrumentation ../../$encout ../../"$instrout"_pred_instr.yuv -pred_mode -clip 50 ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:216: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#      constant bit-rate
$at_traceoff
echo "$at_srcdir/samples.at:218: at_wrap dirac_encoder -targetrate \$bitrate -local \$preset -width \$width -height \$height -cformat \$chroma  -xblen \$xblen -xbsep \$xbsep -yblen \$yblen -ybsep \$ybsep -mv_prec \$mv_prec \$extras \$samp ../../\$bitrate\"Kbps_\"\$encout"
echo samples.at:218 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -targetrate $bitrate -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../$bitrate\"Kbps_\"$encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -targetrate $bitrate -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../$bitrate"Kbps_"$encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -targetrate $bitrate -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../$bitrate"Kbps_"$encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:218: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:219: at_wrap dirac_decoder ../../\$bitrate\"Kbps_\"\$encout ../../\$bitrate\"Kbps_\"\$decout"
echo samples.at:219 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../$bitrate\"Kbps_\"$encout ../../$bitrate\"Kbps_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../$bitrate"Kbps_"$encout ../../$bitrate"Kbps_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../$bitrate"Kbps_"$encout ../../$bitrate"Kbps_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:219: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:220: cmp ../../\$bitrate\"Kbps_\"\$encout.localdec.yuv ../../\$bitrate\"Kbps_\"\$decout"
echo samples.at:220 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp ../../$bitrate\"Kbps_\"$encout.localdec.yuv ../../$bitrate\"Kbps_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp ../../$bitrate"Kbps_"$encout.localdec.yuv ../../$bitrate"Kbps_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp ../../$bitrate"Kbps_"$encout.localdec.yuv ../../$bitrate"Kbps_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:220: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#      lossless
$at_traceoff
echo "$at_srcdir/samples.at:222: at_wrap dirac_encoder -lossless -local \$preset -width \$width -height \$height -cformat \$chroma  -xblen \$xblen -xbsep \$xbsep -yblen \$yblen -ybsep \$ybsep -mv_prec \$mv_prec \$extras \$samp ../../\"lossless_\"\$encout"
echo samples.at:222 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -lossless -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../\"lossless_\"$encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -lossless -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"lossless_"$encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -lossless -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"lossless_"$encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:222: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:223: at_wrap dirac_decoder ../../\"lossless_\"\$encout ../../\"lossless_\"\$decout"
echo samples.at:223 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../\"lossless_\"$encout ../../\"lossless_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../"lossless_"$encout ../../"lossless_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../"lossless_"$encout ../../"lossless_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:223: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:224: cmp ../../\"lossless_\"\$encout.localdec.yuv ../../\"lossless_\"\$decout"
echo samples.at:224 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp ../../\"lossless_\"$encout.localdec.yuv ../../\"lossless_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp ../../"lossless_"$encout.localdec.yuv ../../"lossless_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp ../../"lossless_"$encout.localdec.yuv ../../"lossless_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:224: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:225: cmp \$samp ../../\"lossless_\"\$decout"
echo samples.at:225 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp $samp ../../\"lossless_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp $samp ../../"lossless_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp $samp ../../"lossless_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:225: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#     modified GOP structure
$at_traceoff
echo "$at_srcdir/samples.at:227: at_wrap dirac_encoder -L1_sep 6 -local \$preset -width \$width -height \$height -cformat \$chroma  -xblen \$xblen -xbsep \$xbsep -yblen \$yblen -ybsep \$ybsep -mv_prec \$mv_prec \$extras \$samp ../../\"L1sep6_\"\$encout"
echo samples.at:227 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -L1_sep 6 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../\"L1sep6_\"$encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -L1_sep 6 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"L1sep6_"$encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -L1_sep 6 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"L1sep6_"$encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:227: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:228: at_wrap dirac_decoder ../../\"L1sep6_\"\$encout ../../\"L1sep6_\"\$decout"
echo samples.at:228 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../\"L1sep6_\"$encout ../../\"L1sep6_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../"L1sep6_"$encout ../../"L1sep6_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../"L1sep6_"$encout ../../"L1sep6_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:228: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:229: cmp ../../\"L1sep6_\"\$encout.localdec.yuv ../../\"L1sep6_\"\$decout"
echo samples.at:229 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp ../../\"L1sep6_\"$encout.localdec.yuv ../../\"L1sep6_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp ../../"L1sep6_"$encout.localdec.yuv ../../"L1sep6_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp ../../"L1sep6_"$encout.localdec.yuv ../../"L1sep6_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:229: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#     pre-filter CWM
$at_traceoff
echo "$at_srcdir/samples.at:231: at_wrap dirac_encoder -prefilter CWM 5 -local \$preset -width \$width -height \$height -cformat \$chroma  -xblen \$xblen -xbsep \$xbsep -yblen \$yblen -ybsep \$ybsep -mv_prec \$mv_prec \$extras \$samp ../../\"cwm5_\"\$encout"
echo samples.at:231 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -prefilter CWM 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../\"cwm5_\"$encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -prefilter CWM 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"cwm5_"$encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -prefilter CWM 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"cwm5_"$encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:231: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:232: at_wrap dirac_decoder ../../\"cwm5_\"\$encout ../../\"cwm5_\"\$decout"
echo samples.at:232 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../\"cwm5_\"$encout ../../\"cwm5_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../"cwm5_"$encout ../../"cwm5_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../"cwm5_"$encout ../../"cwm5_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:232: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:233: cmp ../../\"cwm5_\"\$encout.localdec.yuv ../../\"cwm5_\"\$decout"
echo samples.at:233 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp ../../\"cwm5_\"$encout.localdec.yuv ../../\"cwm5_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp ../../"cwm5_"$encout.localdec.yuv ../../"cwm5_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp ../../"cwm5_"$encout.localdec.yuv ../../"cwm5_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:233: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#     pre-filter RECTLP
$at_traceoff
echo "$at_srcdir/samples.at:235: at_wrap dirac_encoder -prefilter RECTLP 5 -local \$preset -width \$width -height \$height -cformat \$chroma  -xblen \$xblen -xbsep \$xbsep -yblen \$yblen -ybsep \$ybsep -mv_prec \$mv_prec \$extras \$samp ../../\"rectlp5_\"\$encout"
echo samples.at:235 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -prefilter RECTLP 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../\"rectlp5_\"$encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -prefilter RECTLP 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"rectlp5_"$encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -prefilter RECTLP 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"rectlp5_"$encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:235: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:236: at_wrap dirac_decoder ../../\"rectlp5_\"\$encout ../../\"rectlp5_\"\$decout"
echo samples.at:236 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../\"rectlp5_\"$encout ../../\"rectlp5_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../"rectlp5_"$encout ../../"rectlp5_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../"rectlp5_"$encout ../../"rectlp5_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:236: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:237: cmp ../../\"rectlp5_\"\$encout.localdec.yuv ../../\"rectlp5_\"\$decout"
echo samples.at:237 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp ../../\"rectlp5_\"$encout.localdec.yuv ../../\"rectlp5_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp ../../"rectlp5_"$encout.localdec.yuv ../../"rectlp5_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp ../../"rectlp5_"$encout.localdec.yuv ../../"rectlp5_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:237: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#     pre-filter DIAGLP
$at_traceoff
echo "$at_srcdir/samples.at:239: at_wrap dirac_encoder -prefilter DIAGLP 5 -local \$preset -width \$width -height \$height -cformat \$chroma  -xblen \$xblen -xbsep \$xbsep -yblen \$yblen -ybsep \$ybsep -mv_prec \$mv_prec \$extras \$samp ../../\"diaglp5_\"\$encout"
echo samples.at:239 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -prefilter DIAGLP 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../\"diaglp5_\"$encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -prefilter DIAGLP 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"diaglp5_"$encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -prefilter DIAGLP 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"diaglp5_"$encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:239: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:240: at_wrap dirac_decoder ../../\"diaglp5_\"\$encout ../../\"diaglp5_\"\$decout"
echo samples.at:240 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../\"diaglp5_\"$encout ../../\"diaglp5_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../"diaglp5_"$encout ../../"diaglp5_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../"diaglp5_"$encout ../../"diaglp5_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:240: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:241: cmp ../../\"diaglp5_\"\$encout.localdec.yuv ../../\"diaglp5_\"\$decout"
echo samples.at:241 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp ../../\"diaglp5_\"$encout.localdec.yuv ../../\"diaglp5_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp ../../"diaglp5_"$encout.localdec.yuv ../../"diaglp5_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp ../../"diaglp5_"$encout.localdec.yuv ../../"diaglp5_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:241: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon


# interlaced
#      constant quality
$at_traceoff
echo "$at_srcdir/samples.at:245: at_wrap dirac_encoder -field_coding -local \$preset -width \$width -height \$height -cformat \$chroma  -xblen \$xblen -xbsep \$xbsep -yblen \$yblen -ybsep \$ybsep -mv_prec \$mv_prec \$extras \$samp ../../\"inter_\"\$encout"
echo samples.at:245 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -field_coding -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../\"inter_\"$encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -field_coding -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"inter_"$encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -field_coding -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"inter_"$encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:245: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:246: at_wrap dirac_decoder ../../\"inter_\"\$encout ../../\"inter_\"\$decout"
echo samples.at:246 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../\"inter_\"$encout ../../\"inter_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../"inter_"$encout ../../"inter_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../"inter_"$encout ../../"inter_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:246: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:247: at_wrap dirac_instrumentation ../../\"inter_\"\$encout ../../\"inter_\"\"\$instrout\"_mc_instr.yuv -motion_colour -clip 50"
echo samples.at:247 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_instrumentation ../../\"inter_\"$encout ../../\"inter_\"\"$instrout\"_mc_instr.yuv -motion_colour -clip 50" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_instrumentation ../../"inter_"$encout ../../"inter_""$instrout"_mc_instr.yuv -motion_colour -clip 50 ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_instrumentation ../../"inter_"$encout ../../"inter_""$instrout"_mc_instr.yuv -motion_colour -clip 50 ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:247: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:248: at_wrap dirac_instrumentation ../../\"inter_\"\$encout ../../\"inter_\"\"\$instrout\"_ma_instr.yuv -motion_arrows -clip 50"
echo samples.at:248 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_instrumentation ../../\"inter_\"$encout ../../\"inter_\"\"$instrout\"_ma_instr.yuv -motion_arrows -clip 50" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_instrumentation ../../"inter_"$encout ../../"inter_""$instrout"_ma_instr.yuv -motion_arrows -clip 50 ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_instrumentation ../../"inter_"$encout ../../"inter_""$instrout"_ma_instr.yuv -motion_arrows -clip 50 ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:248: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:249: at_wrap dirac_instrumentation ../../\"inter_\"\$encout ../../\"inter_\"\"\$instrout\"_mca_instr.yuv -motion_colour_arrows -clip 50"
echo samples.at:249 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_instrumentation ../../\"inter_\"$encout ../../\"inter_\"\"$instrout\"_mca_instr.yuv -motion_colour_arrows -clip 50" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_instrumentation ../../"inter_"$encout ../../"inter_""$instrout"_mca_instr.yuv -motion_colour_arrows -clip 50 ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_instrumentation ../../"inter_"$encout ../../"inter_""$instrout"_mca_instr.yuv -motion_colour_arrows -clip 50 ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:249: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:250: at_wrap dirac_instrumentation ../../\"inter_\"\$encout ../../\"inter_\"\"\$instrout\"_spm_instr.yuv -split_mode -clip 50"
echo samples.at:250 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_instrumentation ../../\"inter_\"$encout ../../\"inter_\"\"$instrout\"_spm_instr.yuv -split_mode -clip 50" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_instrumentation ../../"inter_"$encout ../../"inter_""$instrout"_spm_instr.yuv -split_mode -clip 50 ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_instrumentation ../../"inter_"$encout ../../"inter_""$instrout"_spm_instr.yuv -split_mode -clip 50 ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:250: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:251: at_wrap dirac_instrumentation ../../\"inter_\"\$encout ../../\"inter_\"\"\$instrout\"_sad_instr.yuv -sad -clip 50"
echo samples.at:251 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_instrumentation ../../\"inter_\"$encout ../../\"inter_\"\"$instrout\"_sad_instr.yuv -sad -clip 50" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_instrumentation ../../"inter_"$encout ../../"inter_""$instrout"_sad_instr.yuv -sad -clip 50 ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_instrumentation ../../"inter_"$encout ../../"inter_""$instrout"_sad_instr.yuv -sad -clip 50 ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:251: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:252: at_wrap dirac_instrumentation ../../\"inter_\"\$encout ../../\"inter_\"\"\$instrout\"_pred_instr.yuv -pred_mode -clip 50"
echo samples.at:252 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_instrumentation ../../\"inter_\"$encout ../../\"inter_\"\"$instrout\"_pred_instr.yuv -pred_mode -clip 50" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_instrumentation ../../"inter_"$encout ../../"inter_""$instrout"_pred_instr.yuv -pred_mode -clip 50 ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_instrumentation ../../"inter_"$encout ../../"inter_""$instrout"_pred_instr.yuv -pred_mode -clip 50 ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:252: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#      constant bit-rate
$at_traceoff
echo "$at_srcdir/samples.at:254: at_wrap dirac_encoder -targetrate \$bitrate -field_coding -local \$preset -width \$width -height \$height -cformat \$chroma  -xblen \$xblen -xbsep \$xbsep -yblen \$yblen -ybsep \$ybsep -mv_prec \$mv_prec \$extras \$samp ../../\$bitrate\"Kbps_inter_\"\$encout"
echo samples.at:254 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -targetrate $bitrate -field_coding -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../$bitrate\"Kbps_inter_\"$encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -targetrate $bitrate -field_coding -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../$bitrate"Kbps_inter_"$encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -targetrate $bitrate -field_coding -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../$bitrate"Kbps_inter_"$encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:254: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:255: at_wrap dirac_decoder ../../\$bitrate\"Kbps_inter_\"\$encout ../../\$bitrate\"Kbps_inter_\"\$decout"
echo samples.at:255 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../$bitrate\"Kbps_inter_\"$encout ../../$bitrate\"Kbps_inter_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../$bitrate"Kbps_inter_"$encout ../../$bitrate"Kbps_inter_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../$bitrate"Kbps_inter_"$encout ../../$bitrate"Kbps_inter_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:255: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#      lossless
$at_traceoff
echo "$at_srcdir/samples.at:257: at_wrap dirac_encoder -lossless -field_coding -local \$preset -width \$width -height \$height -cformat \$chroma  -xblen \$xblen -xbsep \$xbsep -yblen \$yblen -ybsep \$ybsep -mv_prec \$mv_prec \$extras \$samp ../../\"lossless_inter_\"\$encout"
echo samples.at:257 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -lossless -field_coding -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../\"lossless_inter_\"$encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -lossless -field_coding -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"lossless_inter_"$encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -lossless -field_coding -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"lossless_inter_"$encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:257: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:258: at_wrap dirac_decoder ../../\"lossless_inter_\"\$encout ../../\"lossless_inter_\"\$decout"
echo samples.at:258 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../\"lossless_inter_\"$encout ../../\"lossless_inter_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../"lossless_inter_"$encout ../../"lossless_inter_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../"lossless_inter_"$encout ../../"lossless_inter_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:258: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:259: cmp \$samp ../../\"lossless_inter_\"\$decout"
echo samples.at:259 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "cmp $samp ../../\"lossless_inter_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; cmp $samp ../../"lossless_inter_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; cmp $samp ../../"lossless_inter_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
$at_diff "$at_devnull" "$at_stdout" || at_failed=:
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:259: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#     modified GOP structure
$at_traceoff
echo "$at_srcdir/samples.at:261: at_wrap dirac_encoder -L1_sep 6 -field_coding -local \$preset -width \$width -height \$height -cformat \$chroma  -xblen \$xblen -xbsep \$xbsep -yblen \$yblen -ybsep \$ybsep -mv_prec \$mv_prec \$extras \$samp ../../\"L1sep6_inter_\"\$encout"
echo samples.at:261 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -L1_sep 6 -field_coding -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../\"L1sep6_inter_\"$encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -L1_sep 6 -field_coding -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"L1sep6_inter_"$encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -L1_sep 6 -field_coding -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"L1sep6_inter_"$encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:261: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:262: at_wrap dirac_decoder ../../\"L1sep6_inter_\"\$encout ../../\"L1sep6_inter_\"\$decout"
echo samples.at:262 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../\"L1sep6_inter_\"$encout ../../\"L1sep6_inter_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../"L1sep6_inter_"$encout ../../"L1sep6_inter_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../"L1sep6_inter_"$encout ../../"L1sep6_inter_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:262: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#     pre-filter CWM
$at_traceoff
echo "$at_srcdir/samples.at:264: at_wrap dirac_encoder -field_coding -prefilter CWM 5 -local \$preset -width \$width -height \$height -cformat \$chroma  -xblen \$xblen -xbsep \$xbsep -yblen \$yblen -ybsep \$ybsep -mv_prec \$mv_prec \$extras \$samp ../../\"inter_cwm5_\"\$encout"
echo samples.at:264 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -field_coding -prefilter CWM 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../\"inter_cwm5_\"$encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -field_coding -prefilter CWM 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"inter_cwm5_"$encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -field_coding -prefilter CWM 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"inter_cwm5_"$encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:264: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:265: at_wrap dirac_decoder ../../\"inter_cwm5_\"\$encout ../../\"inter_cwm5_\"\$decout"
echo samples.at:265 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../\"inter_cwm5_\"$encout ../../\"inter_cwm5_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../"inter_cwm5_"$encout ../../"inter_cwm5_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../"inter_cwm5_"$encout ../../"inter_cwm5_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:265: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#     pre-filter RECTLP
$at_traceoff
echo "$at_srcdir/samples.at:267: at_wrap dirac_encoder -field_coding -prefilter RECTLP 5 -local \$preset -width \$width -height \$height -cformat \$chroma  -xblen \$xblen -xbsep \$xbsep -yblen \$yblen -ybsep \$ybsep -mv_prec \$mv_prec \$extras \$samp ../../\"inter_rectlp5_\"\$encout"
echo samples.at:267 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -field_coding -prefilter RECTLP 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../\"inter_rectlp5_\"$encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -field_coding -prefilter RECTLP 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"inter_rectlp5_"$encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -field_coding -prefilter RECTLP 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"inter_rectlp5_"$encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:267: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:268: at_wrap dirac_decoder ../../\"inter_rectlp5_\"\$encout ../../\"inter_rectlp5_\"\$decout"
echo samples.at:268 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../\"inter_rectlp5_\"$encout ../../\"inter_rectlp5_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../"inter_rectlp5_"$encout ../../"inter_rectlp5_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../"inter_rectlp5_"$encout ../../"inter_rectlp5_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:268: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

#     pre-filter DIAGLP
$at_traceoff
echo "$at_srcdir/samples.at:270: at_wrap dirac_encoder -field_coding -prefilter DIAGLP 5 -local \$preset -width \$width -height \$height -cformat \$chroma  -xblen \$xblen -xbsep \$xbsep -yblen \$yblen -ybsep \$ybsep -mv_prec \$mv_prec \$extras \$samp ../../\"inter_diaglp5_\"\$encout"
echo samples.at:270 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_encoder -field_coding -prefilter DIAGLP 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../\"inter_diaglp5_\"$encout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_encoder -field_coding -prefilter DIAGLP 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"inter_diaglp5_"$encout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_encoder -field_coding -prefilter DIAGLP 5 -local $preset -width $width -height $height -cformat $chroma  -xblen $xblen -xbsep $xbsep -yblen $yblen -ybsep $ybsep -mv_prec $mv_prec $extras $samp ../../"inter_diaglp5_"$encout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:270: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

$at_traceoff
echo "$at_srcdir/samples.at:271: at_wrap dirac_decoder ../../\"inter_diaglp5_\"\$encout ../../\"inter_diaglp5_\"\$decout"
echo samples.at:271 >"$at_check_line_file"

at_trace_this=
if test -n "$at_traceon"; then
    case "at_wrap dirac_decoder ../../\"inter_diaglp5_\"$encout ../../\"inter_diaglp5_\"$decout" in
        *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)' ;;
 *) at_trace_this=yes ;;
    esac
fi

if test -n "$at_trace_this"; then
    ( $at_traceon; at_wrap dirac_decoder ../../"inter_diaglp5_"$encout ../../"inter_diaglp5_"$decout ) >"$at_stdout" 2>"$at_stder1"
    at_status=$?
    grep '^ *+' "$at_stder1" >&2
    grep -v '^ *+' "$at_stder1" >"$at_stderr"
else
    ( :; at_wrap dirac_decoder ../../"inter_diaglp5_"$encout ../../"inter_diaglp5_"$decout ) >"$at_stdout" 2>"$at_stderr"
    at_status=$?
fi

at_failed=false
$at_diff "$at_devnull" "$at_stderr" || at_failed=:
echo stdout:; cat "$at_stdout"
case $at_status in
   77) echo 77 > "$at_status_file"; exit 77;;
   0) ;;
   *) echo "$at_srcdir/samples.at:271: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then


  echo 1 > "$at_status_file"
  exit 1
fi

$at_traceon

done
      $at_traceoff
      $at_times_p && times >"$at_times_file"
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat "$at_status_file"`
    ;;


  * )
    echo "$as_me: no such test group: $at_group" >&2
    continue
    ;;
  esac

  # Be sure to come back to the suite directory, in particular
  # since below we might `rm' the group directory we are in currently.
  cd "$at_suite_dir"

  case $at_group in
    banner-*) ;;
    *)
      if test ! -f "$at_check_line_file"; then
	sed "s/^ */$as_me: warning: /" <<_ATEOF
	A failure happened in a test group before any test could be
	run. This means that test suite is improperly designed.  Please
	report this failure to <>.
_ATEOF
	echo "$at_setup_line" >"$at_check_line_file"
      fi
      at_group_count=`expr 1 + $at_group_count`
      $at_verbose $ECHO_N "$at_group. $at_setup_line: $ECHO_C"
      echo $ECHO_N "$at_group. $at_setup_line: $ECHO_C" >> "$at_group_log"
      case $at_xfail:$at_status in
	yes:0)
	    at_msg="UNEXPECTED PASS"
	    at_xpass_list="$at_xpass_list $at_group"
	    at_errexit=$at_errexit_p
	    ;;
	no:0)
	    at_msg="ok"
	    at_pass_list="$at_pass_list $at_group"
	    at_errexit=false
	    ;;
	*:77)
	    at_msg='skipped ('`cat "$at_check_line_file"`')'
	    at_skip_list="$at_skip_list $at_group"
	    at_errexit=false
	    ;;
	yes:*)
	    at_msg='expected failure ('`cat "$at_check_line_file"`')'
	    at_xfail_list="$at_xfail_list $at_group"
	    at_errexit=false
	    ;;
	no:*)
	    at_msg='FAILED ('`cat "$at_check_line_file"`')'
	    at_fail_list="$at_fail_list $at_group"
	    at_errexit=$at_errexit_p
	    ;;
      esac
      # Make sure there is a separator even with long titles.
      echo " $at_msg"
      at_log_msg="$at_group. $at_desc ($at_setup_line): $at_msg"
      case $at_status in
	0|77)
	  # $at_times_file is only available if the group succeeded.
	  # We're not including the group log, so the success message
	  # is written in the global log separately.  But we also
	  # write to the group log in case they're using -d.
	  if test -f "$at_times_file"; then
	    at_log_msg="$at_log_msg	("`sed 1d "$at_times_file"`')'
	    rm -f "$at_times_file"
          fi
	  echo "$at_log_msg" >> "$at_group_log"
	  echo "$at_log_msg" >&5

	  # Cleanup the group directory, unless the user wants the files.
	  if $at_debug_p ; then
	    	  {
	    echo "#! /bin/sh"
	    echo 'test "${ZSH_VERSION+set}" = set && alias -g '\''${1+"$@"}'\''='\''"$@"'\'''
	    echo "cd '$at_dir'"
	    echo 'exec ${CONFIG_SHELL-'"$SHELL"'}' "$0" \
	         '-v -d' "$at_debug_args" "$at_group" '${1+"$@"}'
	    echo 'exit 1'
	  } >$at_group_dir/run
	  chmod +x $at_group_dir/run

	  elif test -d "$at_group_dir"; then
	    find "$at_group_dir" -type d ! -perm -700 -exec chmod u+rwx \{\} \;
	    rm -fr "$at_group_dir"
	  fi
	  ;;
	*)
	  # Upon failure, include the log into the testsuite's global
	  # log.  The failure message is written in the group log.  It
	  # is later included in the global log.
	  echo "$at_log_msg" >> "$at_group_log"

	  # Upon failure, keep the group directory for autopsy, and
	  # create the debugging script.
	  	  {
	    echo "#! /bin/sh"
	    echo 'test "${ZSH_VERSION+set}" = set && alias -g '\''${1+"$@"}'\''='\''"$@"'\'''
	    echo "cd '$at_dir'"
	    echo 'exec ${CONFIG_SHELL-'"$SHELL"'}' "$0" \
	         '-v -d' "$at_debug_args" "$at_group" '${1+"$@"}'
	    echo 'exit 1'
	  } >$at_group_dir/run
	  chmod +x $at_group_dir/run

	  $at_errexit && break
	  ;;
      esac
      ;;
  esac
done

# Back to the top directory.
cd "$at_dir"

# Compute the duration of the suite.
at_stop_date=`date`
at_stop_time=`date +%s 2>/dev/null`
echo "$as_me: ending at: $at_stop_date" >&5
case $at_start_time,$at_stop_time in
  [0-9]*,[0-9]*)
    at_duration_s=`expr $at_stop_time - $at_start_time`
    at_duration_m=`expr $at_duration_s / 60`
    at_duration_h=`expr $at_duration_m / 60`
    at_duration_s=`expr $at_duration_s % 60`
    at_duration_m=`expr $at_duration_m % 60`
    at_duration="${at_duration_h}h ${at_duration_m}m ${at_duration_s}s"
    echo "$as_me: test suite duration: $at_duration" >&5
    ;;
esac

# Wrap up the test suite with summary statistics.
at_skip_count=`set dummy $at_skip_list; shift; echo $#`
at_fail_count=`set dummy $at_fail_list; shift; echo $#`
at_xpass_count=`set dummy $at_xpass_list; shift; echo $#`
at_xfail_count=`set dummy $at_xfail_list; shift; echo $#`

at_run_count=`expr $at_group_count - $at_skip_count`
at_unexpected_count=`expr $at_xpass_count + $at_fail_count`
at_total_fail_count=`expr $at_xfail_count + $at_fail_count`

echo
cat <<\_ASBOX
## ------------- ##
## Test results. ##
## ------------- ##
_ASBOX
echo
{
  echo
  cat <<\_ASBOX
## ------------- ##
## Test results. ##
## ------------- ##
_ASBOX
  echo
} >&5

if test $at_run_count = 1; then
  at_result="1 test"
  at_were=was
else
  at_result="$at_run_count tests"
  at_were=were
fi
if $at_errexit_p && test $at_unexpected_count != 0; then
  if test $at_xpass_count = 1; then
    at_result="$at_result $at_were run, one passed"
  else
    at_result="$at_result $at_were run, one failed"
  fi
  at_result="$at_result unexpectedly and inhibited subsequent tests."
else
  # Don't you just love exponential explosion of the number of cases?
  case $at_xpass_count:$at_fail_count:$at_xfail_count in
    # So far, so good.
    0:0:0) at_result="$at_result $at_were successful." ;;
    0:0:*) at_result="$at_result behaved as expected." ;;

    # Some unexpected failures
    0:*:0) at_result="$at_result $at_were run,
$at_fail_count failed unexpectedly." ;;

    # Some failures, both expected and unexpected
    0:*:1) at_result="$at_result $at_were run,
$at_total_fail_count failed ($at_xfail_count expected failure)." ;;
    0:*:*) at_result="$at_result $at_were run,
$at_total_fail_count failed ($at_xfail_count expected failures)." ;;

    # No unexpected failures, but some xpasses
    *:0:*) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly." ;;

    # No expected failures, but failures and xpasses
    *:1:0) at_result="$at_result $at_were run,
$at_unexpected_count did not behave as expected ($at_fail_count unexpected failure)." ;;
    *:*:0) at_result="$at_result $at_were run,
$at_unexpected_count did not behave as expected ($at_fail_count unexpected failures)." ;;

    # All of them.
    *:*:1) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly,
$at_total_fail_count failed ($at_xfail_count expected failure)." ;;
    *:*:*) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly,
$at_total_fail_count failed ($at_xfail_count expected failures)." ;;
  esac

  if test $at_skip_count = 0 && test $at_run_count -gt 1; then
    at_result="All $at_result"
  fi
fi

# Now put skips in the mix.
case $at_skip_count in
  0) ;;
  1) at_result="$at_result
1 test was skipped." ;;
  *) at_result="$at_result
$at_skip_count tests were skipped." ;;
esac

if test $at_unexpected_count = 0; then
  echo "$at_result"
  echo "$at_result" >&5
else
  echo "ERROR: $at_result" >&2
  echo "ERROR: $at_result" >&5
  {
    echo
    cat <<\_ASBOX
## ------------------------ ##
## Summary of the failures. ##
## ------------------------ ##
_ASBOX

    # Summary of failed and skipped tests.
    if test $at_fail_count != 0; then
      echo "Failed tests:"
      $SHELL "$0" $at_fail_list --list
      echo
    fi
    if test $at_skip_count != 0; then
      echo "Skipped tests:"
      $SHELL "$0" $at_skip_list --list
      echo
    fi
    if test $at_xpass_count != 0; then
      echo "Unexpected passes:"
      $SHELL "$0" $at_xpass_list --list
      echo
    fi
    if test $at_fail_count != 0; then
      cat <<\_ASBOX
## ---------------------- ##
## Detailed failed tests. ##
## ---------------------- ##
_ASBOX
      echo
      for at_group in $at_fail_list
      do
        at_group_normalized=$at_group

  while :; do
    case $at_group_normalized in #(
    $at_format*) break;;
    esac
    at_group_normalized=0$at_group_normalized
  done

        cat "$at_suite_dir/$at_group_normalized/$as_me.log"
        echo
      done
      echo
    fi
    if test -n "$at_top_srcdir"; then
      sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## ${at_top_build_prefix}config.log ##
_ASBOX
      sed 's/^/| /' ${at_top_build_prefix}config.log
      echo
    fi
  } >&5

  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $as_me.log was created. ##
_ASBOX

  echo
  echo "Please send \`${at_testdir+${at_testdir}/}$as_me.log' and all information you think might help:"
  echo
  echo "   To: <>"
  echo "   Subject: [] $as_me:$at_fail_list${at_fail_list:+ failed${at_xpass_list:+,}}$at_xpass_list${at_xpass_list:+ passed unexpectedly}"
  echo
  if test $at_debug_p = false; then
    echo
    echo 'You may investigate any problem if you feel able to do so, in which'
    echo 'case the test suite provides a good starting point.  Its output may'
    echo "be found below \`${at_testdir+${at_testdir}/}$as_me.dir'."
    echo
  fi
    exit 1
fi

exit 0



