diff -urN linux-2.6.x.old/Documentation/blackfin/kgdb_bfin.txt linux-2.6.x/Documentation/blackfin/kgdb_bfin.txt
--- linux-2.6.x.old/Documentation/blackfin/kgdb_bfin.txt	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.x/Documentation/blackfin/kgdb_bfin.txt	2005-09-16 13:18:47.703418040 +0800
@@ -0,0 +1,123 @@
+			A Simple Guide to Configure KGDB
+
+			Sonic Zhang(sonic.zhang@analog.com)
+				Apr. 13th 2005
+
+
+This KGDB patch enable the kernel developer to do source level debugging on kernel for the Blackfin architecture. The debugging works over the ethernet interface. Both software breakpoints and hardware breakpoints are supported in this porting.
+
+
+2 known issue:
+1. The bug "http://blackfin.uclinux.org/tracker/index.php?func=detail&aid=544&group_id=18&atid=145"
+in the GDB client for Blackfin uclinux causes error values of local variables are displayed when the user breaks the
+running of kernel in GDB.
+2. Because of one hardware bug "05000067 - Watchpoints (Hardware Breakpoints) are not supported" in Blackfin533
+v1.0.3, the hardware breakpoints can't be set. Then, the hardware breakpoints also can't hit.
+
+
+If you want to do source level debugging over Ethernet:
+ 
+1. Compile and install the cross platform version of gdb for blackfin, which can be found as $(BINROOT)/bfin-elf-gdb.
+
+2. Apply this patch to 2.6.x kernel. Select menuconfig option under "kernel hacking" -> "kernel debugging" -> "KGDB: kernel debug with remote gdb". With this seledted, option "Full Symbolic/Source Debugging support" and "Compile the kernel with frame pointers" are also selected.
+
+3. Select option "KGDB: on Ethernet". Add "kgdboe=@target-IP/,@host-IP/" to option "Kernel Boot Parameter" and compile.
+
+4. Connect minicom to the serial port and boot the kernel image.
+
+5. Configure the IP "/> ifconfig eth0 target-IP"
+
+6. Start GDB client "bfin-elf-gdb vmlinux".
+
+7. Connect to the target "(gdb) target remote udp:target-IP:6443".
+
+8. Set software breakpoint "(gdb) break sys_open".
+
+9. Continue "(gdb) c".
+
+10. Run ls in the target console "/> ls".
+
+11. Breakpoint hits. "Breakpoint 1: sys_open(..."
+
+12. Display local variables and function paramters. (*)This operation gives wrong results, see known issue 1.
+
+13. Single stepping "(gdb) si".
+
+14. Remove breakpoint 1. "(gdb) del 1"
+
+15. Set hardware breakpoint "(gdb) hbreak sys_open".
+
+16. Continue "(gdb) c".
+
+17. Run ls in the target console "/> ls".
+
+18. Hardware breakpoint hits. "Breakpoint 1: sys_open(...". (*)This hardware breakpoint won't hit, see known issue 2.
+
+19. Continue "(gdb) c".
+
+20. Interrupt the target in GDB "Ctrl+C".
+
+21. Detach from the target "(gdb) detach".
+
+22. Exit GDB "(gdb) quit".
+
+
+If you want to do source level debugging over UART and share this UART with console:
+
+1. Compile and install the cross platform version of gdb for blackfin, which can be found as $(BINROOT)/bfin-elf-gdb.
+
+2. Apply this patch to 2.6.x kernel. Select menuconfig option under "kernel hacking" -> "kernel debugging" -> "KGDB: kernel debug with remote gdb". With this seledted, option "Full Symbolic/Source Debugging support" and "Compile the kernel with frame pointers" are also selected.
+
+3. Select option "KGDB: on Blackfin UART". Set "KGDB: UART port number". Don't forget to change the mode of blackfin serial driver to PIO. Or else, kgdb works incorrectly on UART.
+ 
+4. Enable "KGDB: Wait for gdb connection early" if you want connect to kgdb when kernel booting. Then, compile.
+
+5. Connect minicom to the serial port and boot the kernel image. 
+
+6. (Optional) Ask target to wait for gdb connection by entering Ctrl+A. In minicom, you should enter Ctrl+A+A.
+
+7. Start GDB client "bfin-elf-gdb vmlinux".
+
+8. Set the baud rate in GDB "(gdb) set remotebaud 57600".
+
+9. Connect to the target "(gdb) target remote /dev/ttyS0".
+
+10. Set software breakpoint "(gdb) break sys_open".
+
+11. Continue "(gdb) c". Then enter Ctrl+C twice to stop GDB connection.
+
+12. Run ls in the target console "/> ls". Dummy string can be seen on the console.
+
+13. Then connect the gdb to target again. "(gdb) target remote /dev/ttyS0". Now you will find a breakpoint is hit. "Breakpoint 1: sys_open(..."
+
+14. All other operations are the same as that in KGDB over Ethernet. The only difference is that after continue command in GDB, please stop GDB connection by 2 "Ctrl+C"s and connect again after breakpoints are hit or Ctrl+A is entered.
+
+
+If you want to do source level debugging over UART and use a different UART from the console:
+
+1. Compile and install the cross platform version of gdb for blackfin, which can be found as $(BINROOT)/bfin-elf-gdb.
+
+2. Apply this patch to 2.6.x kernel. Select menuconfig option under "kernel hacking" -> "kernel debugging" -> "KGDB: kernel debug with remote gdb". With this seledted, option "Full Symbolic/Source Debugging support" and "Compile the kernel with frame pointers" are also selected.
+
+3. Select option "KGDB: on Blackfin UART". Set "KGDB: UART port number" to be a different one from the console. Don't forget to change the mode of blackfin serial driver to PIO. Or else, kgdb works incorrectly on UART.
+ 
+4. Enable "KGDB: Wait for gdb connection early" if you want connect to kgdb when kernel booting. Then, compile.
+
+5. Connect minicom to the serial port of the console and boot the kernel image.
+
+6. Start GDB client "bfin-elf-gdb vmlinux".
+
+7. Set the baud rate in GDB "(gdb) set remotebaud 57600".
+
+8. Connect to the target "(gdb) target remote /dev/ttyS1".
+
+9. Set software breakpoint "(gdb) break sys_open".
+
+10. Continue "(gdb) c". 
+
+11. Run ls in the target console "/> ls". 
+
+12. A breakpoint is hit. "Breakpoint 1: sys_open(..."
+
+13. All other operations are the same as that in KGDB over Ethernet. 
+
diff -urN linux-2.6.x.old/arch/bfinnommu/Kconfig linux-2.6.x/arch/bfinnommu/Kconfig
--- linux-2.6.x.old/arch/bfinnommu/Kconfig	2005-09-16 13:17:59.967674976 +0800
+++ linux-2.6.x/arch/bfinnommu/Kconfig	2005-09-16 13:18:47.729414088 +0800
@@ -624,6 +624,8 @@
 	  allocation as well as poisoning memory on free to catch use of freed
 	  memory.
 
+source "kernel/Kconfig.kgdb"
+
 config FRAME_POINTER
 	bool "Compile the kernel with frame pointers"
 	help
diff -urN linux-2.6.x.old/arch/bfinnommu/Makefile linux-2.6.x/arch/bfinnommu/Makefile
--- linux-2.6.x.old/arch/bfinnommu/Makefile	2005-09-16 13:17:59.620727720 +0800
+++ linux-2.6.x/arch/bfinnommu/Makefile	2005-09-16 13:18:47.760409376 +0800
@@ -18,7 +18,7 @@
 
 
 ifeq ($(CONFIG_FRAME_POINTER),y)
-CFLAGS		+=-fno-omit-frame-pointer -mapcs -mno-sched-prolog
+CFLAGS		+=-fno-omit-frame-pointer 
 endif
 
 comma = ,
diff -urN linux-2.6.x.old/arch/bfinnommu/kernel/Makefile linux-2.6.x/arch/bfinnommu/kernel/Makefile
--- linux-2.6.x.old/arch/bfinnommu/kernel/Makefile	2005-09-16 13:17:59.637725136 +0800
+++ linux-2.6.x/arch/bfinnommu/kernel/Makefile	2005-09-16 13:18:47.780406336 +0800
@@ -8,4 +8,6 @@
 obj-$(CONFIG_MODULES)		+= module.o
 obj-$(CONFIG_BLKFIN_DMA)	+= dma.o
 obj-$(CONFIG_BLKFIN_SIMPLE_DMA)	+= simple_dma.o
+obj-$(CONFIG_KGDB)		+= kgdb.o
+obj-$(CONFIG_KGDB_TEST)		+= kgdb_test.o
 
diff -urN linux-2.6.x.old/arch/bfinnommu/kernel/kgdb.c linux-2.6.x/arch/bfinnommu/kernel/kgdb.c
--- linux-2.6.x.old/arch/bfinnommu/kernel/kgdb.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.x/arch/bfinnommu/kernel/kgdb.c	2005-09-16 13:18:47.788405120 +0800
@@ -0,0 +1,435 @@
+/*
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <asm/system.h>
+#include <asm/ptrace.h>		/* for linux pt_regs struct */
+#include <linux/kgdb.h>
+#ifdef CONFIG_GDB_CONSOLE
+#include <linux/console.h>
+#endif
+#include <linux/init.h>
+#include <linux/debugger.h>
+#include <linux/errno.h>
+#include <asm/irq.h>
+#include <asm/traps.h>
+#include <asm/blackfin.h>
+
+/* Put the error code here just in case the user cares.  */
+int gdb_bf533errcode;
+/* Likewise, the vector number here (since GDB only gets the signal
+   number through the usual means, and that's not very specific).  */
+int gdb_bf533vector = -1;
+
+#if KGDB_MAX_NO_CPUS != 8
+#error change the definition of slavecpulocks
+#endif
+
+void regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs)
+{
+	gdb_regs[BFIN_SYSCFG] = regs->syscfg;
+	gdb_regs[BFIN_R0] = regs->r0;
+	gdb_regs[BFIN_R1] = regs->r1;
+	gdb_regs[BFIN_R2] = regs->r2;
+	gdb_regs[BFIN_R3] = regs->r3;
+	gdb_regs[BFIN_R4] = regs->r4;
+	gdb_regs[BFIN_R5] = regs->r5;
+	gdb_regs[BFIN_R6] = regs->r6;
+	gdb_regs[BFIN_R7] = regs->r7;
+	gdb_regs[BFIN_P0] = regs->p0;
+	gdb_regs[BFIN_P1] = regs->p1;
+	gdb_regs[BFIN_P2] = regs->p2;
+	gdb_regs[BFIN_P3] = regs->p3;
+	gdb_regs[BFIN_P4] = regs->p4;
+	gdb_regs[BFIN_P5] = regs->p5;
+	gdb_regs[BFIN_FP] = regs->fp;
+	if(regs->ipend>1)
+		gdb_regs[BFIN_SP] = regs->reserved;
+	else
+		gdb_regs[BFIN_SP] = regs->usp;
+	gdb_regs[BFIN_I0] = regs->i0;
+	gdb_regs[BFIN_I1] = regs->i1;
+	gdb_regs[BFIN_I2] = regs->i2;
+	gdb_regs[BFIN_I3] = regs->i3;
+	gdb_regs[BFIN_M0] = regs->m0;
+	gdb_regs[BFIN_M1] = regs->m1;
+	gdb_regs[BFIN_M2] = regs->m2;
+	gdb_regs[BFIN_M3] = regs->m3;
+	gdb_regs[BFIN_L0] = regs->l0;
+	gdb_regs[BFIN_L1] = regs->l1;
+	gdb_regs[BFIN_L2] = regs->l2;
+	gdb_regs[BFIN_L3] = regs->l3;
+	gdb_regs[BFIN_B0] = regs->b0;
+	gdb_regs[BFIN_B1] = regs->b1;
+	gdb_regs[BFIN_B2] = regs->b2;
+	gdb_regs[BFIN_B3] = regs->b3;
+	gdb_regs[BFIN_A0_DOT_X] = regs->a0x;
+	gdb_regs[BFIN_AO_DOT_W] = regs->a0w;
+	gdb_regs[BFIN_A1_DOT_X] = regs->a1x;
+	gdb_regs[BFIN_A1_DOT_W] = regs->a1w;
+	gdb_regs[BFIN_LC0] = regs->lc0;
+	gdb_regs[BFIN_LC1] = regs->lc1;
+	gdb_regs[BFIN_LT0] = regs->lt0;
+	gdb_regs[BFIN_LT1] = regs->lt1;
+	gdb_regs[BFIN_LB0] = regs->lb0;
+	gdb_regs[BFIN_LB1] = regs->lb1;
+	gdb_regs[BFIN_ASTAT] = regs->astat;
+	gdb_regs[BFIN_RETS] = regs->rets;
+	gdb_regs[BFIN_PC] = regs->pc;
+	gdb_regs[BFIN_RETX] = regs->retx;
+	gdb_regs[BFIN_RETN] = regs->retn;
+	gdb_regs[BFIN_RETE] = regs->rete;
+	gdb_regs[BFIN_SEQSTAT] = regs->seqstat;
+	gdb_regs[BFIN_IPEND] = regs->ipend;
+	gdb_regs[BFIN_ORIGPC] = regs->orig_pc;
+	gdb_regs[BFIN_EXTRA1] = 0;
+	gdb_regs[BFIN_EXTRA2] = 0;
+	gdb_regs[BFIN_EXTRA3] = 0;
+}
+
+/*
+ * Extracts ebp, esp and eip values understandable by gdb from the values
+ * saved by switch_to.
+ * thread.esp points to ebp. flags and ebp are pushed in switch_to hence esp
+ * prior to entering switch_to is 8 greater then the value that is saved.
+ * If switch_to changes, change following code appropriately.
+ */
+void sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p)
+{
+	gdb_regs[BFIN_SP] = p->thread.ksp;
+	gdb_regs[BFIN_PC] = p->thread.pc;
+	gdb_regs[BFIN_SEQSTAT] = p->thread.seqstat;
+
+}
+
+void gdb_regs_to_regs(unsigned long *gdb_regs, struct pt_regs *regs)
+{
+	regs->syscfg = gdb_regs[BFIN_SYSCFG];
+	regs->r0 = gdb_regs[BFIN_R0];
+	regs->r1 = gdb_regs[BFIN_R1];
+	regs->r2 = gdb_regs[BFIN_R2];
+	regs->r3 = gdb_regs[BFIN_R3];
+	regs->r4 = gdb_regs[BFIN_R4];
+	regs->r5 = gdb_regs[BFIN_R5];
+	regs->r6 = gdb_regs[BFIN_R6];
+	regs->r7 = gdb_regs[BFIN_R7];
+	regs->p0 = gdb_regs[BFIN_P0];
+	regs->p1 = gdb_regs[BFIN_P1];
+	regs->p2 = gdb_regs[BFIN_P2];
+	regs->p3 = gdb_regs[BFIN_P3];
+	regs->p4 = gdb_regs[BFIN_P4];
+	regs->p5 = gdb_regs[BFIN_P5];
+	regs->fp = gdb_regs[BFIN_FP];
+	regs->i0 = gdb_regs[BFIN_I0];
+	regs->i1 = gdb_regs[BFIN_I1];
+	regs->i2 = gdb_regs[BFIN_I2];
+	regs->i3 = gdb_regs[BFIN_I3];
+	regs->m0 = gdb_regs[BFIN_M0];
+	regs->m1 = gdb_regs[BFIN_M1];
+	regs->m2 = gdb_regs[BFIN_M2];
+	regs->m3 = gdb_regs[BFIN_M3];
+	regs->l0 = gdb_regs[BFIN_L0];
+	regs->l1 = gdb_regs[BFIN_L1];
+	regs->l2 = gdb_regs[BFIN_L2];
+	regs->l3 = gdb_regs[BFIN_L3];
+	regs->b0 = gdb_regs[BFIN_B0];
+	regs->b1 = gdb_regs[BFIN_B1];
+	regs->b2 = gdb_regs[BFIN_B2];
+	regs->b3 = gdb_regs[BFIN_B3];
+	regs->a0x = gdb_regs[BFIN_A0_DOT_X];
+	regs->a0w = gdb_regs[BFIN_AO_DOT_W];
+	regs->a1x = gdb_regs[BFIN_A1_DOT_X];
+	regs->a1w = gdb_regs[BFIN_A1_DOT_W];
+	regs->lc0 = gdb_regs[BFIN_LC0];
+	regs->lc1 = gdb_regs[BFIN_LC1];
+	regs->lt0 = gdb_regs[BFIN_LT0];
+	regs->lt1 = gdb_regs[BFIN_LT1];
+	regs->lb0 = gdb_regs[BFIN_LB0];
+	regs->lb1 = gdb_regs[BFIN_LB1];
+	regs->rets = gdb_regs[BFIN_RETS];
+	regs->pc = gdb_regs[BFIN_PC];
+	regs->retx = gdb_regs[BFIN_RETX];
+	regs->retn = gdb_regs[BFIN_RETN];
+	regs->rete = gdb_regs[BFIN_RETE];
+	
+#if 0				/* can't change these */
+	regs->usp = gdb_regs[BFIN_SP];
+	regs->astat = gdb_regs[BFIN_ASTAT];
+	regs->seqstat = gdb_regs[BFIN_SEQSTAT];
+	regs->ipend = gdb_regs[BFIN_IPEND];
+	regs->orig_pc = gdb_regs[BFIN_ORIGPC];
+#endif
+}
+
+struct hw_breakpoint {
+	unsigned int occupied:1;
+	unsigned int skip:1;
+	unsigned int enabled:1;
+	unsigned int type:1;
+	unsigned int dataacc:2;
+	unsigned short count;
+	unsigned int addr;
+} breakinfo[HW_BREAKPOINT_NUM];
+
+int kgdb_arch_init(void)
+{
+	kgdb_remove_all_hw_break();
+	return 0;
+}
+
+int kgdb_set_hw_break(unsigned long addr)
+{
+	int breakno;
+	for(breakno=0;breakno<HW_BREAKPOINT_NUM;breakno++)
+		if(!breakinfo[breakno].occupied) {
+			breakinfo[breakno].occupied = 1;
+			breakinfo[breakno].enabled = 1;
+			breakinfo[breakno].type = 1;
+			breakinfo[breakno].addr = addr;
+			return 0;
+		}
+
+	return -ENOSPC;
+}
+
+int kgdb_remove_hw_break(unsigned long addr)
+{
+	int breakno;
+	for(breakno=0;breakno<HW_BREAKPOINT_NUM;breakno++)
+		if(breakinfo[breakno].addr == addr)
+			memset(&(breakinfo[breakno]), 0, sizeof(struct hw_breakpoint));
+
+	return 0;
+}
+
+void kgdb_remove_all_hw_break(void)
+{
+	memset(breakinfo, 0, sizeof(struct hw_breakpoint)*8);
+}
+/*
+void kgdb_show_info(void)
+{
+	int a0, ac0, actl, stat;
+	__asm__ volatile ("%0 = [%1];" :"=&d"(a0): "a"(WPIA0));
+	__asm__ volatile ("%0 = [%1];" :"=&d"(ac0): "a"(WPIACNT0));
+	__asm__ volatile ("%0 = [%1];" :"=&d"(actl): "a"(WPIACTL));
+	__asm__ volatile ("%0 = [%1];" :"=&d"(stat): "a"(WPSTAT));
+	printk("hwd: wpia0=0x%x, wpiacnt0=%d, wpiactl=0x%x, wpstat=0x%x\n", a0, ac0, actl, stat);
+}
+*/
+void kgdb_correct_hw_break(void)
+{
+	int breakno;
+	int correctit;
+	unsigned int wpdactl;
+
+	__asm__ volatile ("%0 = [%1];":"=&d"(wpdactl):"p"(WPDACTL));
+
+	correctit = 0;
+	for (breakno = 0; breakno < HW_BREAKPOINT_NUM; breakno++) {
+		if(breakinfo[breakno].type == 1) {
+			switch (breakno) {
+			case 0:
+				if(breakinfo[breakno].enabled && !(wpdactl&WPIAEN0)) {
+					correctit = 1;
+					wpdactl &= ~(WPIREN01|EMUSW0);
+					wpdactl |= WPIAEN0|WPICNTEN0;
+					__asm__ volatile (
+						"[%0] = %1;"
+						"[%2] = %3;"
+						::"p"(WPIA0), "d"(breakinfo[breakno].addr),
+						"p"(WPIACNT0), "d"(breakinfo[breakno].skip));
+				} else if (!breakinfo[breakno].enabled && (wpdactl&WPIAEN0)) {
+					correctit = 1;
+					wpdactl &= ~WPIAEN0;
+				}
+				break;
+
+			case 1:
+				if(breakinfo[breakno].enabled && !(wpdactl&WPIAEN1)) {
+					correctit = 1;
+					wpdactl &= ~(WPIREN01|EMUSW1);
+					wpdactl |= WPIAEN1|WPICNTEN1;
+					__asm__ volatile (
+						"[%0] = %1;"
+						"[%2] = %3;"
+						::"p"(WPIA1), "d"(breakinfo[breakno].addr),
+						"p"(WPIACNT1), "d"(breakinfo[breakno].skip));
+				} else if (!breakinfo[breakno].enabled && (wpdactl&WPIAEN1)) {
+					correctit = 1;
+					wpdactl &= ~WPIAEN1;
+				}
+				break;
+
+			case 2:
+				if(breakinfo[breakno].enabled && !(wpdactl&WPIAEN2)) {
+					correctit = 1;
+					wpdactl &= ~(WPIREN23|EMUSW2);
+					wpdactl |= WPIAEN2|WPICNTEN2;
+					__asm__ volatile (
+						"[%0] = %1;"
+						"[%2] = %3;"
+						::"p"(WPIA2), "d"(breakinfo[breakno].addr),
+						"p"(WPIACNT2), "d"(breakinfo[breakno].skip));
+				} else if (!breakinfo[breakno].enabled && (wpdactl&WPIAEN2)) {
+					correctit = 1;
+					wpdactl &= ~WPIAEN2;
+				}
+				break;
+
+			case 3:
+				if(breakinfo[breakno].enabled && !(wpdactl&WPIAEN3)) {
+					correctit = 1;
+					wpdactl &= ~(WPIREN23|EMUSW3);
+					wpdactl |= WPIAEN3|WPICNTEN3;
+					__asm__ volatile (
+						"[%0] = %1;"
+						"[%2] = %3;"
+						::"p"(WPIA3), "d"(breakinfo[breakno].addr),
+						"p"(WPIACNT3), "d"(breakinfo[breakno].skip));
+				} else if (!breakinfo[breakno].enabled && (wpdactl&WPIAEN3)) {
+					correctit = 1;
+					wpdactl &= ~WPIAEN3;
+				}
+				break;
+			case 4:
+				if(breakinfo[breakno].enabled && !(wpdactl&WPIAEN4)) {
+					correctit = 1;
+					wpdactl &= ~(WPIREN45|EMUSW4);
+					wpdactl |= WPIAEN4|WPICNTEN4;
+					__asm__ volatile (
+						"[%0] = %1;"
+						"[%2] = %3;"
+						::"p"(WPIA4), "d"(breakinfo[breakno].addr),
+						"p"(WPIACNT4), "d"(breakinfo[breakno].skip));
+				} else if (!breakinfo[breakno].enabled && (wpdactl&WPIAEN4)) {
+					correctit = 1;
+					wpdactl &= ~WPIAEN4;
+				}
+				break;
+			case 5:
+				if(breakinfo[breakno].enabled && !(wpdactl&WPIAEN5)) {
+					correctit = 1;
+					wpdactl &= ~(WPIREN45|EMUSW5);
+					wpdactl |= WPIAEN5|WPICNTEN5;
+					__asm__ volatile (
+						"[%0] = %1;"
+						"[%2] = %3;"
+						::"p"(WPIA5), "d"(breakinfo[breakno].addr),
+						"p"(WPIACNT5), "d"(breakinfo[breakno].skip));
+				} else if (!breakinfo[breakno].enabled && (wpdactl&WPIAEN5)) {
+					correctit = 1;
+					wpdactl &= ~WPIAEN5;
+				}
+				break;
+			}
+		}
+	}
+	if (correctit) {
+		wpdactl &= ~WPAND;
+		wpdactl |= WPPWR;
+/*printk("correct_hw_break: wpdactl=0x%x\n", wpdactl);*/
+		__asm__ volatile (
+			"[%0] = %1;"
+			"csync;"
+			::"a"(WPIACTL), "d"(wpdactl));
+/*		kgdb_show_info();*/
+	}
+}
+
+void kgdb_disable_hw_debug(struct pt_regs *regs)
+{
+	/* Disable hardware debugging while we are in kgdb */
+	__asm__ volatile (
+		"r0 = [%0];"
+		"bitclr (r0, 0);"
+		"[%0] = r0;"
+		"csync;"
+		: : "a"(WPIACTL) : "R0");
+}
+
+void kgdb_post_master_code(struct pt_regs *regs, int eVector, int err_code)
+{
+	/* Master processor is completely in the debugger */
+	gdb_bf533vector = eVector;
+	gdb_bf533errcode = err_code;
+}
+
+int kgdb_arch_handle_exception(int exceptionVector, int signo,
+			       int err_code, char *remcom_in_buffer,
+			       char *remcom_out_buffer,
+			       struct pt_regs *linux_regs)
+{
+	long addr;
+	long breakno;
+	char *ptr;
+	int newPC;
+	int wp_status;
+
+	switch (remcom_in_buffer[0]) {
+	case 'c':
+	case 's':
+		if (kgdb_contthread && kgdb_contthread != current) {
+			strcpy(remcom_out_buffer, "E00");
+			break;
+		}
+
+		kgdb_contthread = NULL;
+
+		/* try to read optional parameter, pc unchanged if no parm */
+		ptr = &remcom_in_buffer[1];
+		if (kgdb_hex2long(&ptr, &addr)) {
+			linux_regs->pc = addr;
+		}
+		newPC = linux_regs->pc;
+
+		/* clear the trace bit */
+		linux_regs->syscfg &= 0xfffffffe;
+
+		/* set the trace bit if we're stepping */
+		if (remcom_in_buffer[0] == 's') {
+			linux_regs->syscfg |= 0x1;
+			debugger_step = 1;
+		}
+
+		__asm__ volatile (
+			"%0 = [%1];"
+			"csync;"
+			: "=r" (wp_status) : "a"(WPSTAT));
+
+ 		if (exceptionVector == VEC_WATCH) {
+			for (breakno = 0; breakno < 6; ++breakno) {
+				if (wp_status & (1 << breakno)) {
+					breakinfo->skip = 1;
+					break;
+				}
+			}
+		}
+		kgdb_correct_hw_break();
+		__asm__ volatile ("[%0] = %1;" : :"a"(WPSTAT), "d"(0));
+
+		return (0);
+	}			/* switch */
+	return -1;		/* this means that we do not want to exit from the handler */
+}
+
+struct kgdb_arch arch_kgdb_ops = {
+	.gdb_bpt_instr = {0xa1},
+	.flags = KGDB_HW_BREAKPOINT,
+};
diff -urN linux-2.6.x.old/arch/bfinnommu/kernel/kgdb_test.c linux-2.6.x/arch/bfinnommu/kernel/kgdb_test.c
--- linux-2.6.x.old/arch/bfinnommu/kernel/kgdb_test.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.x/arch/bfinnommu/kernel/kgdb_test.c	2005-09-16 13:18:47.788405120 +0800
@@ -0,0 +1,84 @@
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+
+#include <asm/current.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+#include <asm/blackfin.h>
+
+
+static char cmdline[256];
+static unsigned long len;
+
+int kgdb_test(char *name, int len, int count,int z)
+{
+	printk("kgdb name(%d): %s, %d, %d\n",len, name, count, z); 
+	count = z;
+	return count;
+}
+
+static int test_proc_output (char *buf)
+{
+	kgdb_test("hello world!", 12, 0x55, 0x10);
+	return 0;
+}
+
+static int test_read_proc(char *page, char **start, off_t off,
+                         int count, int *eof, void *data)
+{
+	int len;
+        
+	len = test_proc_output (page);
+        if (len <= off+count) *eof = 1;
+        *start = page + off;
+        len -= off;
+        if (len>count) len = count;
+        if (len<0) len = 0;
+        return len;
+}
+
+static int test_write_proc(struct file *file, const char *buffer,
+			   unsigned long count, void *data)
+{
+	if(count>=256)
+		len = 255;
+	else
+		len = count;
+	
+	memcpy(cmdline, buffer, count);
+	cmdline[len] = 0;
+		
+        return len;
+}
+
+
+static int __init cplbtest_init(void)
+{
+	struct proc_dir_entry *entry;
+
+	if ((entry=create_proc_entry ("kgdbtest", 0, NULL)) == NULL) {
+		return -ENOMEM;
+	}
+	
+	entry->read_proc = test_read_proc;
+	entry->write_proc = test_write_proc;
+	entry->data = NULL;
+
+	return 0;
+}
+
+
+static void __exit cplbtest_exit (void)
+{
+	remove_proc_entry ("kgdbtest", NULL);
+}
+
+module_init(cplbtest_init);
+module_exit(cplbtest_exit);
+
diff -urN linux-2.6.x.old/arch/bfinnommu/kernel/setup.c linux-2.6.x/arch/bfinnommu/kernel/setup.c
--- linux-2.6.x.old/arch/bfinnommu/kernel/setup.c	2005-09-16 13:17:59.729711152 +0800
+++ linux-2.6.x/arch/bfinnommu/kernel/setup.c	2005-09-16 13:18:47.798403600 +0800
@@ -293,7 +293,11 @@
 	pos = fill_cpl_tables(dcplb_table, pos, ZERO, SIZE_4M, SIZE_4M, SDRAM_DKERNEL);
 	pos = fill_cpl_tables(dcplb_table, pos, RAM_END - SIZE_4M, RAM_END - SIZE_1M, SIZE_1M, SDRAM_DGENERIC);
 	pos = fill_cpl_tables(dcplb_table, pos, RAM_END - SIZE_1M, RAM_END, SIZE_1M, SDRAM_DNON_CHBL);
+#if defined(CONFIG_KGDB_ETH)&&(!defined(CONFIG_BFIN_MAC))
+	pos = fill_cpl_tables(dcplb_table, pos, ASYNC_BANK3_BASE, ASYNC_BANK3_BASE + ASYNC_BANK3_SIZE, ASYNC_BANK3_SIZE, SDRAM_EBIU|CPLB_LOCK);
+#else
 	pos = fill_cpl_tables(dcplb_table, pos, ASYNC_BANK3_BASE, ASYNC_BANK3_BASE + ASYNC_BANK3_SIZE, ASYNC_BANK3_SIZE, SDRAM_EBIU);
+#endif
 	pos = fill_cpl_tables(dcplb_table, pos, SIZE_4M, SIZE_4M+(dcplb_avail * SIZE_4M) , SIZE_4M, SDRAM_DGENERIC);
 	while (pos < 32)                                                   
 			pos = fill_cpl_tables(dcplb_table, pos, 0, 1 , SIZE_4M, 0);
@@ -305,7 +309,12 @@
 	pos = fill_cpl_tables(dpdt_table, pos, SIZE_4M, RAM_END - SIZE_4M, SIZE_4M, SDRAM_DGENERIC);
 	pos = fill_cpl_tables(dpdt_table, pos, RAM_END - SIZE_4M, RAM_END - SIZE_1M, SIZE_1M, SDRAM_DGENERIC);
 	pos = fill_cpl_tables(dpdt_table, pos, RAM_END - SIZE_1M, RAM_END, SIZE_1M, SDRAM_DNON_CHBL);
-	pos = fill_cpl_tables(dpdt_table, pos, ASYNC_BANK0_BASE, ASYNC_BANK3_BASE + ASYNC_BANK3_SIZE, ASYNC_BANK0_SIZE, SDRAM_EBIU);
+	pos = fill_cpl_tables(dpdt_table, pos, ASYNC_BANK0_BASE, ASYNC_BANK2_BASE + ASYNC_BANK2_SIZE, ASYNC_BANK0_SIZE, SDRAM_EBIU);
+#if defined(CONFIG_KGDB_ETH)&&(!defined(CONFIG_BFIN_MAC))
+	pos = fill_cpl_tables(dpdt_table, pos, ASYNC_BANK3_BASE, ASYNC_BANK3_BASE + ASYNC_BANK3_SIZE, ASYNC_BANK3_SIZE, SDRAM_EBIU|CPLB_LOCK);
+#else
+	pos = fill_cpl_tables(dpdt_table, pos, ASYNC_BANK3_BASE, ASYNC_BANK3_BASE + ASYNC_BANK3_SIZE, ASYNC_BANK3_SIZE, SDRAM_EBIU);
+#endif
 	pos = fill_cpl_tables(dpdt_table, pos, L1_DATA_A_START, L1_DATA_A_START + L1_DATA_A_LENGTH, SIZE_4K, L1_DMEMORY);
 #if !defined(CONFIG_BF531) 
 	pos = fill_cpl_tables(dpdt_table, pos, L1_DATA_B_START, L1_DATA_B_START + L1_DATA_B_LENGTH, SIZE_4K, L1_DMEMORY);
diff -urN linux-2.6.x.old/arch/bfinnommu/kernel/traps.c linux-2.6.x/arch/bfinnommu/kernel/traps.c
--- linux-2.6.x.old/arch/bfinnommu/kernel/traps.c	2005-09-16 13:17:59.740709480 +0800
+++ linux-2.6.x/arch/bfinnommu/kernel/traps.c	2005-09-16 13:19:52.590553696 +0800
@@ -18,6 +18,7 @@
 #include <asm/uaccess.h>
 #include <asm/traps.h>
 #include <asm/blackfin.h>
+#include <linux/debugger.h>
 #include <linux/interrupt.h>
 /*
 . EXCEPTION TRAPS DEBUGGING LEVELS
@@ -76,25 +77,45 @@
 {
 	int sig = 0;
 	siginfo_t info;
+	unsigned long trapnr = fp->seqstat & 0x3f;
 
  	/* trap_c() will be called for exceptions. During exceptions
  	   processing, the pc value should be set with retx value.  
  	   With this change we can cleanup some code in signal.c- TODO */
  	fp->orig_pc = fp->retx;
+/*	printk("exception: 0x%x\n", trapnr);*/
 
 	/* send the appropriate signal to the user program */
-	switch (fp->seqstat & 0x3f) {
+	switch (trapnr) {
 	    case VEC_STEP:
 		info.si_code = TRAP_STEP;
 		fp->pc = fp->retx;      /* gdb wants the value of the pc*/
 		sig = SIGTRAP;
+#ifdef CONFIG_KGDB
+		CHK_DEBUGGER(trapnr,SIGTRAP,info.si_code,fp,)
+		return;
+#else
 		break;
+#endif
 	    case VEC_EXCPT01 :		 /* gdb breakpoint */
 		info.si_code = TRAP_ILLTRAP;
 		fp->retx -=2;		/* For Service, proessor increments to next instruction. */
 		fp->pc = fp->retx;      /* gdb wants the value of the pc*/
 		sig = SIGTRAP;
+#ifdef CONFIG_KGDB
+		CHK_DEBUGGER(trapnr,SIGTRAP,info.si_code,fp,)
+		return;
+#else
 		break;
+#endif
+#ifdef CONFIG_KGDB
+	    case VEC_EXCPT02 :		 /* gdb connection */
+		info.si_code = TRAP_ILLTRAP;
+		fp->pc = fp->retx;      /* gdb wants the value of the pc*/
+		sig = SIGTRAP;
+		CHK_DEBUGGER(trapnr,SIGTRAP,info.si_code,fp,)
+		return;
+#endif
 	    case VEC_EXCPT04:		/* Atomic test and set service */
 		panic ("Exception 4");
 		goto nsig;
@@ -102,6 +123,9 @@
 		info.si_code = ILL_ILLOPC;
 		sig = SIGILL;
 		DPRINTK(EXC_0x21);
+#ifdef CONFIG_KGDB
+		CHK_DEBUGGER(trapnr,sig,info.si_code,fp,);
+#endif
 		break;
 	    case VEC_OVFLOW:
 		info.si_code = TRAP_TRACEFLOW;
@@ -112,6 +136,9 @@
 		info.si_code = ILL_ILLPARAOP;
 		sig = SIGILL;
 		DPRINTK(EXC_0x22);
+#ifdef CONFIG_KGDB
+		CHK_DEBUGGER(trapnr,sig,info.si_code,fp,);
+#endif
 		break;
 	    case VEC_ILL_RES:
 		info.si_code = ILL_PRVOPC;
@@ -123,23 +150,37 @@
 		sig = SIGBUS;
 		DPRINTK(EXC_0x24);
 		DPRINTK("DCPLB_FAULT_ADDR=%p\n", *pDCPLB_FAULT_ADDR);
+#ifdef CONFIG_KGDB
+		CHK_DEBUGGER(trapnr,sig,info.si_code,fp,);
+#endif
 	    	break;
 	    case VEC_MISALI_I:
 		info.si_code = BUS_ADRALN;
 		sig = SIGBUS;
 		DPRINTK(EXC_0x2A);
 		DPRINTK("ICPLB_FAULT_ADDR=%p\n", *pICPLB_FAULT_ADDR);
+#ifdef CONFIG_KGDB
+		CHK_DEBUGGER(trapnr,sig,info.si_code,fp,);
+#endif
 		break;
 	    case VEC_UNCOV:
 		info.si_code = ILL_ILLEXCPT;
 		sig = SIGILL;
 		DPRINTK(EXC_0x25);
+#ifdef CONFIG_KGDB
+		CHK_DEBUGGER(trapnr,sig,info.si_code,fp,);
+#endif
 		break;
 	    case VEC_WATCH:
 		info.si_code = TRAP_WATCHPT;
 		sig = SIGTRAP;
 		DPRINTK3(EXC_0x28);
+#ifdef CONFIG_KGDB
+		CHK_DEBUGGER(trapnr,sig,info.si_code,fp,)
+		return;
+#else
 		break;
+#endif
 	    case VEC_ISTRU_VL:                /* ADSP-BF535 only (MH)*/
 		info.si_code = BUS_OPFETCH;
 		sig = SIGBUS;
@@ -147,14 +188,13 @@
 	    case VEC_CPLB_I_VL:
 		DPRINTK2(EXC_0x2B);
 		DPRINTK2("ICPLB_FAULT_ADDR: %p\n", *pICPLB_FAULT_ADDR);
+		break;
 	    case VEC_CPLB_VL:
 		info.si_code = ILL_CPLB_VI;
 		DPRINTK3(EXC_0x23);
 		DPRINTK3("DCPLB_FAULT_ADDR=%p\n", *pDCPLB_FAULT_ADDR);
 		_cplb_hdr();
 		goto nsig;
-		sig = SIGILL;
-                break;
 	    case VEC_CPLB_I_M:
 		DPRINTK3(EXC_0x2C);
 		DPRINTK3("ICPLB_FAULT_ADDR=%p\n", *pICPLB_FAULT_ADDR);
@@ -180,6 +220,10 @@
 	    default:
 		info.si_code = TRAP_ILLTRAP;
 		sig = SIGTRAP;
+#ifdef CONFIG_KGDB
+		CHK_DEBUGGER(trapnr,sig,info.si_code,fp,);
+		return;
+#endif
 		break;
 	}
 	info.si_signo = sig;
diff -urN linux-2.6.x.old/arch/bfinnommu/mach-common/ints-priority-sc.c linux-2.6.x/arch/bfinnommu/mach-common/ints-priority-sc.c
--- linux-2.6.x.old/arch/bfinnommu/mach-common/ints-priority-sc.c	2005-09-16 13:17:59.959676192 +0800
+++ linux-2.6.x/arch/bfinnommu/mach-common/ints-priority-sc.c	2005-09-16 13:18:47.810401776 +0800
@@ -25,6 +25,9 @@
 #include <linux/module.h>
 #include <linux/kernel_stat.h>
 #include <linux/seq_file.h>
+#ifdef CONFIG_KGDB
+#include <linux/kgdb.h>
+#endif
 #include <asm/irqchip.h>
 #include <asm/traps.h>
 #include <asm/blackfin.h>
@@ -462,4 +465,8 @@
 	  vec = ivg->irqno;
 
 	asm_do_IRQ(vec, fp);
+
+#ifdef CONFIG_KGDB
+	kgdb_process_breakpoint();
+#endif
 }
diff -urN linux-2.6.x.old/drivers/net/Makefile linux-2.6.x/drivers/net/Makefile
--- linux-2.6.x.old/drivers/net/Makefile	2005-09-16 13:18:14.336490584 +0800
+++ linux-2.6.x/drivers/net/Makefile	2005-09-16 13:18:47.828399040 +0800
@@ -196,3 +196,4 @@
 obj-$(CONFIG_ETRAX_ETHERNET) += cris/
 
 obj-$(CONFIG_NETCONSOLE) += netconsole.o
+obj-$(CONFIG_KGDB_ETH) += kgdb_eth.o
diff -urN linux-2.6.x.old/drivers/net/kgdb_eth.c linux-2.6.x/drivers/net/kgdb_eth.c
--- linux-2.6.x.old/drivers/net/kgdb_eth.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.x/drivers/net/kgdb_eth.c	2005-09-16 13:18:47.829398888 +0800
@@ -0,0 +1,160 @@
+/*
+ * drivers/net/kgdb_eth.c
+ *
+ * A network interface for GDB.
+ * Based upon 'gdbserial' by David Grothe <dave@gcom.com>
+ * and Scott Foehner <sfoehner@engr.sgi.com>
+ *
+ * Maintainers: Amit S. Kale <amitkale@emsyssoft.com> and
+ * 		Tom Rini <trini@kernel.crashing.org>
+ *
+ * 2004 (c) Amit S. Kale <amitkale@emsyssoft.com>
+ * 2004 (c) MontaVista Software, Inc.
+ *
+ * Other folks:
+ * San Mehat <nettwerk@biodome.org>
+ * Robert Walsh <rjwalsh@durables.org>
+ * wangdi <wangdi@clusterfs.com>.
+ * Matt Mackall <mpm@selenic.com>
+ * Pavel Machek <pavel@suse.cz>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/kgdb.h>
+#include <linux/netpoll.h>
+#include <linux/init.h>
+#include <linux/inetdevice.h>
+#include <linux/rtnetlink.h>
+
+#include <asm/atomic.h>
+#include <asm/irq.h>
+
+#define IN_BUF_SIZE 512		/* power of 2, please */
+#define OUT_BUF_SIZE 30		/* We don't want to send too big of a packet. */
+
+static char in_buf[IN_BUF_SIZE], out_buf[OUT_BUF_SIZE];
+static int in_head, in_tail, out_count;
+static atomic_t in_count;
+static int configured;
+
+static void rx_hook(struct netpoll *np, int port, char *msg, int len);
+
+static struct netpoll np = {
+	.name = "kgdboe",
+	.dev_name = "eth0",
+	.rx_hook = rx_hook,
+	.local_port = 6443,
+	.remote_port = 6442,
+	.remote_mac = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
+};
+
+static int eth_getDebugChar(void)
+{
+	int chr;
+
+	while (atomic_read(&in_count) == 0)
+		netpoll_poll(&np);
+
+	chr = in_buf[in_tail++];
+	in_tail &= (IN_BUF_SIZE - 1);
+	atomic_dec(&in_count);
+	return chr;
+}
+
+static void eth_flushDebugChar(void)
+{
+	if (out_count && np.dev) {
+		netpoll_send_udp(&np, out_buf, out_count);
+/*out_buf[out_count]=0;
+printk("gdb_anw: %s\n", out_buf);*/
+		memset(out_buf, 0, sizeof(out_buf));
+		out_count = 0;
+	}
+}
+
+static void eth_putDebugChar(int chr)
+{
+	out_buf[out_count++] = chr;
+	if (out_count == OUT_BUF_SIZE) {
+		eth_flushDebugChar();
+	}
+}
+
+static void rx_hook(struct netpoll *np, int port, char *msg, int len)
+{
+	int i;
+/*	int ksp,usp;*/
+
+	np->remote_port = port;
+
+	/* Is this gdb trying to attach? */
+	if (!kgdb_connected && msg[0]=='$' && len==8) {
+		if(strncmp(msg, "$Hc-1#09", 8)==0) {
+			kgdb_schedule_breakpoint();
+		}
+	}
+
+/*	__asm__("%0 = SP;":"=d"(ksp)::"R0");
+	__asm__("%0 = USP;":"=d"(usp)::"R1");
+	printk("gdb_cmd(ksp=0x%x,usp=0x%x): ", ksp, usp);*/
+	for (i = 0; i < len; i++) {
+		if (msg[i] == 3) {
+			kgdb_schedule_breakpoint();
+		}
+
+		if (atomic_read(&in_count) >= IN_BUF_SIZE) {
+			/* buffer overflow, clear it */
+			in_head = in_tail = 0;
+			atomic_set(&in_count, 0);
+			break;
+		}
+		in_buf[in_head++] = msg[i];
+		in_head &= (IN_BUF_SIZE - 1);
+		atomic_inc(&in_count);
+/*		printk("%c", msg[i]);*/
+	}
+/*	printk("\n");*/
+}
+
+/* We must be passed configuration options. */
+static int option_setup(char *opt)
+{
+	configured = !netpoll_parse_options(&np, opt);
+	return 0;
+}
+__setup("kgdboe=", option_setup);
+
+static int hook(void)
+{
+	/* We haven't been configured, giveup. */
+	if (!configured)
+		return 1;
+
+	return 0;
+}
+
+struct kgdb_serial kgdbeth_serial = {
+	.read_char = eth_getDebugChar,
+	.write_char = eth_putDebugChar,
+	.hook = hook,
+	.flush = eth_flushDebugChar,
+};
+
+int init_kgdboe(void)
+{
+	if (!configured || netpoll_setup(&np))
+		return 1;
+
+	if (!kgdb_serial)
+		kgdb_serial = &kgdbeth_serial;
+	printk(KERN_INFO "kgdb: debugging over ethernet enabled\n");
+
+	return 0;
+}
+module_init(init_kgdboe);
diff -urN linux-2.6.x.old/drivers/serial/Makefile linux-2.6.x/drivers/serial/Makefile
--- linux-2.6.x.old/drivers/serial/Makefile	2005-09-16 13:18:22.082313040 +0800
+++ linux-2.6.x/drivers/serial/Makefile	2005-09-16 13:18:47.839397368 +0800
@@ -53,3 +53,4 @@
 obj-$(CONFIG_SERIAL_VR41XX) += vr41xx_siu.o
 obj-$(CONFIG_BLK_DEV_SGIIOC4) += ioc4_serial.o
 obj-$(CONFIG_SERIAL_BLACKFIN) += bf533_serial.o
+obj-$(CONFIG_KGDB_BLACKFIN_UART) += kgdb_bfin_uart.o
diff -urN linux-2.6.x.old/drivers/serial/bf533_serial.c linux-2.6.x/drivers/serial/bf533_serial.c
--- linux-2.6.x.old/drivers/serial/bf533_serial.c	2005-09-16 13:18:22.116307872 +0800
+++ linux-2.6.x/drivers/serial/bf533_serial.c	2005-09-16 13:18:47.854395088 +0800
@@ -445,6 +445,48 @@
 }
 #endif
 
+#ifdef CONFIG_KGDB_BLACKFIN_UART
+extern void kgdb_breakkey_pressed(struct pt_regs *regs);
+extern void init_kgdb_blackfin_uart(void);
+ 
+void kgdb_put_debug_char(char chr)
+{
+	struct uart_registers *uart_regs;
+	
+	if(CONFIG_KGDB_UART_PORT<0 || CONFIG_KGDB_UART_PORT>=NR_PORTS)
+		uart_regs = &(bfin_uart[0].regs);
+	else
+		uart_regs = &(bfin_uart[CONFIG_KGDB_UART_PORT].regs);
+	
+	while (!(*(uart_regs->rpUART_LSR) & THRE)) {
+		CSYNC;
+	}
+	ACCESS_PORT_IER(uart_regs)
+	*(uart_regs->rpUART_THR) = chr;
+	CSYNC;
+}
+
+int kgdb_get_debug_char(void)
+{
+	struct uart_registers *uart_regs;
+	unsigned char chr;
+
+	if(CONFIG_KGDB_UART_PORT<0 || CONFIG_KGDB_UART_PORT>=NR_PORTS)
+		uart_regs = &(bfin_uart[0].regs);
+	else
+		uart_regs = &(bfin_uart[CONFIG_KGDB_UART_PORT].regs);
+	
+	while(!(*(uart_regs->rpUART_LSR) & DR)) {
+		CSYNC;
+	}
+	ACCESS_PORT_IER(uart_regs)
+	chr = *(uart_regs->rpUART_RBR);
+	CSYNC;
+
+	return chr;
+}
+#endif
+
 void receive_chars(struct bfin_serial *info, struct pt_regs *regs)
 {
 	struct uart_registers *uart_regs = &(info->regs);
@@ -475,6 +517,13 @@
 				machine_restart(NULL);
 				return;
 			}
+#ifdef CONFIG_KGDB_BLACKFIN_UART
+			else if(ch == 0x1) { /* Ctrl + A */
+				kgdb_breakkey_pressed(regs);
+				continue;
+			}
+#endif
+
 			/* It is a 'keyboard interrupt' ;-) */
 #ifdef CONFIG_CONSOLE
 			wake_up(&keypress_wait);
@@ -1970,6 +2019,9 @@
 	bfin_config_uart1(&bfin_uart[1]);
 #endif
 	register_console(&bfin_driver);
+#ifdef CONFIG_KGDB_BLACKFIN_UART
+	init_kgdb_blackfin_uart();
+#endif
 	return 0;
 }
 
diff -urN linux-2.6.x.old/drivers/serial/kgdb_bfin_uart.c linux-2.6.x/drivers/serial/kgdb_bfin_uart.c
--- linux-2.6.x.old/drivers/serial/kgdb_bfin_uart.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.x/drivers/serial/kgdb_bfin_uart.c	2005-09-16 13:18:47.855394936 +0800
@@ -0,0 +1,71 @@
+/*
+ * uart interface for kgdb.
+ *
+ * Sonic Zhang <sonic.zhang@citiz.net>
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/kgdb.h>
+
+static struct kgdb_serial kgdb_uart_driver;
+static int initialized;
+
+/*
+ * Wait until the interface can accept a char, then write it.
+ */
+extern void kgdb_put_debug_char(int chr);
+extern int kgdb_get_debug_char(void);
+
+void kgdb_print(const char *fmt, ...)
+{
+	va_list args;
+	char *p;
+	static char printk_buf[1024];
+
+	va_start(args, fmt);
+	vscnprintf(printk_buf, sizeof(printk_buf), fmt, args);
+	va_end(args);
+	
+	for (p = printk_buf; *p; p++) {
+		kgdb_put_debug_char(*p);
+	}
+}
+
+void kgdb_breakkey_pressed(struct pt_regs *regs) 
+{
+	if(initialized)
+		kgdb_schedule_breakpoint();
+}
+
+static int
+kgdb_hook_io(void)
+{
+	/* If we've already been initialized, return. */
+	if (initialized)
+		return 0;
+	
+	initialized = 1;
+
+	return 0;
+}
+
+static struct kgdb_serial kgdb_uart_driver = {
+	.read_char = kgdb_get_debug_char,
+	.write_char = kgdb_put_debug_char,
+	.hook = kgdb_hook_io,
+	.flush = NULL,
+};
+
+void init_kgdb_blackfin_uart(void)
+{
+	kgdb_serial = &kgdb_uart_driver;
+	kgdb_print("Init kgdb uart on blackfin.\n");
+	initialized = 1;
+
+#ifdef CONFIG_KGDB_WAIT_IN_BOOT
+	/* Break in as soon as we can. */
+	kgdb_schedule_breakpoint();
+#endif
+}
diff -urN linux-2.6.x.old/include/asm-bfinnommu/entry.h linux-2.6.x/include/asm-bfinnommu/entry.h
--- linux-2.6.x.old/include/asm-bfinnommu/entry.h	2005-09-16 13:18:28.619319264 +0800
+++ linux-2.6.x/include/asm-bfinnommu/entry.h	2005-09-16 13:18:47.855394936 +0800
@@ -71,6 +71,13 @@
 
 	[--sp] = ASTAT;
 
+#ifdef CONFIG_KGDB
+	fp     = 0(Z);
+	R0     = sp;
+	R0    += 60;
+	R0    += 60;
+	R0    += 60;
+#endif
 	[--sp] = r0;	/* Skip reserved */
 	[--sp] = RETS;
 	r0 = RETI;
@@ -79,6 +86,16 @@
 	[--sp] = RETN;
 	[--sp] = RETE;
 	[--sp] = SEQSTAT;
+#ifdef CONFIG_KGDB
+	r0.l   = lo(IPEND);
+	r0.h   = 0;
+	BITCLR (R0, 4);
+	BITCLR (R0, 3);
+	BITCLR (R0, 2);
+	BITCLR (R0, 1);
+	BITCLR (R0, 0);
+	r0.l   = ONES r0;
+#endif
 	[--sp] = r0;	/* Skip IPEND as well. */
 	[--sp] = RETI;  /*orig_pc*/
 	/* Clear all L registers.  */
@@ -130,6 +147,13 @@
 
 	[--sp] = ASTAT;
 
+#ifdef CONFIG_KGDB
+	fp     = 0(Z);
+	R0     = sp;
+	R0    += 60;
+	R0    += 60;
+	R0    += 60;
+#endif
 	[--sp] = r0;	/* Skip reserved */
 	[--sp] = RETS;
 	r0 = RETI;
@@ -138,6 +162,16 @@
 	[--sp] = RETN;
 	[--sp] = RETE;
 	[--sp] = SEQSTAT;
+#ifdef CONFIG_KGDB
+	r0.l   = lo(IPEND);
+	r0.h   = 0;
+	BITCLR (R0, 4);
+	BITCLR (R0, 3);
+	BITCLR (R0, 2);
+	BITCLR (R0, 1);
+	BITCLR (R0, 0);
+	r0.l   = ONES r0;
+#endif
 	[--sp] = r0;	/* Skip IPEND as well. */
 	[--sp] = r0;  /*orig_pc*/
 	/* Clear all L registers.  */
diff -urN linux-2.6.x.old/include/asm-bfinnommu/kgdb.h linux-2.6.x/include/asm-bfinnommu/kgdb.h
--- linux-2.6.x.old/include/asm-bfinnommu/kgdb.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.x/include/asm-bfinnommu/kgdb.h	2005-09-16 13:18:47.856394784 +0800
@@ -0,0 +1,139 @@
+#ifndef _ASM_KGDB_H_
+#define _ASM_KGDB_H_
+
+#include <linux/ptrace.h>
+
+/* gdb locks */
+#define KGDB_MAX_NO_CPUS 8
+
+/************************************************************************/
+/* BUFMAX defines the maximum number of characters in inbound/outbound buffers*/
+/* at least NUMREGBYTES*2 are needed for register packets */
+/* Longer buffer is needed to list all threads */
+#define BUFMAX 2048
+
+/* Number of bytes of registers.  */
+#define NUMREGBYTES 224
+/*
+ *  Note that this register image is different from
+ *  the register image that Linux produces at interrupt time.
+ *  
+ *  Linux's register image is defined by struct pt_regs in ptrace.h.
+ */
+enum regnames {
+  BFIN_SYSCFG = 0,
+  //BFIN_ORIGR0, 
+  BFIN_R0,
+  BFIN_R1,
+  BFIN_R2,
+  BFIN_R3,
+  BFIN_R4,
+  BFIN_R5,
+  BFIN_R6,
+  BFIN_R7,
+  BFIN_P0,
+  BFIN_P1,
+  BFIN_P2,
+  BFIN_P3,
+  BFIN_P4,
+  BFIN_P5,
+  BFIN_FP,
+  BFIN_SP,
+  BFIN_I0,
+  BFIN_I1,
+  BFIN_I2,
+  BFIN_I3,
+  BFIN_M0,
+  BFIN_M1,
+  BFIN_M2,
+  BFIN_M3,
+  BFIN_L0,
+  BFIN_L1,
+  BFIN_L2,
+  BFIN_L3,
+  BFIN_B0,
+  BFIN_B1,         /* START MODIFIER REGISTER */
+  BFIN_B2,         /* END MODIFIER REGISTER */
+  BFIN_B3,
+  BFIN_A0_DOT_X,
+  BFIN_AO_DOT_W,
+  BFIN_A1_DOT_X,
+  BFIN_A1_DOT_W,
+  BFIN_LC0,
+  BFIN_LC1,
+  BFIN_LT0,
+  BFIN_LT1,
+  BFIN_LB0,
+  BFIN_LB1,
+  BFIN_ASTAT,
+  BFIN_RESERVED,
+  BFIN_RETS, 	/* Subroutine address register */
+  BFIN_PC, 	/*actually RETI pc will be in ORIG_PC*/
+  BFIN_RETX,
+  BFIN_RETN,
+  BFIN_RETE,
+  BFIN_SEQSTAT,
+  BFIN_IPEND,        /* Subroutine address register */  
+  BFIN_ORIGPC,        /* Subroutine address register */  
+  BFIN_EXTRA1,        /* Extra "registers" for hacks 1. address of .text */
+  BFIN_EXTRA2,        
+  BFIN_EXTRA3
+};
+
+#define BREAKPOINT() asm("   EXCPT 2;");
+#define BREAK_INSTR_SIZE       2
+#define HW_BREAKPOINT_NUM		6
+
+/* Instruction watchpoint address control register bits mask */
+#define WPPWR		0x1
+#define WPIREN01	0x2
+#define WPIRINV01	0x4
+#define WPIAEN0		0x8
+#define WPIAEN1		0x10
+#define WPICNTEN0	0x20
+#define WPICNTEN1	0x40
+#define EMUSW0		0x80
+#define EMUSW1		0x100
+#define WPIREN23	0x200
+#define WPIRINV23	0x400
+#define WPIAEN2		0x800
+#define WPIAEN3		0x1000
+#define WPICNTEN2	0x2000
+#define WPICNTEN3	0x4000
+#define EMUSW2		0x8000
+#define EMUSW3		0x10000
+#define WPIREN45	0x20000
+#define WPIRINV45	0x40000
+#define WPIAEN4		0x80000
+#define WPIAEN5		0x100000
+#define WPICNTEN4	0x200000
+#define WPICNTEN5	0x400000
+#define EMUSW4		0x800000
+#define EMUSW5		0x1000000
+#define WPAND		0x2000000
+
+/* Data watchpoint address control register bits mask */
+#define WPDREN01	0x1
+#define WPDRINV01	0x2
+#define WPDAEN0		0x4
+#define WPDAEN1		0x8
+#define WPDCNTEN0	0x10
+#define WPDCNTEN1	0x20
+#define WPDSRC0		0xc0
+#define WPDACC0		0x300
+#define WPDSRC1		0xc00
+#define WPDACC1		0x3000
+
+/* Watchpoint status register bits mask */
+#define STATIA0		0x1
+#define STATIA1		0x2
+#define STATIA2		0x4
+#define STATIA3		0x8
+#define STATIA4		0x10
+#define STATIA5		0x20
+#define STATDA0		0x40
+#define STATDA1		0x80
+
+extern void kgdb_print(const char *fmt, ...);
+
+#endif				/* _ASM_KGDB_H_ */
diff -urN linux-2.6.x.old/include/asm-bfinnommu/processor.h linux-2.6.x/include/asm-bfinnommu/processor.h
--- linux-2.6.x.old/include/asm-bfinnommu/processor.h	2005-09-16 13:18:28.621318960 +0800
+++ linux-2.6.x/include/asm-bfinnommu/processor.h	2005-09-16 13:18:47.856394784 +0800
@@ -34,6 +34,7 @@
 	unsigned short seqstat;		/* saved status register */
 	unsigned long  esp0;		/* points to SR of stack frame pt_regs*/
 	unsigned long  pc;		/* instruction pointer */
+	void *         debuggerinfo;
 };
 
 #define INIT_THREAD  {						\
diff -urN linux-2.6.x.old/include/linux/debugger.h linux-2.6.x/include/linux/debugger.h
--- linux-2.6.x.old/include/linux/debugger.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.x/include/linux/debugger.h	2005-09-16 13:18:47.856394784 +0800
@@ -0,0 +1,59 @@
+#ifndef _DEBUGGER_H_
+#define _DEBUGGER_H_
+
+/*
+ * Copyright (C) 2003-2004 Amit S. Kale
+ *
+ * Definition switchout for debuggers
+ */
+
+/*
+ * KGDB
+ */
+#ifdef CONFIG_KGDB
+
+typedef int gdb_debug_hook(int exVector, int signo, int err_code,
+			   struct pt_regs *regs);
+extern gdb_debug_hook *linux_debug_hook;
+#define CHK_DEBUGGER(trapnr,signr,error_code,regs,after)			\
+    {									\
+	if (linux_debug_hook != (gdb_debug_hook *) NULL && !user_mode(regs)) \
+	{								\
+		(*linux_debug_hook)(trapnr, signr, error_code, regs) ;	\
+		after;							\
+	}								\
+    }
+
+void kgdb_nmihook(int cpu, void *regs);
+static inline void debugger_nmihook(int cpu, void *regs)
+{
+	kgdb_nmihook(cpu, regs);
+}
+
+extern int debugger_step;
+extern atomic_t debugger_active;
+
+/*
+ * No debugger in the kernel
+ */
+#else
+
+#define CHK_DEBUGGER(trapnr,signr,error_code,regs,after)	\
+{									\
+	if (0)								\
+		after;							\
+}
+
+static inline void debugger_nmihook(int cpu, void *regs)
+{
+	/* Do nothing */
+}
+
+#define debugger_step 0
+static const atomic_t debugger_active = { 0 };
+
+#define debugger_memerr_expected 0
+
+#endif
+
+#endif				/* _DEBUGGER_H_ */
diff -urN linux-2.6.x.old/include/linux/kgdb.h linux-2.6.x/include/linux/kgdb.h
--- linux-2.6.x.old/include/linux/kgdb.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.x/include/linux/kgdb.h	2005-09-16 13:18:47.857394632 +0800
@@ -0,0 +1,180 @@
+#ifndef _KGDB_H_
+#define _KGDB_H_
+
+/*
+ * Copyright (C) 2001-2004 Amit S. Kale
+ */
+
+#include <linux/ptrace.h>
+#include <asm/kgdb.h>
+#include <linux/spinlock.h>
+#include <asm/atomic.h>
+#include <linux/debugger.h>
+
+/*
+ * This file should not include ANY others.  This makes it usable
+ * most anywhere without the fear of include order or inclusion.
+ * TODO: Make it so!
+ *
+ * This file may be included all the time.  It is only active if
+ * CONFIG_KGDB is defined, otherwise it stubs out all the macros
+ * and entry points.
+ */
+
+#if defined(CONFIG_KGDB) && !defined(__ASSEMBLY__)
+/* To enter the debugger explicitly. */
+extern void breakpoint(void);
+extern void kgdb_schedule_breakpoint(void);
+extern void kgdb_process_breakpoint(void);
+extern volatile int kgdb_connected;
+
+extern atomic_t kgdb_setting_breakpoint;
+
+extern struct task_struct *kgdb_usethread, *kgdb_contthread;
+
+enum kgdb_bptype {
+	bp_breakpoint = '0',
+	bp_hardware_breakpoint,
+	bp_write_watchpoint,
+	bp_read_watchpoint,
+	bp_access_watchpoint
+};
+
+enum kgdb_bpstate {
+	bp_disabled,
+	bp_enabled
+};
+
+struct kgdb_bkpt {
+	unsigned long bpt_addr;
+	unsigned char saved_instr[BREAK_INSTR_SIZE];
+	enum kgdb_bptype type;
+	enum kgdb_bpstate state;
+};
+
+#ifndef BREAK_INSTR_SIZE
+#error BREAK_INSTR_SIZE  needed by kgdb
+#endif
+
+#ifndef MAX_BREAKPOINTS
+#define MAX_BREAKPOINTS        16
+#endif
+
+#define KGDB_HW_BREAKPOINT          1
+
+/* Required functions. */
+/**
+ *	regs_to_gdb_regs - Convert ptrace regs to GDB regs
+ *	@gdb_regs: A pointer to hold the registers in the order GDB wants.
+ *	@regs: The &struct pt_regs of the current process.
+ *
+ *	Convert the pt_regs in @regs into the format for registers that
+ *	GDB expects, stored in @gdb_regs.
+ */
+extern void regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs);
+
+/**
+ *	sleeping_regs_to_gdb_regs - Convert ptrace regs to GDB regs
+ *	@gdb_regs: A pointer to hold the registers in the order GDB wants.
+ *	@p: The &struct task_struct of the desired process.
+ *
+ *	Convert the register values of the sleeping process in @p to
+ *	the format that GDB expects.
+ *	This function is called when kgdb does not have access to the
+ *	&struct pt_regs and therefore it should fill the gdb registers
+ *	@gdb_regs with what has	been saved in &struct thread_struct
+ *	thread field during switch_to.
+ */
+extern void sleeping_thread_to_gdb_regs(unsigned long *gdb_regs,
+					struct task_struct *p);
+
+/**
+ *	gdb_regs_to_regs - Convert GDB regs to ptrace regs.
+ *	@gdb_regs: A pointer to hold the registers we've recieved from GDB.
+ *	@regs: A pointer to a &struct pt_regs to hold these values in.
+ *
+ *	Convert the GDB regs in @gdb_regs into the pt_regs, and store them
+ *	in @regs.
+ */
+extern void gdb_regs_to_regs(unsigned long *gdb_regs, struct pt_regs *regs);
+
+/**
+ *	kgdb_arch_handle_exception - Handle architecture specific GDB packets.
+ *	@vector: The error vector of the exception that happened.
+ *	@signo: The signal number of the exception that happened.
+ *	@err_code: The error code of the exception that happened.
+ *	@InBuffer: The buffer of the packet we have read.
+ *	@outBuffer: The buffer, of %BUFMAX to write a packet into.
+ *	@regs: The &struct pt_regs of the current process.
+ *
+ *	This function MUST handle the 'c' and 's' command packets,
+ *	as well packets to set / remove a hardware breakpoint, if used.
+ *	If there are additional packets which the hardware needs to handle,
+ *	they are handled here.  The code should return -1 if it wants to
+ *	process more packets, and a %0 or %1 if it wants to exit from the
+ *	kgdb hook.
+ */
+extern int kgdb_arch_handle_exception(int vector, int signo, int err_code,
+				      char *InBuffer, char *outBuffer,
+				      struct pt_regs *regs);
+
+/* Optional functions. */
+extern int kgdb_arch_init(void);
+extern void kgdb_disable_hw_debug(struct pt_regs *regs);
+extern void kgdb_post_master_code(struct pt_regs *regs, int eVector,
+				  int err_code);
+extern int kgdb_set_hw_break(unsigned long addr);
+extern int kgdb_remove_hw_break(unsigned long addr);
+extern void kgdb_remove_all_hw_break(void);
+extern void kgdb_correct_hw_break(void);
+extern void kgdb_shadowinfo(struct pt_regs *regs, char *buffer,
+			    unsigned threadid);
+extern struct task_struct *kgdb_get_shadow_thread(struct pt_regs *regs,
+						  int threadid);
+extern struct pt_regs *kgdb_shadow_regs(struct pt_regs *regs, int threadid);
+
+/**
+ * struct kgdb_arch - Desribe architecture specific values.
+ * @gdb_bpt_instr: The instruction to trigger a breakpoint.
+ * @flags: Flags for the breakpoint, currently just %KGDB_HW_BREAKPOINT.
+ * @shadowth: A value of %1 indicates we shadow information on processes.
+ *
+ * The @shadowth flag is an option to shadow information not retrievable by
+ * gdb otherwise.  This is deprecated in favor of a binutils which supports
+ * CFI macros.
+ */
+struct kgdb_arch {
+	unsigned char gdb_bpt_instr[BREAK_INSTR_SIZE];
+	unsigned long flags;
+	unsigned shadowth;
+};
+
+/* Thread reference */
+typedef unsigned char threadref[8];
+
+/* Interface stuff. */
+struct kgdb_serial {
+	int (*read_char) (void);
+	void (*write_char) (int);
+	void (*flush) (void);
+	int (*hook) (void);
+};
+
+extern struct kgdb_serial *kgdb_serial;
+extern struct kgdb_arch arch_kgdb_ops;
+extern int kgdb_initialized;
+
+struct uart_port;
+
+extern void kgdb8250_add_port(int i, struct uart_port *serial_req);
+extern int init_kgdboe(void);
+
+int kgdb_hex2long(char **ptr, long *longValue);
+char *kgdb_mem2hex(char *mem, char *buf, int count);
+char *kgdb_hex2mem(char *buf, char *mem, int count);
+int kgdb_get_mem(char *addr, unsigned char *buf, int count);
+
+#else
+#define kgdb_process_breakpoint()      do {} while(0)
+#endif /* KGDB && !__ASSEMBLY__ */
+#endif				/* _KGDB_H_ */
diff -urN linux-2.6.x.old/kernel/Kconfig.kgdb linux-2.6.x/kernel/Kconfig.kgdb
--- linux-2.6.x.old/kernel/Kconfig.kgdb	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.x/kernel/Kconfig.kgdb	2005-09-16 13:18:47.861394024 +0800
@@ -0,0 +1,66 @@
+config KGDB
+	bool "KGDB: kernel debugging with remote gdb"
+	depends on DEBUG_KERNEL
+	select DEBUG_INFO
+	select FRAME_POINTER
+	help
+	  If you say Y here, it will be possible to remotely debug the
+	  kernel using gdb. This enlarges your kernel image disk size by
+	  several megabytes and requires a machine with more than 128 MB
+	  RAM to avoid excessive linking time. 
+	  Documentation of kernel debugger available at
+	  http://kgdb.sourceforge.net
+	  This is only useful for kernel hackers. If unsure, say N.
+ 
+config KGDB_CONSOLE
+	bool "KGDB: Console messages through gdb"
+	depends on KGDB
+	help
+	  If you say Y here, console messages will appear through gdb.
+	  Other consoles such as tty or ttyS will continue to work as usual.
+	  Note, that if you use this in conjunction with KGDB_ETH, if the
+	  ethernet driver runs into an error condition during use with KGDB
+	  it is possible to hit an infinite recusrion, causing the kernel
+	  to crash, and typically reboot.  For this reason, it is preferable
+	  to use NETCONSOLE in conjunction with KGDB_ETH instead of
+	  KGDB_CONSOLE.
+
+config KGDB_ETH
+	bool "KGDB: Over Ethernet"
+	depends on KGDB
+	select NETPOLL
+	select NETPOLL_TRAP
+	select NETPOLL_RX
+	help
+	  Uses ethernet interface in kgdb.
+
+config KGDB_BLACKFIN_UART
+	depends on KGDB
+	bool "KGDB: Over blackfin UART"
+	help
+	  Uses UART in kgdb. 
+
+config KGDB_UART_PORT
+	depends on KGDB_BLACKFIN_UART
+	int "KGDB: uart port number"
+	default "0"
+	help
+	  Set the kgdb uart port number 
+
+config KGDB_WAIT_IN_BOOT
+	depends on KGDB_BLACKFIN_UART
+	bool "KGDB: Wait for gdb connection early"
+	help
+	  Wait for gdb connection early in kernel boot.
+
+config DEBUG_INFO
+	bool "KGDB: Add -g flag into Makefile"
+	depends on KGDB
+	select FULLDEBUG
+	help
+	  Add debug infomation into the kernel image.
+
+config KGDB_TEST
+	bool "KGDB: test"
+	depends on KGDB
+	help
diff -urN linux-2.6.x.old/kernel/Makefile linux-2.6.x/kernel/Makefile
--- linux-2.6.x.old/kernel/Makefile	2005-09-16 13:18:34.385442680 +0800
+++ linux-2.6.x/kernel/Makefile	2005-09-16 13:18:47.871392504 +0800
@@ -28,6 +28,7 @@
 obj-$(CONFIG_SYSFS) += ksysfs.o
 obj-$(CONFIG_GENERIC_HARDIRQS) += irq/
 obj-$(CONFIG_SECCOMP) += seccomp.o
+obj-$(CONFIG_KGDB) += kgdb.o
 
 ifneq ($(CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
diff -urN linux-2.6.x.old/kernel/kgdb.c linux-2.6.x/kernel/kgdb.c
--- linux-2.6.x.old/kernel/kgdb.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.x/kernel/kgdb.c	2005-09-16 13:18:47.894389008 +0800
@@ -0,0 +1,1351 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+/*
+ * Copyright (C) 2000-2001 VERITAS Software Corporation.
+ * Copyright (C) 2002-2004 Timesys Corporation
+ * Copyright (C) 2003-2004 Amit S. Kale
+ * Copyright (C) 2004 Pavel Machek <pavel@suse.cz>
+ * Copyright (C) 2004 Tom Rini <trini@kernel.crashing.org>
+ *
+ * Restructured KGDB for 2.6 kernels.
+ * thread support, support for multiple processors,support for ia-32(x86) 
+ * hardware debugging, Console support, handling nmi watchdog
+ * - Amit S. Kale ( amitkale@emsyssoft.com )
+ *
+ * Several enhancements by George Anzinger <george@mvista.com>
+ * Generic KGDB Support
+ * Implemented by Anurekh Saxena (anurekh.saxena@timesys.com)
+ * 
+ * Contributor:     Lake Stevens Instrument Division
+ * Written by:      Glenn Engel
+ *  
+ * Modified for 386 by Jim Kingdon, Cygnus Support.
+ * Origianl kgdb, compatibility with 2.1.xx kernel by David Grothe <dave@gcom.com>
+ * Integrated into 2.2.5 kernel by Tigran Aivazian <tigran@sco.com>
+ */
+
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/mm.h>
+#include <linux/threads.h>
+#include <asm/system.h>
+#include <asm/ptrace.h>
+#include <asm/uaccess.h>
+#include <linux/kgdb.h>
+#include <asm/atomic.h>
+#include <linux/notifier.h>
+#include <linux/module.h>
+#include <asm/cacheflush.h>
+#include <linux/init.h>
+#include <linux/netpoll.h>
+#ifdef CONFIG_KGDB_CONSOLE
+#include <linux/console.h>
+#endif
+
+extern int pid_max;
+
+#define BUF_THREAD_ID_SIZE 16
+
+/*
+ * kgdb_initialized indicates that kgdb is setup and is all ready to serve
+ * breakpoints and other kernel exceptions. kgdb_connected indicates that kgdb
+ * has connected to kgdb.
+ */
+int kgdb_initialized = 0;
+volatile int kgdb_connected;
+
+/* Set to 1 to make kgdb allow access to user addresses. Can be set from gdb
+ * also at runtime. */
+#ifdef CONFIG_BLACKFIN
+int kgdb_useraccess = 1;
+#else
+int kgdb_useraccess = 0;
+#endif
+
+struct kgdb_serial *kgdb_serial;
+
+/*
+ * Holds information about breakpoints in a kernel. These breakpoints are
+ * added and removed by gdb.
+ */
+struct kgdb_bkpt kgdb_break[MAX_BREAKPOINTS];
+
+struct kgdb_arch *kgdb_ops = &arch_kgdb_ops;
+
+static const char hexchars[] = "0123456789abcdef";
+
+static spinlock_t slavecpulocks[NR_CPUS];
+static volatile int procindebug[NR_CPUS];
+atomic_t kgdb_setting_breakpoint;
+struct task_struct *kgdb_usethread, *kgdb_contthread;
+
+int debugger_step;
+atomic_t debugger_active;
+
+/* This will point to kgdb_handle_exception by default.
+ * The architecture code can override this in its init function
+ */
+gdb_debug_hook *linux_debug_hook;
+
+static char remcom_in_buffer[BUFMAX];
+static char remcom_out_buffer[BUFMAX];
+
+/**
+ *	kgdb_arch_init - Perform any architecture specific initalization.
+ *
+ *	RETURN:
+ *	The return value is ignored.
+ *
+ *	This function will handle the initalization of any architecture
+ *	specific hooks.  If there is a suitable early output driver,
+ *	kgdb_serial can be pointed at it now.
+ */
+int __attribute__ ((weak))
+    kgdb_arch_init(void)
+{
+	return 0;
+}
+
+/**
+ *	kgdb_disable_hw_debug - Disable hardware debugging while we in kgdb.
+ *	@regs: Current &struct pt_regs.
+ *
+ *	This function will be called if the particular architecture must
+ *	disable hardware debugging while it is processing gdb packets or
+ *	handling exception.
+ */
+void __attribute__ ((weak))
+    kgdb_disable_hw_debug(struct pt_regs *regs)
+{
+}
+
+/**
+ *	kgdb_set_hw_break - Set a hardware breakpoint at @addr.
+ *	@addr: The address to set a hardware breakpoint at.
+ */
+int __attribute__ ((weak))
+    kgdb_set_hw_break(unsigned long addr)
+{
+	return 0;
+}
+
+/**
+ *	kgdb_remove_hw_break - Remove a hardware breakpoint at @addr.
+ *	@addr: The address to remove a hardware breakpoint from.
+ */
+int __attribute__ ((weak))
+    kgdb_remove_hw_break(unsigned long addr)
+{
+	return 0;
+}
+
+/**
+ *	kgdb_remove_all_hw_break - Clear all hardware breakpoints.
+ */
+void __attribute__ ((weak))
+     kgdb_remove_all_hw_break(void)
+{
+}
+
+/**
+ *	kgdb_correct_hw_break - Correct hardware breakpoints.
+ *
+ *	A hook to allow for changes to the hardware breakpoint, called
+ *	after a single step (s) or continue (c) packet, and once we're about
+ *	to let the kernel continue running.
+ *
+ *	This is used to set the hardware breakpoint registers for all the
+ *	slave cpus on an SMP configuration. This must be called after any
+ *	changes are made to the hardware breakpoints (such as by a single
+ *	step (s) or continue (c) packet. This is only required on
+ *	architectures that support SMP and every processor has its own set
+ *	of breakpoint registers.
+ */
+void __attribute__ ((weak))
+    kgdb_correct_hw_break(void)
+{
+}
+
+/**
+ *	kgdb_post_master_code - Save error vector/code numbers.
+ *	@regs: Original pt_regs.
+ *	@eVector: Original error vector.
+ *	@err_code: Original error code.
+ *
+ *	This is needed on architectures which support SMP and KGDB.
+ *	This function is called after all the slave cpus have been put
+ *	to a know spin state and the master CPU has control over KGDB.
+ */
+
+void __attribute__ ((weak))
+    kgdb_post_master_code(struct pt_regs *regs, int eVector, int err_code)
+{
+}
+
+/**
+ *	kgdb_shadowinfo - Get shadowed information on @threadid.
+ *	@regs: The &struct pt_regs of the current process.
+ *	@buffer: A buffer of %BUFMAX size.
+ *	@threadid: The thread id of the shadowed process to get information on.
+ */
+void __attribute__ ((weak))
+    kgdb_shadowinfo(struct pt_regs *regs, char *buffer, unsigned threadid)
+{
+}
+
+/**
+ *	kgdb_get_shadow_thread - Get the shadowed &task_struct of @threadid.
+ *	@regs: The &struct pt_regs of the current thread.
+ *	@threadid: The thread id of the shadowed process to get information on.
+ *
+ *	RETURN:
+ *	This returns a pointer to the &struct task_struct of the shadowed
+ *	thread, @threadid.
+ */
+struct task_struct __attribute__ ((weak))
+    * kgdb_get_shadow_thread(struct pt_regs *regs, int threadid)
+{
+	return NULL;
+}
+
+/**
+ *	kgdb_shadow_regs - Return the shadowed registers of @threadid.
+ *	@regs: The &struct pt_regs of the current thread.
+ *	@threadid: The thread id we want the &struct pt_regs for.
+ *
+ *	RETURN:
+ *	The a pointer to the &struct pt_regs of the shadowed thread @threadid.
+ */
+struct pt_regs __attribute__ ((weak))
+    * kgdb_shadow_regs(struct pt_regs *regs, int threadid)
+{
+	return NULL;
+}
+
+static int hex(char ch)
+{
+	if ((ch >= 'a') && (ch <= 'f'))
+		return (ch - 'a' + 10);
+	if ((ch >= '0') && (ch <= '9'))
+		return (ch - '0');
+	if ((ch >= 'A') && (ch <= 'F'))
+		return (ch - 'A' + 10);
+	return (-1);
+}
+
+/* scan for the sequence $<data>#<checksum>	*/
+static void get_packet(char *buffer)
+{
+	unsigned char checksum;
+	unsigned char xmitcsum;
+	int count;
+	char ch;
+	
+	do {
+		/* wait around for the start character, ignore all other
+		 * characters */
+		while ((ch = (kgdb_serial->read_char() & 0x7f)) != '$')
+			;	/* Spin. */
+		kgdb_connected = 1;
+		checksum = 0;
+		xmitcsum = -1;
+
+		count = 0;
+
+		/* now, read until a # or end of buffer is found */
+		while (count < (BUFMAX - 1)) {
+			ch = kgdb_serial->read_char() & 0x7f;
+			if (ch == '#')
+				break;
+			checksum = checksum + ch;
+			buffer[count] = ch;
+			count = count + 1;
+		}
+		buffer[count] = 0;
+
+		if (ch == '#') {
+			xmitcsum = hex(kgdb_serial->read_char() & 0x7f) << 4;
+			xmitcsum += hex(kgdb_serial->read_char() & 0x7f);
+
+			if (checksum != xmitcsum)
+				kgdb_serial->write_char('-');	/* failed checksum */
+			else
+				kgdb_serial->write_char('+');	/* successful transfer */
+			if (kgdb_serial->flush)
+				kgdb_serial->flush();
+		}
+	} while (checksum != xmitcsum);
+}
+
+/*
+ * Send the packet in buffer.
+ * Check for gdb connection if asked for.
+ */
+static void put_packet(char *buffer)
+{
+	unsigned char checksum;
+	int count;
+	char ch;
+
+	/*  $<packet info>#<checksum>. */
+	while (1) {
+		kgdb_serial->write_char('$');
+		checksum = 0;
+		count = 0;
+
+		while ((ch = buffer[count])) {
+			kgdb_serial->write_char(ch);
+			checksum += ch;
+			count++;
+		}
+
+		kgdb_serial->write_char('#');
+		kgdb_serial->write_char(hexchars[checksum >> 4]);
+		kgdb_serial->write_char(hexchars[checksum % 16]);
+		if (kgdb_serial->flush)
+			kgdb_serial->flush();
+
+		/* Now see what we get in reply. */
+		ch = kgdb_serial->read_char();
+
+		if (ch == 3)
+			ch = kgdb_serial->read_char();
+
+		/* If we get an ACK, we are done. */
+		if (ch == '+')
+			return;
+
+		/* If we get the start of another packet, this means
+		 * that GDB is attempting to reconnect.  We will NAK
+		 * the packet being sent, and stop trying to send this
+		 * packet. */
+		if (ch == '$') {
+			kgdb_serial->write_char('-');
+			if (kgdb_serial->flush)
+				kgdb_serial->flush();
+			return;
+		}
+	}
+}
+
+static int get_char(char *addr, unsigned char *data)
+{
+	mm_segment_t fs;
+	int ret = 0;
+
+	if (!kgdb_useraccess && (unsigned long)addr < TASK_SIZE) {
+		return -EINVAL;
+	}
+	wmb();
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	if (get_user(*data, addr) != 0) {
+		ret = -EFAULT;
+	}
+
+	set_fs(fs);
+	return ret;
+}
+
+static int set_char(char *addr, int data)
+{
+	mm_segment_t fs;
+	int ret = 0;
+
+	if (!kgdb_useraccess && (unsigned long)addr < TASK_SIZE) {
+		return -EINVAL;
+	}
+	wmb();
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	if (put_user(data, addr) != 0) {
+		ret = -EFAULT;
+	}
+
+	set_fs(fs);
+	return ret;
+}
+
+/*
+ * convert the memory pointed to by mem into hex, placing result in buf
+ * return a pointer to the last char put in buf (null). May return an error.
+ */
+char *kgdb_mem2hex(char *mem, char *buf, int count)
+{
+	int i;
+	unsigned char ch;
+	int error;
+
+	for (i = 0; i < count; i++) {
+
+		if ((error = get_char(mem++, &ch)) < 0)
+			return ERR_PTR(error);
+
+		*buf++ = hexchars[ch >> 4];
+		*buf++ = hexchars[ch % 16];
+	}
+	*buf = 0;
+	return (buf);
+}
+
+/*
+ * convert the hex array pointed to by buf into binary to be placed in mem
+ * return a pointer to the character AFTER the last byte written
+ * May return an error.
+ */
+char *kgdb_hex2mem(char *buf, char *mem, int count)
+{
+	int i;
+	unsigned char ch;
+	int error;
+
+	for (i = 0; i < count; i++) {
+		ch = hex(*buf++) << 4;
+		ch = ch + hex(*buf++);
+		if ((error = set_char(mem++, ch)) < 0)
+			return ERR_PTR(error);
+	}
+	return (mem);
+}
+
+/*
+ * While we find nice hex chars, build a longValue.
+ * Return number of chars processed.
+ */
+int kgdb_hex2long(char **ptr, long *longValue)
+{
+	int numChars = 0;
+	int hexValue;
+
+	*longValue = 0;
+
+	while (**ptr) {
+		hexValue = hex(**ptr);
+		if (hexValue >= 0) {
+			*longValue = (*longValue << 4) | hexValue;
+			numChars++;
+		} else
+			break;
+
+		(*ptr)++;
+	}
+
+	return (numChars);
+}
+
+static inline char *pack_hex_byte(char *pkt, int byte)
+{
+	*pkt++ = hexchars[(byte >> 4) & 0xf];
+	*pkt++ = hexchars[(byte & 0xf)];
+	return pkt;
+}
+
+static inline void error_packet(char *pkt, int error)
+{
+	error = -error;
+	pkt[0] = 'E';
+	pkt[1] = hexchars[(error / 10)];
+	pkt[2] = hexchars[(error % 10)];
+	pkt[3] = '\0';
+}
+
+static char *pack_threadid(char *pkt, threadref * id)
+{
+	char *limit;
+	unsigned char *altid;
+
+	altid = (unsigned char *)id;
+	limit = pkt + BUF_THREAD_ID_SIZE;
+	while (pkt < limit)
+		pkt = pack_hex_byte(pkt, *altid++);
+
+	return pkt;
+}
+
+void int_to_threadref(threadref * id, int value)
+{
+	unsigned char *scan;
+
+	scan = (unsigned char *)id;
+	{
+		int i = 4;
+		while (i--)
+			*scan++ = 0;
+	}
+	*scan++ = (value >> 24) & 0xff;
+	*scan++ = (value >> 16) & 0xff;
+	*scan++ = (value >> 8) & 0xff;
+	*scan++ = (value & 0xff);
+}
+
+static struct task_struct *getthread(struct pt_regs *regs, int tid)
+{
+	int i;
+	struct task_struct *p;
+
+	if (tid >= pid_max + num_online_cpus() + kgdb_ops->shadowth) {
+		return NULL;
+	}
+	if (tid >= pid_max + num_online_cpus()) {
+		return kgdb_get_shadow_thread(regs, tid - pid_max -
+					      num_online_cpus());
+	}
+	if (tid >= pid_max) {
+		i = 0;
+		do_each_task_pid(0, PIDTYPE_PID, p) {
+			if (tid == pid_max + i) {
+				return p;
+			}
+			i++;
+		} while_each_task_pid(0, PIDTYPE_PID, p);
+		return NULL;
+	}
+	if (!tid) {
+		return NULL;
+	}
+	return find_task_by_pid(tid);
+}
+
+#ifdef CONFIG_SMP
+void kgdb_wait(struct pt_regs *regs)
+{
+	unsigned long flags;
+	int processor;
+
+	local_irq_save(flags);
+	processor = smp_processor_id();
+	procindebug[processor] = 1;
+	current->thread.debuggerinfo = regs;
+
+	/* Wait till master processor goes completely into the debugger.
+	 * FIXME: this looks racy */
+	while (!procindebug[atomic_read(&debugger_active) - 1]) {
+		int i = 10;	/* an arbitrary number */
+
+		while (--i)
+			cpu_relax();
+		barrier();
+	}
+
+	/* Wait till master processor is done with debugging */
+	spin_lock(slavecpulocks + processor);
+
+	/* This has been taken from x86 kgdb implementation and
+	 * will be needed by architectures that have SMP support
+	 */
+	kgdb_correct_hw_break();
+
+	current->thread.debuggerinfo = NULL;
+
+	/* Signal the master processor that we are done */
+	procindebug[processor] = 0;
+	spin_unlock(slavecpulocks + processor);
+	local_irq_restore(flags);
+}
+#endif
+
+int kgdb_get_mem(char *addr, unsigned char *buf, int count)
+{
+	int error;
+	while (count) {
+		if ((error = get_char(addr++, buf)) < 0)
+			return error;
+		buf++;
+		count--;
+	}
+	return 0;
+}
+
+static int set_mem(char *addr, unsigned char *buf, int count)
+{
+	int error;
+	while (count) {
+		if ((error = set_char(addr++, *buf++)) < 0)
+			return error;
+		count--;
+	}
+	return 0;
+}
+
+static int kgdb_set_sw_break(unsigned long addr)
+{
+	int i, breakno = -1;
+	int error;
+
+	for (i = 0; i < MAX_BREAKPOINTS; i++) {
+		if ((kgdb_break[i].state == bp_enabled) &&
+		    (kgdb_break[i].bpt_addr == addr)) {
+			return -EEXIST;
+		}
+
+		if (kgdb_break[i].state == bp_disabled) {
+			if ((breakno == -1) || (kgdb_break[i].bpt_addr == addr))
+				breakno = i;
+		}
+	}
+	if (breakno == -1)
+		return -E2BIG;
+
+	if ((error = kgdb_get_mem((char *)addr, kgdb_break[breakno].saved_instr,
+				  BREAK_INSTR_SIZE)) < 0)
+		return error;
+
+	if ((error = set_mem((char *)addr, kgdb_ops->gdb_bpt_instr,
+			     BREAK_INSTR_SIZE)) < 0)
+		return error;
+	flush_cache_range(current->mm, addr, addr + BREAK_INSTR_SIZE);
+	flush_icache_range(addr, addr + BREAK_INSTR_SIZE);
+
+	kgdb_break[breakno].state = bp_enabled;
+	kgdb_break[breakno].type = bp_breakpoint;
+	kgdb_break[breakno].bpt_addr = addr;
+
+	return 0;
+}
+
+static int kgdb_remove_sw_break(unsigned long addr)
+{
+	int i;
+	int error;
+
+	for (i = 0; i < MAX_BREAKPOINTS; i++) {
+		if ((kgdb_break[i].state == bp_enabled) &&
+		    (kgdb_break[i].bpt_addr == addr)) {
+			if ((error =
+			     set_mem((char *)addr, kgdb_break[i].saved_instr,
+				     BREAK_INSTR_SIZE)) < 0)
+				return error;
+			flush_cache_range(current->mm, addr,
+					  addr + BREAK_INSTR_SIZE);
+			flush_icache_range(addr, addr + BREAK_INSTR_SIZE);
+			kgdb_break[i].state = bp_disabled;
+			return 0;
+		}
+	}
+	return -ENOENT;
+}
+
+int remove_all_break(void)
+{
+	int i;
+	int error;
+
+	/* Clear memory breakpoints. */
+	for (i = 0; i < MAX_BREAKPOINTS; i++) {
+		if (kgdb_break[i].state == bp_enabled) {
+			unsigned long addr = kgdb_break[i].bpt_addr;
+			if ((error =
+			     set_mem((char *)addr, kgdb_break[i].saved_instr,
+				     BREAK_INSTR_SIZE)) < 0)
+				return error;
+			flush_cache_range(current->mm, addr,
+					  addr + BREAK_INSTR_SIZE);
+			flush_icache_range(addr, addr + BREAK_INSTR_SIZE);
+		}
+		kgdb_break[i].state = bp_disabled;
+	}
+
+	/* Clear hardware breakpoints. */
+	kgdb_remove_all_hw_break();
+
+	return 0;
+}
+
+static inline int shadow_pid(int realpid)
+{
+	if (realpid) {
+		return realpid;
+	}
+	return pid_max + smp_processor_id();
+}
+
+#ifdef CONFIG_KGDB_ETH
+extern void kgdb_enable_eth_irq(void);
+#endif
+
+/*
+ * This function does all command procesing for interfacing to gdb.
+ *
+ * Locking hierarchy:
+ *	interface locks, if any (begin_session)
+ *	kgdb lock (debugger_active)
+ *
+ */
+int kgdb_handle_exception(int exVector, int signo, int err_code,
+			  struct pt_regs *linux_regs)
+{
+	unsigned long length, addr;
+	char *ptr;
+	unsigned long flags;
+	unsigned long gdb_regs[NUMREGBYTES / sizeof(unsigned long)];
+	int i;
+	long threadid;
+	threadref thref;
+	struct task_struct *thread = NULL;
+	unsigned procid;
+	static char tmpstr[256];
+	int numshadowth = num_online_cpus() + kgdb_ops->shadowth;
+	long kgdb_usethreadid = 0;
+	int error = 0;
+	struct pt_regs *shadowregs;
+	
+	/* Panic on recursive debugger calls. */
+	if (atomic_read(&debugger_active) == smp_processor_id() + 1) {
+		return 0;
+	}
+
+#ifdef CONFIG_KGDB_ETH
+	netpoll_set_trap(1);
+#endif
+
+#ifdef CONFIG_BLACKFIN
+	if(debugger_step)
+		local_irq_enable();
+#endif
+	/* 
+	 * Interrupts will be restored by the 'trap return' code, except when
+	 * single stepping.
+	 */
+	local_irq_save(flags);
+
+	/* Hold debugger_active */
+	procid = smp_processor_id();
+	while (cmpxchg(&atomic_read(&debugger_active), 0, (procid + 1)) != 0) {
+		int i = 25;	/* an arbitrary number */
+
+		while (--i)
+			cpu_relax();
+	}
+
+	debugger_step = 0;
+
+	current->thread.debuggerinfo = linux_regs;
+
+	kgdb_disable_hw_debug(linux_regs);
+
+	for (i = 0; i < num_online_cpus(); i++) {
+		spin_lock(&slavecpulocks[i]);
+	}
+
+	/* spin_lock code is good enough as a barrier so we don't
+	 * need one here */
+	procindebug[smp_processor_id()] = 1;
+
+	/* Clear the out buffer. */
+	memset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));
+
+	/* Master processor is completely in the debugger */
+	kgdb_post_master_code(linux_regs, exVector, err_code);
+
+	if (kgdb_connected) {
+		/* reply to host that an exception has occurred */
+		ptr = remcom_out_buffer;
+		*ptr++ = 'T';
+		*ptr++ = hexchars[(signo >> 4) % 16];
+		*ptr++ = hexchars[signo % 16];
+		ptr += strlen(strcpy(ptr, "thread:"));
+		int_to_threadref(&thref, shadow_pid(current->pid));
+		ptr = pack_threadid(ptr, &thref);
+		*ptr++ = ';';
+
+		put_packet(remcom_out_buffer);
+	}
+
+	kgdb_usethread = current;
+	kgdb_usethreadid = shadow_pid(current->pid);
+	
+	while (1) {
+		char *bpt_type;
+		error = 0;
+
+		/* Clear the out buffer. */
+		memset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));
+
+		get_packet(remcom_in_buffer);
+
+		switch (remcom_in_buffer[0]) {
+		case '?':
+			/* We know that this packet is only sent
+			 * during initial connect.  So to be safe,
+			 * we clear out our breakpoints now incase
+			 * GDB is reconnecting. */
+			remove_all_break();
+			remcom_out_buffer[0] = 'S';
+			remcom_out_buffer[1] = hexchars[signo >> 4];
+			remcom_out_buffer[2] = hexchars[signo % 16];
+			break;
+
+		case 'g':	/* return the value of the CPU registers */
+			thread = kgdb_usethread;
+
+			if (!thread)
+				thread = current;
+
+			/* All threads that don't have debuggerinfo should be
+			   in __schedule() sleeping, since all other CPUs
+			   are in kgdb_wait, and thus have debuggerinfo. */
+
+			if (kgdb_usethreadid >= pid_max + num_online_cpus()) {
+				shadowregs = kgdb_shadow_regs(linux_regs,
+							      kgdb_usethreadid -
+							      pid_max -
+							      num_online_cpus
+							      ());
+				if (!shadowregs) {
+					error_packet(remcom_out_buffer,
+						     -EINVAL);
+					break;
+				}
+				regs_to_gdb_regs(gdb_regs, shadowregs);
+			} else if (thread->thread.debuggerinfo) {
+				if ((error =
+				     get_char(thread->thread.debuggerinfo,
+					      (unsigned char *)gdb_regs)) < 0) {
+					error_packet(remcom_out_buffer, error);
+					break;
+				}
+				regs_to_gdb_regs(gdb_regs, (struct pt_regs *)
+						 thread->thread.debuggerinfo);
+			} else {
+				/* Pull stuff saved during 
+				 * switch_to; nothing else is
+				 * accessible (or even particularly relevant).
+				 * This should be enough for a stack trace. */
+				sleeping_thread_to_gdb_regs(gdb_regs, thread);
+			}
+
+			kgdb_mem2hex((char *)gdb_regs, remcom_out_buffer,
+				     NUMREGBYTES);
+			break;
+
+		case 'G':	/* set the value of the CPU registers - return OK */
+			kgdb_hex2mem(&remcom_in_buffer[1], (char *)gdb_regs,
+				     NUMREGBYTES);
+
+			if (kgdb_usethread && kgdb_usethread != current)
+				error_packet(remcom_out_buffer, -EINVAL);
+			else {
+				gdb_regs_to_regs(gdb_regs, linux_regs);
+				strcpy(remcom_out_buffer, "OK");
+			}
+
+			break;
+
+			/* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
+		case 'm':
+			ptr = &remcom_in_buffer[1];
+			if (kgdb_hex2long(&ptr, &addr) > 0 && *ptr++ == ',' &&
+			    kgdb_hex2long(&ptr, &length) > 0) {
+				if (IS_ERR(ptr = kgdb_mem2hex((char *)addr,
+							      remcom_out_buffer,
+							      length)))
+					error_packet(remcom_out_buffer,
+						     PTR_ERR(ptr));
+			} else
+				error_packet(remcom_out_buffer, -EINVAL);
+			break;
+
+			/* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
+		case 'M':
+			ptr = &remcom_in_buffer[1];
+			if (kgdb_hex2long(&ptr, &addr) > 0 && *(ptr++) == ','
+			    && kgdb_hex2long(&ptr, &length) > 0 &&
+			    *(ptr++) == ':') {
+				if (IS_ERR(ptr = kgdb_hex2mem(ptr, (char *)addr,
+							      length)))
+					error_packet(remcom_out_buffer,
+						     PTR_ERR(ptr));
+			} else
+				error_packet(remcom_out_buffer, -EINVAL);
+			break;
+
+			/* kill or detach. KGDB should treat this like a 
+			 * continue.
+			 */
+		case 'D':
+			if ((error = remove_all_break()) < 0) {
+				error_packet(remcom_out_buffer, error);
+			} else {
+				strcpy(remcom_out_buffer, "OK");
+				kgdb_connected = 0;
+			}
+			put_packet(remcom_out_buffer);
+			goto default_handle;
+
+		case 'k':
+			/* Don't care about error from remove_all_break */
+			remove_all_break();
+			kgdb_connected = 0;
+			goto default_handle;
+
+			/* query */
+		case 'q':
+			switch (remcom_in_buffer[1]) {
+			case 's':
+			case 'f':
+				if (memcmp
+				    (remcom_in_buffer + 2, "ThreadInfo", 10)) {
+					error_packet(remcom_out_buffer,
+						     -EINVAL);
+					break;
+				}
+				if (remcom_in_buffer[1] == 'f') {
+					threadid = 1;
+				}
+				remcom_out_buffer[0] = 'm';
+				ptr = remcom_out_buffer + 1;
+				for (i = 0; i < 32 && threadid < pid_max +
+				     numshadowth; threadid++) {
+					thread = getthread(linux_regs,
+							   threadid);
+					if (thread) {
+						int_to_threadref(&thref,
+								 threadid);
+						pack_threadid(ptr, &thref);
+						ptr += 16;
+						*(ptr++) = ',';
+						i++;
+					}
+				}
+				*(--ptr) = '\0';
+				break;
+
+			case 'C':
+				/* Current thread id */
+				strcpy(remcom_out_buffer, "QC");
+
+				threadid = shadow_pid(current->pid);
+
+				int_to_threadref(&thref, threadid);
+				pack_threadid(remcom_out_buffer + 2, &thref);
+				break;
+			case 'T':
+				if (memcmp(remcom_in_buffer + 1,
+					   "ThreadExtraInfo,", 16)) {
+					error_packet(remcom_out_buffer,
+						     -EINVAL);
+					break;
+				}
+				threadid = 0;
+				ptr = remcom_in_buffer + 17;
+				kgdb_hex2long(&ptr, &threadid);
+				if (!getthread(linux_regs, threadid)) {
+					error_packet(remcom_out_buffer,
+						     -EINVAL);
+					break;
+				}
+				if (threadid < pid_max) {
+					kgdb_mem2hex(getthread(linux_regs,
+							       threadid)->comm,
+						     remcom_out_buffer, 16);
+				} else if (threadid >= pid_max +
+					   num_online_cpus()) {
+					kgdb_shadowinfo(linux_regs,
+							remcom_out_buffer,
+							threadid - pid_max -
+							num_online_cpus());
+				} else {
+					sprintf(tmpstr, "Shadow task %d"
+						" for pid 0",
+						(int)(threadid - pid_max));
+					kgdb_mem2hex(tmpstr, remcom_out_buffer,
+						     strlen(tmpstr));
+				}
+				break;
+			}
+			break;
+
+			/* task related */
+		case 'H':
+			switch (remcom_in_buffer[1]) {
+			case 'g':
+				ptr = &remcom_in_buffer[2];
+				kgdb_hex2long(&ptr, &threadid);
+				thread = getthread(linux_regs, threadid);
+				if (!thread && threadid > 0) {
+					error_packet(remcom_out_buffer,
+						     -EINVAL);
+					break;
+				}
+				kgdb_usethread = thread;
+				kgdb_usethreadid = threadid;
+				strcpy(remcom_out_buffer, "OK");
+				break;
+
+			case 'c':
+				ptr = &remcom_in_buffer[2];
+				kgdb_hex2long(&ptr, &threadid);
+				if (!threadid) {
+					kgdb_contthread = 0;
+				} else {
+					thread =
+					    getthread(linux_regs, threadid);
+					if (!thread && threadid > 0) {
+						error_packet(remcom_out_buffer,
+							     -EINVAL);
+						break;
+					}
+					kgdb_contthread = thread;
+				}
+				strcpy(remcom_out_buffer, "OK");
+				break;
+			}
+			break;
+
+			/* Query thread status */
+		case 'T':
+			ptr = &remcom_in_buffer[1];
+			kgdb_hex2long(&ptr, &threadid);
+			thread = getthread(linux_regs, threadid);
+			if (thread)
+				strcpy(remcom_out_buffer, "OK");
+			else
+				error_packet(remcom_out_buffer, -EINVAL);
+			break;
+		/* Since GDB-5.3, it's been drafted that '0' is a software
+		 * breakpoint, '1' is a hardware breakpoint, so let's do
+		 * that.
+		 */
+		case 'z':
+		case 'Z':
+			bpt_type = &remcom_in_buffer[1];
+			ptr = &remcom_in_buffer[2];
+
+			if (*bpt_type != '0' && *bpt_type != '1')
+				/* Unsupported. */
+				break;
+			/* Test if this is a hardware breakpoint, and
+			 * if we support it. */
+			if (*bpt_type == '1' && !(kgdb_ops->flags &
+						KGDB_HW_BREAKPOINT))
+				/* Unsupported. */
+				break;
+
+			if (*(ptr++) != ',') {
+				error_packet(remcom_out_buffer, -EINVAL);
+				break;
+			}
+			kgdb_hex2long(&ptr, &addr);
+
+			if (remcom_in_buffer[0] == 'Z' && *bpt_type == '0')
+				error = kgdb_set_sw_break(addr);
+			else if (remcom_in_buffer[0] == 'Z' && *bpt_type == '1')
+				error = kgdb_set_hw_break(addr);
+			else if (remcom_in_buffer[0] == 'z' && *bpt_type == '0')
+				error = kgdb_remove_sw_break(addr);
+			else if (remcom_in_buffer[0] == 'z' && *bpt_type == '1')
+				error = kgdb_remove_hw_break(addr);
+
+			if (error == 0)
+				strcpy(remcom_out_buffer, "OK");
+			else
+				error_packet(remcom_out_buffer, error);
+
+			break;
+
+		default:
+		      default_handle:
+			error = kgdb_arch_handle_exception(exVector, signo,
+							   err_code,
+							   remcom_in_buffer,
+							   remcom_out_buffer,
+							   linux_regs);
+
+			if (error >= 0 || remcom_in_buffer[0] == 'D' ||
+			    remcom_in_buffer[0] == 'k')
+				goto kgdb_exit;
+
+		}		/* switch */
+
+		/* reply to the request */
+		put_packet(remcom_out_buffer);
+	}
+
+      kgdb_exit:
+
+	current->thread.debuggerinfo = NULL;
+	procindebug[smp_processor_id()] = 0;
+
+	for (i = 0; i < num_online_cpus(); i++) {
+		spin_unlock(&slavecpulocks[i]);
+	}
+	/* Wait till all the processors have quit
+	 * from the debugger 
+	 */
+	for (i = 0; i < num_online_cpus(); i++) {
+		while (procindebug[i]) {
+			int j = 10;	/* an arbitrary number */
+
+			while (--j)
+				cpu_relax();
+			barrier();
+		}
+	}
+
+	/* Free debugger_active */
+	atomic_set(&debugger_active, 0);
+	local_irq_restore(flags);
+
+#ifdef CONFIG_BLACKFIN
+	if(debugger_step)
+		local_irq_disable();
+#endif
+
+#ifdef CONFIG_KGDB_ETH
+	netpoll_set_trap(0);
+#endif
+
+	return error;
+}
+
+/*
+ * GDB places a breakpoint at this function to know dynamically
+ * loaded objects. It's not defined static so that only one instance with this
+ * name exists in the kernel.
+ */
+
+int module_event(struct notifier_block *self, unsigned long val, void *data)
+{
+	return 0;
+}
+
+static struct notifier_block kgdb_module_load_nb = {
+	.notifier_call = module_event,
+};
+
+/*
+ * Sometimes we need to schedule a breakpoint because we can't break
+ * right where we are.
+ */
+static int kgdb_need_breakpoint[NR_CPUS];
+
+void kgdb_schedule_breakpoint(void)
+{
+	kgdb_need_breakpoint[smp_processor_id()] = 1;
+}
+
+void kgdb_process_breakpoint(void)
+{
+	/*
+	 * Handle a breakpoint queued from inside network driver code
+	 * to avoid reentrancy issues
+	 */
+	if (kgdb_serial && kgdb_need_breakpoint[smp_processor_id()]) {
+		kgdb_need_breakpoint[smp_processor_id()] = 0;
+		breakpoint();
+	}
+}
+
+void kgdb_nmihook(int cpu, void *regs)
+{
+#ifdef CONFIG_SMP
+	if (!procindebug[cpu] && atomic_read(&debugger_active) != (cpu + 1)) {
+		kgdb_wait((struct pt_regs *)regs);
+	}
+#endif
+}
+
+static void kgdb_entry(void)
+{
+	int i;
+
+	if (kgdb_initialized) {
+		/* KGDB was initialized */
+		return;
+	}
+
+	for (i = 0; i < NR_CPUS; i++)
+		spin_lock_init(&slavecpulocks[i]);
+
+	for (i = 0; i < MAX_BREAKPOINTS; i++)
+		kgdb_break[i].state = bp_disabled;
+
+	linux_debug_hook = kgdb_handle_exception;
+
+	/* Let the arch do any initalization it needs do. */
+	kgdb_arch_init();
+
+	/* Ethernet might be ready now */
+#ifdef CONFIG_KGDB_ETH
+	if (!kgdb_serial)
+		init_kgdboe();
+#endif
+	if (!kgdb_serial || kgdb_serial->hook() < 0) {
+		/* KGDB interface isn't ready yet */
+		return;
+	}
+
+	/* We can't do much if this fails */
+	register_module_notifier(&kgdb_module_load_nb);
+
+	/* Clear things. */
+	atomic_set(&debugger_active, 0);
+	atomic_set(&kgdb_setting_breakpoint, 0);
+	memset(kgdb_need_breakpoint, 0, sizeof(kgdb_need_breakpoint));
+
+	kgdb_initialized = 1;
+}
+
+/*
+ * This function will generate a breakpoint exception.  It is used at the
+ * beginning of a program to sync up with a debugger and can be used
+ * otherwise as a quick means to stop program execution and "break" into
+ * the debugger.
+ */
+void breakpoint(void)
+{
+	if (!kgdb_initialized) {
+		kgdb_entry();
+		if (!kgdb_initialized) {
+#ifdef CONFIG_KGDB_BLACKFIN_SHAREDUART
+			kgdb_print(KERN_CRIT "KGDB cannot initialize, cannot "
+					"perform a breakpoint.\n\t");
+#else
+			printk(KERN_CRIT "KGDB cannot initialize, cannot "
+					"perform a breakpoint.\n");
+#endif
+			return;
+		} else
+#ifdef CONFIG_KGDB_BLACKFIN_SHAREDUART
+			kgdb_print(KERN_CRIT "Waiting for connection from remote "
+					"gdb...\n\t");
+#else
+			printk(KERN_CRIT "Waiting for connection from remote "
+					"gdb...\n");
+#endif
+	}
+	atomic_set(&kgdb_setting_breakpoint, 1);
+	wmb();
+	BREAKPOINT();
+	wmb();
+	atomic_set(&kgdb_setting_breakpoint, 0);
+}
+EXPORT_SYMBOL(breakpoint);
+
+#ifdef CONFIG_KGDB_CONSOLE
+char kgdbconbuf[BUFMAX];
+
+void kgdb_console_write(struct console *co, const char *s, unsigned count)
+{
+	int i;
+	int wcount;
+	char *bufptr;
+	unsigned long flags;
+
+	/* If we're debugging, or KGDB has not connected, don't try
+	 * and print. */
+	if (!kgdb_connected || atomic_read(&debugger_active) != 0)
+		return;
+
+	local_irq_save(flags);
+
+	kgdbconbuf[0] = 'O';
+	bufptr = kgdbconbuf + 1;
+	while (count > 0) {
+		if ((count << 1) > (BUFMAX - 2)) {
+			wcount = (BUFMAX - 2) >> 1;
+		} else {
+			wcount = count;
+		}
+		count -= wcount;
+		for (i = 0; i < wcount; i++) {
+			bufptr = pack_hex_byte(bufptr, s[i]);
+		}
+		*bufptr = '\0';
+		s += wcount;
+
+		put_packet(kgdbconbuf);
+
+	}
+	local_irq_restore(flags);
+}
+
+/* Always fail so that kgdb console doesn't become the default console */
+static int __init kgdb_console_setup(struct console *co, char *options)
+{
+	return -1;
+}
+
+static struct console kgdbcons = {
+	.name = "kgdb",
+	.write = kgdb_console_write,
+	.setup = kgdb_console_setup,
+	.flags = CON_PRINTBUFFER | CON_ENABLED,
+	.index = -1,
+};
+
+static int __init kgdb_console_init(void)
+{
+	register_console(&kgdbcons);
+	return 0;
+}
+
+console_initcall(kgdb_console_init);
+#endif
+
+static int __init opt_kgdb_enter(char *str)
+{
+	/*
+	 * We want to break in early.  If kgdb_serial is set, we break now.
+	 * Otherwise we schedule a breakpoint.
+	 */
+	if (kgdb_serial)
+		breakpoint();
+	else
+		kgdb_schedule_breakpoint();
+
+	return 0;
+}
+
+static int __init opt_gdb(char *str)
+{
+	return opt_kgdb_enter(str);
+}
+
+/*
+ * These options have been deprecated and are present only to maintain
+ * compatibility with kgdb for 2.4 and earlier kernels.
+ */
+#ifdef CONFIG_KGDB_8250
+extern int kgdb8250_baud;
+extern int kgdb8250_ttyS;
+static int __init opt_gdbttyS(char *str)
+{
+	kgdb8250_ttyS = simple_strtoul(str, NULL, 10);
+	return 1;
+}
+static int __init opt_gdbbaud(char *str)
+{
+	kgdb8250_baud = simple_strtoul(str, NULL, 10);
+	return 1;
+}
+#endif
+
+/*
+ *
+ * Sequence of following lines has to be maintained because gdb option is a
+ * prefix of the other two options
+ */
+
+#ifdef CONFIG_KGDB_8250
+__setup("gdbttyS=", opt_gdbttyS);
+__setup("gdbbaud=", opt_gdbbaud);
+#endif
+__setup("gdb", opt_gdb);
+__setup("kgdbwait", opt_kgdb_enter);
diff -urN linux-2.6.x.old/kernel/sched.c linux-2.6.x/kernel/sched.c
--- linux-2.6.x.old/kernel/sched.c	2005-09-16 13:18:34.411438728 +0800
+++ linux-2.6.x/kernel/sched.c	2005-09-16 13:18:47.914385968 +0800
@@ -43,6 +43,7 @@
 #include <linux/cpuset.h>
 #include <linux/percpu.h>
 #include <linux/kthread.h>
+#include <linux/debugger.h>
 #include <linux/seq_file.h>
 #include <linux/syscalls.h>
 #include <linux/times.h>
@@ -4978,6 +4979,9 @@
 #if defined(in_atomic)
 	static unsigned long prev_jiffy;	/* ratelimiting */
 
+	if (atomic_read(&debugger_active))
+		return;
+
 	if ((in_atomic() || irqs_disabled()) &&
 	    system_state == SYSTEM_RUNNING && !oops_in_progress) {
 		if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)
diff -urN linux-2.6.x.old/net/core/netpoll.c linux-2.6.x/net/core/netpoll.c
--- linux-2.6.x.old/net/core/netpoll.c	2005-09-16 13:18:34.702394496 +0800
+++ linux-2.6.x/net/core/netpoll.c	2005-09-16 13:18:47.925384296 +0800
@@ -304,6 +304,7 @@
 	if (!skb)
 		return;
 
+	skb_reserve(skb, 2);
 	memcpy(skb->data, msg, len);
 	skb->len += len;
 
