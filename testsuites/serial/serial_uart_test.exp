#!/usr/bin/expect
#

#Test program to test extended UART.
#Be sure two serial cables are available and connected correctly.
#And the kernel is booted up with eth0 enabled.
#

source ../kernel_config.exp
source ../board_info.exp
log_file [log_file_name "$argv0"]
send_user "Starting $argv0\n"

set argc [llength $argv]

if { $argc < 1} {
puts "Please input: board_type [ port type : serial_uart or sport_uart ] [line connection: normal or switch] ."
exit
}

set port_type serial_uart
if { $argc >= 2} {
set port_type [lindex $argv 1]
}

set line_connection normal 
if { $argc >= 3} {
set line_connection [lindex $argv 2]
}

if { $line_connection == "normal" } {

set kermit_ttydev $ttydev
set ttydev_for_testcase_use $ttyUSBdev

} elseif { $line_connection == "switch" } {

set kermit_ttydev $ttyUSBdev
set ttydev_for_testcase_use $ttydev
}

if {  $port_type== "sport_uart" } {

set bootargs             $bootargs_param7
set ttyBFdev /dev/ttySS0

} elseif { $port_type== "serial_uart" } {

if { $board_type == "BF527-EZKIT" } {
set bootargs             $bootargs_param8
set ttyBFdev /dev/ttyBF0
} else {
set bootargs             $bootargs_param7
set ttyBFdev /dev/ttyBF1
}
}

puts "port_type $port_type ttydev_for_testcase_use $ttydev_for_testcase_use"

step "Start kermit."
source ../spawn_kermit.exp

step "Reboot the kernel."
source ../reboot_kernel.exp

send_log "\nStarting test for UART ...\n"
set TITLE [title "$argv0"]
append TITLE " ($port_type)"

set ttyflags "-icrnl -ixon igncr -opost -onlcr -isig -icanon -iexten -echo -echoe -echok -echoke -hupcl -echoctl -parenb -parodd cs8 hupcl -cstopb cread clocal -crtscts min 1 time 0"
set bits_number 8
set target_file aaa
set host_file bbb
set save_file ccc
set command "/proc/kallsyms"
#set command "/proc/cmdline"

send_log "*********************************\r"
send_log "Start $TITLE\r"
send_log "*********************************\r"

set case_num 0
set target_default_id $spawn_id
###
### Case 1 is sending file from  host to target.
### Catted file would have "\r\n" as line end, while on target unix file only use "\n" as line terminator,
### so use igncr to set target tty device not to add "\n" sign.
###

set timeout 3
sleep 3
spawn  /bin/sh
set target_id $spawn_id
expect  -re  $sh_prompt

### This case is sending file from  host to target.

send -s "telnet $targetip\r"
while 1 {
        expect {
                -re  "$kernel_prompt" { break  }
                timeout {
                      send_user "Failed inital telnet\n"
                      exit }
        }
}

incr case_num
set timeout 5

send "\r"
expect -re  $kernel_prompt

send -s "cat $command > $save_file \r"
while 1 {
        expect {
                -re  "$kernel_prompt" { break  }
                timeout {
                     send_user "Failed to save file.\n"
                     exit }
        }
}

send -s "stty -F $ttyBFdev cs$bits_number ispeed $baud_rate ospeed $baud_rate $ttyflags\r"
while 1 {
        expect {
                -re  "$kernel_prompt" { break  }
                timeout {
                     send_user "Failed to set uart speed.\n"
                     exit }
        }
}

send -s "stty -F $ttyBFdev -a\r"
while 1 {
        expect {
                -re  "$kernel_prompt" { break  }
                timeout {
                     send_user "Failed to set uart speed.\n"
                     exit }
        }
}
send -s "cat $ttyBFdev > $target_file \r"
while 1 {
        expect {
                -re  "$kernel_prompt" {
                      case_fail $case_num
                      }
                timeout {
                      break }
        }
}


spawn /bin/sh
set host_sh_id $spawn_id
expect  -re  $sh_prompt

send -s "rcp root@$targetip:/$save_file . \r"
while 1 {
        expect {
                -re  "$sh_prompt" { break  }
                timeout {
                     send_user "Failed to rcp $target_file to host.\n"
                     exit }
        }
}

while 1 {
send -s "stty -F $ttydev_for_testcase_use cs$bits_number ispeed $baud_rate ospeed $baud_rate $ttyflags\r"
expect {
        -re  "$sh_prompt" {
          break }
         timeout {
          puts " set $ttydev_for_testcase_use failed...\n"
          break
         }
}
}
set timeout 60
while 1 {
send -s " cat $save_file > $ttydev_for_testcase_use  \r"
expect {
        -re  "$sh_prompt" { 
          break }
         timeout {
          puts " send data failed...\n"
          break
         }
}
}

while 1 {
send -s "stty -F $ttydev_for_testcase_use -a \r"
expect {
        -re  "speed.*$sh_prompt" {
          break }
         timeout {
          puts " set $ttydev_for_testcase_use failed...\n"
          break
         }
}
}
set spawn_id $target_id
set timeout 5
sleep 3
while 1 {
expect {
        -re  "$kernel_prompt" {
          puts "Fail to wait.\n"
          case_fail $case_num
          break }
         timeout {
          puts "\nStill wait.\n"
          break
         }
}
}

send "\3"
send "\r"
while 1 {
expect {
        -re "$kernel_prompt" {
          send_log "Catted file is got on target.\n" 
          break }
          timeout {
          case_fail $case_num
         }
}
}

set timeout 10
send -s "diff -u $save_file $target_file \r"
while 1 {
expect {
         -re "\\\+\\\+\\\+" {
                         expect -re  "$kernel_prompt"
                         send_log "\nTwo files diffs.\n "
                         case_fail $case_num
                         break
                          }
          "differ"
                      {
                         send_log "Two files diffs!\n"
                         case_fail $case_num
                         break
                        }

          timeout
                      {
                         expect -re  "$kernel_prompt"
                         send_log "Success case.\n"
                         case_pass $case_num
                         break
                        }
         }
}
######################################################################
###
### Case 2 is sending file from target to host.
### Here use igncr to host tty device not to add "\n" sign.
###
set timeout 5
incr case_num

set spawn_id $target_id
send -s "stty -F $ttyBFdev cs$bits_number ispeed $baud_rate ospeed $baud_rate $ttyflags\r"
while 1 {
        expect {
                -re  "$kernel_prompt" { break  }
                timeout {
                     send_user "Failed to set uart speed.\n"
                     exit }
        }
}
set spawn_id $host_sh_id
sleep 3
send "ls\r"
expect -re  "$sh_prompt"

send -s "stty -F $ttydev_for_testcase_use cs$bits_number ispeed $baud_rate ospeed $baud_rate $ttyflags\r"
while 1 {
        expect {
                -re  "$sh_prompt" { break  }
                timeout {
                     send_user "Failed to set uart speed.\n"
                     exit }
        }
}

while 1 {
send -s "cat $ttydev_for_testcase_use > $host_file \r"
expect {
        -re  "$sh_prompt" {
          puts "Fail to cat on host.\n"
          case_fail $case_num
          break }
         timeout {
          puts "wait for receiving data...\n"
          break
         }
}
}

set spawn_id $target_id
set timeout 100
while 1 {
send -s "cat $save_file > $ttyBFdev \r"
        expect {
              -re  "$kernel_prompt" {
                      break }
                timeout { send_user "Failed to cat file\n"
                        exit }
        }

}
set spawn_id $host_sh_id
set timeout 5
sleep 5
while 1 {
expect {
        -re  "$sh_prompt" {
          puts "Fail to wait.\n"
          case_fail $case_num
          break }
         timeout {
          puts "\nStill wait.\n"
          break
         }
}
}
send -s "\3"
while 1 {
expect {
        -re  "$sh_prompt" {
          break }
         timeout {
          puts "Failed to come out.\n"
          break
         }
}
}
#send -s "cat $host_file \r"
#while 1 {
#expect {
#       -re  "$sh_prompt" {
#         break}
#        timeout {
#         puts "Failed to cat file.\n"}
#}
#}
set timeout 10
send -s "diff -u $save_file $host_file \r"
while 1 {
expect {
         -re "\\\+\\\+\\\+" {
                         expect -re  "$sh_prompt"
                         send_log "\nTwo files diffs.\n "
                         case_fail $case_num
                         break
                          }
          "differ"
                      {
                         send_log "Two files diffs!\n"
                         case_fail $case_num
                         break
                        }

          timeout
                      {
                         expect -re  "$sh_prompt"
                         send_log "Success case.\n"
                         case_pass $case_num
                         break
                        }
         }
}
###
### Case 3 is to check if it can use the extend ttyBF port as default console to boot up kernel.
###

step "Convert the console to the extend UART."

set spawn_id $target_default_id
set console [file tail $ttyBFdev]
append bootargs_param7 " console=$console,57600n$bits_number"
set bootargs             $bootargs_param7
source ../reboot_kernel.exp

set timeout 3
incr case_num

    send -s "\x81"
    send -s "c"
    while 1 {
        expect {
            "ermit>" {
                send -s "q\r"
                expect -re ">"
                set back_flag SUCCESS
                break
            }

            timeout {
                send_user "ERROR: back to kermit error\n"
                break
            }
        }
    }

step "Start kermit."
if { $line_connection == "normal" } {

set kermit_ttydev $ttyUSBdev 

} elseif { $line_connection == "switch" } {

set kermit_ttydev $ttydev
}
source ../spawn_kermit.exp
set timeout 20

    expect -re "$kernel_prompt"
    send -s "ls\r"
    while 1 {
        expect {
            -re "$kernel_prompt" {
                case_pass $case_num
                break
            }

            timeout {
                case_fail $case_num
                send_user "The console is not active.\n"
                exit
            }
        }
}



send_log "\n"
send_log "\n$TITLE ............\[PASS\]\n"

send_user "Ending $argv0\n"
log_file

